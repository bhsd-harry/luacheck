(()=>{var da=Object.create;var yt=Object.defineProperty;var ua=Object.getOwnPropertyDescriptor;var _a=Object.getOwnPropertyNames;var ca=Object.getPrototypeOf,fa=Object.prototype.hasOwnProperty;var Be=(h=>typeof require!="undefined"?require:typeof Proxy!="undefined"?new Proxy(h,{get:(P,W)=>(typeof require!="undefined"?require:P)[W]}):h)(function(h){if(typeof require!="undefined")return require.apply(this,arguments);throw Error('Dynamic require of "'+h+'" is not supported')});var wt=(h,P)=>()=>(P||h((P={exports:{}}).exports,P),P.exports);var pa=(h,P,W,me)=>{if(P&&typeof P=="object"||typeof P=="function")for(let se of _a(P))!fa.call(h,se)&&se!==W&&yt(h,se,{get:()=>P[se],enumerable:!(me=ua(P,se))||me.enumerable});return h};var ma=(h,P,W)=>(W=h!=null?da(ca(h)):{},pa(P||!h||!h.__esModule?yt(W,"default",{value:h,enumerable:!0}):W,h));var kt=wt((Xe,vt)=>{(function(h,P){typeof Xe=="object"&&typeof vt!="undefined"?P(Xe):typeof define=="function"&&define.amd?define(["exports"],P):(h=typeof globalThis!="undefined"?globalThis:h||self,P(h.wasmoon={}))})(Xe,function(h){"use strict";var P=typeof document!="undefined"?document.currentScript:null;h.LuaReturn=void 0,function(m){m[m.Ok=0]="Ok",m[m.Yield=1]="Yield",m[m.ErrorRun=2]="ErrorRun",m[m.ErrorSyntax=3]="ErrorSyntax",m[m.ErrorMem=4]="ErrorMem",m[m.ErrorErr=5]="ErrorErr",m[m.ErrorFile=6]="ErrorFile"}(h.LuaReturn||(h.LuaReturn={}));let W=4,me=-1,se=1e6,$=-se-1e3;h.LuaType=void 0,function(m){m[m.None=-1]="None",m[m.Nil=0]="Nil",m[m.Boolean=1]="Boolean",m[m.LightUserdata=2]="LightUserdata",m[m.Number=3]="Number",m[m.String=4]="String",m[m.Table=5]="Table",m[m.Function=6]="Function",m[m.Userdata=7]="Userdata",m[m.Thread=8]="Thread"}(h.LuaType||(h.LuaType={})),h.LuaEventCodes=void 0,function(m){m[m.Call=0]="Call",m[m.Ret=1]="Ret",m[m.Line=2]="Line",m[m.Count=3]="Count",m[m.TailCall=4]="TailCall"}(h.LuaEventCodes||(h.LuaEventCodes={})),h.LuaEventMasks=void 0,function(m){m[m.Call=1]="Call",m[m.Ret=2]="Ret",m[m.Line=4]="Line",m[m.Count=8]="Count"}(h.LuaEventMasks||(h.LuaEventMasks={})),h.LuaLibraries=void 0,function(m){m.Base="_G",m.Coroutine="coroutine",m.Table="table",m.IO="io",m.OS="os",m.String="string",m.UTF8="utf8",m.Math="math",m.Debug="debug",m.Package="package"}(h.LuaLibraries||(h.LuaLibraries={}));class Qe extends Error{}class Z{constructor(t,s){this.target=t,this.options=s}}function Tt(m,t){return new Z(m,t)}class An extends Number{}class he extends Array{}let Et=1e3;class ge{constructor(t,s,d,l){this.closed=!1,this.lua=t,this.typeExtensions=s,this.address=d,this.parent=l}newThread(){let t=this.lua.lua_newthread(this.address);if(!t)throw new Error("lua_newthread returned a null pointer");return new ge(this.lua,this.typeExtensions,t,this.parent||this)}resetThread(){this.assertOk(this.lua.lua_resetthread(this.address))}loadString(t,s){let d=this.lua.module.lengthBytesUTF8(t),l=d+1,p=this.lua.module._malloc(l);try{this.lua.module.stringToUTF8(t,p,l),this.assertOk(this.lua.luaL_loadbufferx(this.address,p,d,s!=null?s:p,null))}finally{this.lua.module._free(p)}}loadFile(t){this.assertOk(this.lua.luaL_loadfilex(this.address,t,null))}resume(t=0){let s=this.lua.module._malloc(W);try{return this.lua.module.setValue(s,0,"i32"),{result:this.lua.lua_resume(this.address,null,t,s),resultCount:this.lua.module.getValue(s,"i32")}}finally{this.lua.module._free(s)}}getTop(){return this.lua.lua_gettop(this.address)}setTop(t){this.lua.lua_settop(this.address,t)}remove(t){return this.lua.lua_remove(this.address,t)}setField(t,s,d){t=this.lua.lua_absindex(this.address,t),this.pushValue(d),this.lua.lua_setfield(this.address,t,s)}async run(t=0,s){let d=this.timeout;try{(s==null?void 0:s.timeout)!==void 0&&this.setTimeout(Date.now()+s.timeout);let l=this.resume(t);for(;l.result===h.LuaReturn.Yield;){if(this.timeout&&Date.now()>this.timeout)throw l.resultCount>0&&this.pop(l.resultCount),new Qe("thread timeout exceeded");if(l.resultCount>0){let p=this.getValue(-1);this.pop(l.resultCount),p===Promise.resolve(p)?await p:await new Promise(w=>setImmediate(w))}else await new Promise(p=>setImmediate(p));l=this.resume(0)}return this.assertOk(l.result),this.getStackValues()}finally{(s==null?void 0:s.timeout)!==void 0&&this.setTimeout(d)}}runSync(t=0){let s=this.getTop()-t-1;return this.assertOk(this.lua.lua_pcallk(this.address,t,me,0,0,null)),this.getStackValues(s)}pop(t=1){this.lua.lua_pop(this.address,t)}call(t,...s){let d=this.lua.lua_getglobal(this.address,t);if(d!==h.LuaType.Function)throw new Error(`A function of type '${d}' was pushed, expected is ${h.LuaType.Function}`);for(let p of s)this.pushValue(p);let l=this.getTop()-s.length-1;return this.lua.lua_callk(this.address,s.length,me,0,null),this.getStackValues(l)}getStackValues(t=0){let s=this.getTop()-t,d=new he(s);for(let l=0;l<s;l++)d[l]=this.getValue(t+l+1);return d}stateToThread(t){var s;return t===((s=this.parent)===null||s===void 0?void 0:s.address)?this.parent:new ge(this.lua,this.typeExtensions,t,this.parent||this)}pushValue(t,s){let d=this.getValueDecorations(t),l=d.target;if(l instanceof ge){this.lua.lua_pushthread(l.address)===1||this.lua.lua_xmove(l.address,this.address,1);return}let p=this.getTop();switch(typeof l){case"undefined":this.lua.lua_pushnil(this.address);break;case"number":Number.isInteger(l)?this.lua.lua_pushinteger(this.address,BigInt(l)):this.lua.lua_pushnumber(this.address,l);break;case"string":this.lua.lua_pushstring(this.address,l);break;case"boolean":this.lua.lua_pushboolean(this.address,l?1:0);break;default:if(!this.typeExtensions.find(w=>w.extension.pushValue(this,d,s)))throw new Error(`The type '${typeof l}' is not supported by Lua`)}if(d.options.metatable&&this.setMetatable(-1,d.options.metatable),this.getTop()!==p+1)throw new Error(`pushValue expected stack size ${p+1}, got ${this.getTop()}`)}setMetatable(t,s){if(t=this.lua.lua_absindex(this.address,t),this.lua.lua_getmetatable(this.address,t)){this.pop(1);let d=this.getMetatableName(t);throw new Error(`data already has associated metatable: ${d||"unknown name"}`)}this.pushValue(s),this.lua.lua_setmetatable(this.address,t)}getMetatableName(t){let s=this.lua.luaL_getmetafield(this.address,t,"__name");if(s===h.LuaType.Nil)return;if(s!==h.LuaType.String){this.pop(1);return}let d=this.lua.lua_tolstring(this.address,-1,null);return this.pop(1),d}getValue(t,s,d){t=this.lua.lua_absindex(this.address,t);let l=s!=null?s:this.lua.lua_type(this.address,t);switch(l){case h.LuaType.None:return;case h.LuaType.Nil:return null;case h.LuaType.Number:return this.lua.lua_tonumberx(this.address,t,null);case h.LuaType.String:return this.lua.lua_tolstring(this.address,t,null);case h.LuaType.Boolean:return!!this.lua.lua_toboolean(this.address,t);case h.LuaType.Thread:return this.stateToThread(this.lua.lua_tothread(this.address,t));default:{let p;(l===h.LuaType.Table||l===h.LuaType.Userdata)&&(p=this.getMetatableName(t));let w=this.typeExtensions.find(S=>S.extension.isType(this,t,l,p));return w?w.extension.getValue(this,t,d):(console.warn(`The type '${this.lua.lua_typename(this.address,l)}' returned is not supported on JS`),new An(this.lua.lua_topointer(this.address,t)))}}}close(){this.isClosed()||(this.hookFunctionPointer&&this.lua.module.removeFunction(this.hookFunctionPointer),this.closed=!0)}setTimeout(t){t&&t>0?(this.hookFunctionPointer||(this.hookFunctionPointer=this.lua.module.addFunction(()=>{Date.now()>t&&(this.pushValue(new Qe("thread timeout exceeded")),this.lua.lua_error(this.address))},"vii")),this.lua.lua_sethook(this.address,this.hookFunctionPointer,h.LuaEventMasks.Count,Et),this.timeout=t):this.hookFunctionPointer&&(this.hookFunctionPointer=void 0,this.timeout=void 0,this.lua.lua_sethook(this.address,null,0,0))}getTimeout(){return this.timeout}getPointer(t){return new An(this.lua.lua_topointer(this.address,t))}isClosed(){var t;return!this.address||this.closed||!!(!((t=this.parent)===null||t===void 0)&&t.isClosed())}indexToString(t){let s=this.lua.luaL_tolstring(this.address,t,null);return this.pop(),s}dumpStack(t=console.log){let s=this.getTop();for(let d=1;d<=s;d++){let l=this.lua.lua_type(this.address,d),p=this.lua.lua_typename(this.address,l),w=this.getPointer(d),S=this.indexToString(d),x=this.getValue(d,l);t(d,p,w,S,x)}}assertOk(t){if(t!==h.LuaReturn.Ok&&t!==h.LuaReturn.Yield){let s=h.LuaReturn[t],d=new Error(`Lua Error(${s}/${t})`);if(this.getTop()>0)if(t===h.LuaReturn.ErrorMem)d.message=this.lua.lua_tolstring(this.address,-1,null);else{let l=this.getValue(-1);l instanceof Error&&(d.stack=l.stack),d.message=this.indexToString(-1)}if(t!==h.LuaReturn.ErrorMem)try{this.lua.luaL_traceback(this.address,this.address,null,1);let l=this.lua.lua_tolstring(this.address,-1,null);l.trim()!=="stack traceback:"&&(d.message=`${d.message}
${l}`),this.pop(1)}catch(l){console.warn("Failed to generate stack trace",l)}throw d}}getValueDecorations(t){return t instanceof Z?t:new Z(t,{})}}class On extends ge{constructor(t,s){if(s){let d={memoryUsed:0},l=t.module.addFunction((w,S,x,I)=>{if(I===0)return S&&(d.memoryUsed-=x,t.module._free(S)),0;let F=S?I-x:I,D=d.memoryUsed+F;if(I>x&&d.memoryMax&&D>d.memoryMax)return 0;let B=t.module._realloc(S,I);return B&&(d.memoryUsed=D),B},"iiiii"),p=t.lua_newstate(l,null);if(!p)throw t.module.removeFunction(l),new Error("lua_newstate returned a null pointer");super(t,[],p),this.memoryStats=d,this.allocatorFunctionPointer=l}else super(t,[],t.luaL_newstate());if(this.isClosed())throw new Error("Global state could not be created (probably due to lack of memory)")}close(){if(!this.isClosed()){super.close(),this.lua.lua_close(this.address),this.allocatorFunctionPointer&&this.lua.module.removeFunction(this.allocatorFunctionPointer);for(let t of this.typeExtensions)t.extension.close()}}registerTypeExtension(t,s){this.typeExtensions.push({extension:s,priority:t}),this.typeExtensions.sort((d,l)=>l.priority-d.priority)}loadLibrary(t){switch(t){case h.LuaLibraries.Base:this.lua.luaopen_base(this.address);break;case h.LuaLibraries.Coroutine:this.lua.luaopen_coroutine(this.address);break;case h.LuaLibraries.Table:this.lua.luaopen_table(this.address);break;case h.LuaLibraries.IO:this.lua.luaopen_io(this.address);break;case h.LuaLibraries.OS:this.lua.luaopen_os(this.address);break;case h.LuaLibraries.String:this.lua.luaopen_string(this.address);break;case h.LuaLibraries.UTF8:this.lua.luaopen_string(this.address);break;case h.LuaLibraries.Math:this.lua.luaopen_math(this.address);break;case h.LuaLibraries.Debug:this.lua.luaopen_debug(this.address);break;case h.LuaLibraries.Package:this.lua.luaopen_package(this.address);break}this.lua.lua_setglobal(this.address,t)}get(t){let s=this.lua.lua_getglobal(this.address,t),d=this.getValue(-1,s);return this.pop(),d}set(t,s){this.pushValue(s),this.lua.lua_setglobal(this.address,t)}getTable(t,s){let d=this.getTop(),l=this.lua.lua_getglobal(this.address,t);try{if(l!==h.LuaType.Table)throw new TypeError(`Unexpected type in ${t}. Expected ${h.LuaType[h.LuaType.Table]}. Got ${h.LuaType[l]}.`);s(d+1)}finally{this.getTop()!==d+1&&console.warn(`getTable: expected stack size ${d} got ${this.getTop()}`),this.setTop(d)}}getMemoryUsed(){return this.getMemoryStatsRef().memoryUsed}getMemoryMax(){return this.getMemoryStatsRef().memoryMax}setMemoryMax(t){this.getMemoryStatsRef().memoryMax=t}getMemoryStatsRef(){if(!this.memoryStats)throw new Error("Memory allocations is not being traced, please build engine with { traceAllocations: true }");return this.memoryStats}}class re{constructor(t,s){this.thread=t,this.name=s}isType(t,s,d,l){return d===h.LuaType.Userdata&&l===this.name}getValue(t,s,d){let l=t.lua.luaL_testudata(t.address,s,this.name);if(!l)throw new Error(`data does not have the expected metatable: ${this.name}`);let p=t.lua.module.getValue(l,"*");return t.lua.getRef(p)}pushValue(t,s,d){let{target:l}=s,p=t.lua.ref(l),w=t.lua.lua_newuserdatauv(t.address,W,0);if(t.lua.module.setValue(w,p,"*"),h.LuaType.Nil===t.lua.luaL_getmetatable(t.address,this.name))throw t.pop(2),new Error(`metatable not found: ${this.name}`);return t.lua.lua_setmetatable(t.address,-2),!0}}class Lt extends re{constructor(t,s){if(super(t,"js_error"),this.gcPointer=t.lua.module.addFunction(d=>{let l=t.lua.luaL_checkudata(d,1,this.name),p=t.lua.module.getValue(l,"*");return t.lua.unref(p),h.LuaReturn.Ok},"ii"),t.lua.luaL_newmetatable(t.address,this.name)){let d=t.lua.lua_gettop(t.address);t.lua.lua_pushstring(t.address,"protected metatable"),t.lua.lua_setfield(t.address,d,"__metatable"),t.lua.lua_pushcclosure(t.address,this.gcPointer,0),t.lua.lua_setfield(t.address,d,"__gc"),t.pushValue((l,p)=>p==="message"?l.message:null),t.lua.lua_setfield(t.address,d,"__index"),t.pushValue(l=>l.message),t.lua.lua_setfield(t.address,d,"__tostring")}t.lua.lua_pop(t.address,1),s&&t.set("Error",{create:d=>{if(d&&typeof d!="string")throw new Error("message must be a string");return new Error(d)}})}pushValue(t,s){return s.target instanceof Error?super.pushValue(t,s):!1}close(){this.thread.lua.module.removeFunction(this.gcPointer)}}function St(m,t){return new Lt(m,t)}class Ue{constructor(t){this.count=t}}function Ze(m,t){return new Z(m,t)}class At extends re{constructor(t,s){super(t,"js_function"),this.functionRegistry=typeof FinalizationRegistry!="undefined"?new FinalizationRegistry(d=>{this.thread.isClosed()||this.thread.lua.luaL_unref(this.thread.address,$,d)}):void 0,this.options=s,this.callbackContext=t.newThread(),this.callbackContextIndex=this.thread.lua.luaL_ref(t.address,$),this.functionRegistry||console.warn("FunctionTypeExtension: FinalizationRegistry not found. Memory leaks likely."),this.gcPointer=t.lua.module.addFunction(d=>{t.lua.luaL_checkudata(d,1,this.name);let l=t.lua.luaL_checkudata(d,1,this.name),p=t.lua.module.getValue(l,"*");return t.lua.unref(p),h.LuaReturn.Ok},"ii"),t.lua.luaL_newmetatable(t.address,this.name)&&(t.lua.lua_pushstring(t.address,"__gc"),t.lua.lua_pushcclosure(t.address,this.gcPointer,0),t.lua.lua_settable(t.address,-3),t.lua.lua_pushstring(t.address,"__metatable"),t.lua.lua_pushstring(t.address,"protected metatable"),t.lua.lua_settable(t.address,-3)),t.lua.lua_pop(t.address,1),this.functionWrapper=t.lua.module.addFunction(d=>{let l=t.stateToThread(d),p=t.lua.luaL_checkudata(d,t.lua.lua_upvalueindex(1),this.name),w=t.lua.module.getValue(p,"*"),{target:S,options:x}=t.lua.getRef(w),I=l.getTop(),F=[];if(x.receiveThread&&F.push(l),x.receiveArgsQuantity)F.push(I);else for(let D=1;D<=I;D++){let B=l.getValue(D);(D!==1||!(x!=null&&x.self)||B!==x.self)&&F.push(B)}try{let D=S.apply(x==null?void 0:x.self,F);if(D===void 0)return 0;if(D instanceof Ue)return D.count;if(D instanceof he){for(let B of D)l.pushValue(B);return D.length}else return l.pushValue(D),1}catch(D){if(D===1/0)throw D;return l.pushValue(D),l.lua.lua_error(l.address)}},"ii")}close(){this.thread.lua.module.removeFunction(this.gcPointer),this.thread.lua.module.removeFunction(this.functionWrapper),this.callbackContext.close(),this.callbackContext.lua.luaL_unref(this.callbackContext.address,$,this.callbackContextIndex)}isType(t,s,d){return d===h.LuaType.Function}pushValue(t,s){if(typeof s.target!="function")return!1;let d=t.lua.ref(s),l=t.lua.lua_newuserdatauv(t.address,W,0);if(t.lua.module.setValue(l,d,"*"),h.LuaType.Nil===t.lua.luaL_getmetatable(t.address,this.name))throw t.pop(1),t.lua.unref(d),new Error(`metatable not found: ${this.name}`);return t.lua.lua_setmetatable(t.address,-2),t.lua.lua_pushcclosure(t.address,this.functionWrapper,1),!0}getValue(t,s){var d;t.lua.lua_pushvalue(t.address,s);let l=t.lua.luaL_ref(t.address,$),p=(...w)=>{var S;if(this.callbackContext.isClosed()){console.warn("Tried to call a function after closing lua state");return}let x=this.callbackContext.newThread();try{let I=x.lua.lua_rawgeti(x.address,$,BigInt(l));if(I!==h.LuaType.Function){let D=x.lua.luaL_getmetafield(x.address,-1,"__call");if(x.pop(),D!==h.LuaType.Function)throw new Error(`A value of type '${I}' was pushed but it is not callable`)}for(let D of w)x.pushValue(D);!((S=this.options)===null||S===void 0)&&S.functionTimeout&&x.setTimeout(Date.now()+this.options.functionTimeout);let F=x.lua.lua_pcallk(x.address,w.length,1,0,0,null);if(F===h.LuaReturn.Yield)throw new Error("cannot yield in callbacks from javascript");return x.assertOk(F),x.getTop()>0?x.getValue(-1):void 0}finally{x.close(),this.callbackContext.pop()}};return(d=this.functionRegistry)===null||d===void 0||d.register(p,l),p}}function Ot(m,t){return new At(m,t)}class Ct extends re{constructor(t){if(super(t,"js_null"),this.gcPointer=t.lua.module.addFunction(s=>{let d=t.lua.luaL_checkudata(s,1,this.name),l=t.lua.module.getValue(d,"*");return t.lua.unref(l),h.LuaReturn.Ok},"ii"),t.lua.luaL_newmetatable(t.address,this.name)){let s=t.lua.lua_gettop(t.address);t.lua.lua_pushstring(t.address,"protected metatable"),t.lua.lua_setfield(t.address,s,"__metatable"),t.lua.lua_pushcclosure(t.address,this.gcPointer,0),t.lua.lua_setfield(t.address,s,"__gc"),t.pushValue(()=>null),t.lua.lua_setfield(t.address,s,"__index"),t.pushValue(()=>"null"),t.lua.lua_setfield(t.address,s,"__tostring"),t.pushValue((d,l)=>d===l),t.lua.lua_setfield(t.address,s,"__eq")}t.lua.lua_pop(t.address,1),super.pushValue(t,new Z({},{})),t.lua.lua_setglobal(t.address,"null")}getValue(t,s){if(!t.lua.luaL_testudata(t.address,s,this.name))throw new Error(`data does not have the expected metatable: ${this.name}`);return null}pushValue(t,s){return(s==null?void 0:s.target)!==null?!1:(t.lua.lua_getglobal(t.address,"null"),!0)}close(){this.thread.lua.module.removeFunction(this.gcPointer)}}function Ft(m){return new Ct(m)}class It extends re{constructor(t,s){if(super(t,"js_promise"),this.gcPointer=t.lua.module.addFunction(d=>{let l=t.lua.luaL_checkudata(d,1,this.name),p=t.lua.module.getValue(l,"*");return t.lua.unref(p),h.LuaReturn.Ok},"ii"),t.lua.luaL_newmetatable(t.address,this.name)){let d=t.lua.lua_gettop(t.address);t.lua.lua_pushstring(t.address,"protected metatable"),t.lua.lua_setfield(t.address,d,"__metatable"),t.lua.lua_pushcclosure(t.address,this.gcPointer,0),t.lua.lua_setfield(t.address,d,"__gc");let l=p=>{if(Promise.resolve(p)!==p&&typeof p.then!="function")throw new Error("promise method called without self instance");return!0};t.pushValue({next:(p,...w)=>l(p)&&p.then(...w),catch:(p,...w)=>l(p)&&p.catch(...w),finally:(p,...w)=>l(p)&&p.finally(...w),await:Ze((p,w)=>{if(l(w),p.address===t.address)throw new Error("cannot await in the main thread");let S,x=w.then(F=>{S={status:"fulfilled",value:F}}).catch(F=>{S={status:"rejected",value:F}}),I=this.thread.lua.module.addFunction(F=>{if(!S)return t.lua.lua_yieldk(p.address,0,0,I);this.thread.lua.module.removeFunction(I);let D=t.stateToThread(F);if(S.status==="rejected")return D.pushValue(S.value||new Error("promise rejected with no error")),this.thread.lua.lua_error(F);if(S.value instanceof Ue)return S.value.count;if(S.value instanceof he){for(let B of S.value)D.pushValue(B);return S.value.length}else return D.pushValue(S.value),1},"iiii");return p.pushValue(x),new Ue(t.lua.lua_yieldk(p.address,1,0,I))},{receiveThread:!0})}),t.lua.lua_setfield(t.address,d,"__index"),t.pushValue((p,w)=>p===w),t.lua.lua_setfield(t.address,d,"__eq")}t.lua.lua_pop(t.address,1),s&&t.set("Promise",{create:d=>new Promise(d),all:d=>{if(!Array.isArray(d))throw new Error("argument must be an array of promises");return Promise.all(d.map(l=>Promise.resolve(l)))},resolve:d=>Promise.resolve(d)})}close(){this.thread.lua.module.removeFunction(this.gcPointer)}pushValue(t,s){return Promise.resolve(s.target)!==s.target&&typeof s.target.then!="function"?!1:super.pushValue(t,s)}}function Rt(m,t){return new It(m,t)}function Cn(m,t){return new Z(m,t||{})}class Dt extends re{constructor(t){if(super(t,"js_proxy"),this.gcPointer=t.lua.module.addFunction(s=>{let d=t.lua.luaL_checkudata(s,1,this.name),l=t.lua.module.getValue(d,"*");return t.lua.unref(l),h.LuaReturn.Ok},"ii"),t.lua.luaL_newmetatable(t.address,this.name)){let s=t.lua.lua_gettop(t.address);t.lua.lua_pushstring(t.address,"protected metatable"),t.lua.lua_setfield(t.address,s,"__metatable"),t.lua.lua_pushcclosure(t.address,this.gcPointer,0),t.lua.lua_setfield(t.address,s,"__gc"),t.pushValue((d,l)=>{switch(typeof l){case"number":l=l-1;case"string":break;default:throw new Error("Only strings or numbers can index js objects")}let p=d[l];return typeof p=="function"?Ze(p,{self:d}):p}),t.lua.lua_setfield(t.address,s,"__index"),t.pushValue((d,l,p)=>{switch(typeof l){case"number":l=l-1;case"string":break;default:throw new Error("Only strings or numbers can index js objects")}d[l]=p}),t.lua.lua_setfield(t.address,s,"__newindex"),t.pushValue(d=>{var l,p;return(p=(l=d.toString)===null||l===void 0?void 0:l.call(d))!==null&&p!==void 0?p:typeof d}),t.lua.lua_setfield(t.address,s,"__tostring"),t.pushValue(d=>d.length||0),t.lua.lua_setfield(t.address,s,"__len"),t.pushValue(d=>{let l=Object.getOwnPropertyNames(d),p=0;return he.of(()=>{let w=he.of(l[p],d[l[p]]);return p++,w},d,null)}),t.lua.lua_setfield(t.address,s,"__pairs"),t.pushValue((d,l)=>d===l),t.lua.lua_setfield(t.address,s,"__eq"),t.pushValue((d,...l)=>(l[0]===d&&l.shift(),d(...l))),t.lua.lua_setfield(t.address,s,"__call")}t.lua.lua_pop(t.address,1)}isType(t,s,d,l){return d===h.LuaType.Userdata&&l===this.name}getValue(t,s){let d=t.lua.lua_touserdata(t.address,s),l=t.lua.module.getValue(d,"*");return t.lua.getRef(l)}pushValue(t,s){var d;let{target:l,options:p}=s;if(p.proxy===void 0){if(l==null||typeof l!="object"&&!(typeof l=="function"&&((d=l.prototype)===null||d===void 0?void 0:d.constructor)===l&&l.toString().startsWith("class "))||Promise.resolve(l)===l||typeof l.then=="function")return!1}else if(p.proxy===!1)return!1;return p.metatable&&!(p.metatable instanceof Z)?(s.options.metatable=Cn(p.metatable,{proxy:!1}),!1):super.pushValue(t,s)}close(){this.thread.lua.module.removeFunction(this.gcPointer)}}function Pt(m){return new Dt(m)}class Mt extends re{constructor(t){super(t,"js_table")}close(){}isType(t,s,d){return d===h.LuaType.Table}getValue(t,s,d){let l=d||new Map,p=t.lua.lua_topointer(t.address,s),w=l.get(p);if(!w){let S=this.readTableKeys(t,s);w=S.length>0&&S.every((I,F)=>I===String(F+1))?[]:{},l.set(p,w),this.readTableValues(t,s,l,w)}return w}pushValue(t,{target:s},d){if(typeof s!="object"||s===null)return!1;let l=d||new Map,p=l.get(s);if(p!==void 0)return t.lua.lua_rawgeti(t.address,$,BigInt(p)),!0;try{let w=t.getTop()+1,S=(x,I)=>{t.lua.lua_createtable(t.address,x,I);let F=t.lua.luaL_ref(t.address,$);l.set(s,F),t.lua.lua_rawgeti(t.address,$,BigInt(F))};if(Array.isArray(s)){S(s.length,0);for(let x=0;x<s.length;x++)t.pushValue(x+1,l),t.pushValue(s[x],l),t.lua.lua_settable(t.address,w)}else{S(0,Object.getOwnPropertyNames(s).length);for(let x in s)t.pushValue(x,l),t.pushValue(s[x],l),t.lua.lua_settable(t.address,w)}}finally{if(d===void 0)for(let w of l.values())t.lua.luaL_unref(t.address,$,w)}return!0}readTableKeys(t,s){let d=[];for(t.lua.lua_pushnil(t.address);t.lua.lua_next(t.address,s);){let l=t.indexToString(-2);d.push(l),t.pop()}return d}readTableValues(t,s,d,l){let p=Array.isArray(l);for(t.lua.lua_pushnil(t.address);t.lua.lua_next(t.address,s);){let w=t.indexToString(-2),S=t.getValue(-1,void 0,d);p?l.push(S):l[w]=S,t.pop()}}}function Nt(m){return new Mt(m)}function Bt(m){return new Z(m,{reference:!0})}class Ut extends re{constructor(t){if(super(t,"js_userdata"),this.gcPointer=t.lua.module.addFunction(s=>{let d=t.lua.luaL_checkudata(s,1,this.name),l=t.lua.module.getValue(d,"*");return t.lua.unref(l),h.LuaReturn.Ok},"ii"),t.lua.luaL_newmetatable(t.address,this.name)){let s=t.lua.lua_gettop(t.address);t.lua.lua_pushstring(t.address,"protected metatable"),t.lua.lua_setfield(t.address,s,"__metatable"),t.lua.lua_pushcclosure(t.address,this.gcPointer,0),t.lua.lua_setfield(t.address,s,"__gc")}t.lua.lua_pop(t.address,1)}isType(t,s,d,l){return d===h.LuaType.Userdata&&l===this.name}getValue(t,s){let d=t.lua.lua_touserdata(t.address,s),l=t.lua.module.getValue(d,"*");return t.lua.getRef(l)}pushValue(t,s){return s.options.reference?super.pushValue(t,s):!1}close(){this.thread.lua.module.removeFunction(this.gcPointer)}}function Yt(m){return new Ut(m)}class Fn{constructor(t,{openStandardLibs:s=!0,injectObjects:d=!1,enableProxy:l=!0,traceAllocations:p=!1,functionTimeout:w=void 0}={}){this.cmodule=t,this.global=new On(this.cmodule,p),this.global.registerTypeExtension(0,Nt(this.global)),this.global.registerTypeExtension(0,Ot(this.global,{functionTimeout:w})),this.global.registerTypeExtension(1,Rt(this.global,d)),d&&this.global.registerTypeExtension(5,Ft(this.global)),l?this.global.registerTypeExtension(3,Pt(this.global)):this.global.registerTypeExtension(1,St(this.global,d)),this.global.registerTypeExtension(4,Yt(this.global)),s&&this.cmodule.luaL_openlibs(this.global.address)}doString(t){return this.callByteCode(s=>s.loadString(t))}doFile(t){return this.callByteCode(s=>s.loadFile(t))}doStringSync(t){return this.global.loadString(t),this.global.runSync()[0]}doFileSync(t){return this.global.loadFile(t),this.global.runSync()[0]}async callByteCode(t){let s=this.global.newThread(),d=this.global.getTop();try{t(s);let l=await s.run(0);return l.length>0?(this.cmodule.lua_xmove(s.address,this.global.address,l.length),this.global.getValue(this.global.getTop()-l.length+1)):void 0}finally{this.global.remove(d)}}}var zt=(()=>{var m=typeof document=="undefined"&&typeof location=="undefined"?Be("url").pathToFileURL(__filename).href:typeof document=="undefined"?location.href:P&&P.src||new URL("index.js",document.baseURI).href;return async function(t={}){var s=t,d,l;s.ready=new Promise((e,n)=>{d=e,l=n}),"_malloc _free _realloc _luaL_checkversion_ _luaL_getmetafield _luaL_callmeta _luaL_tolstring _luaL_argerror _luaL_typeerror _luaL_checklstring _luaL_optlstring _luaL_checknumber _luaL_optnumber _luaL_checkinteger _luaL_optinteger _luaL_checkstack _luaL_checktype _luaL_checkany _luaL_newmetatable _luaL_setmetatable _luaL_testudata _luaL_checkudata _luaL_where _luaL_fileresult _luaL_execresult _luaL_ref _luaL_unref _luaL_loadfilex _luaL_loadbufferx _luaL_loadstring _luaL_newstate _luaL_len _luaL_addgsub _luaL_gsub _luaL_setfuncs _luaL_getsubtable _luaL_traceback _luaL_requiref _luaL_buffinit _luaL_prepbuffsize _luaL_addlstring _luaL_addstring _luaL_addvalue _luaL_pushresult _luaL_pushresultsize _luaL_buffinitsize _lua_newstate _lua_close _lua_newthread _lua_resetthread _lua_atpanic _lua_version _lua_absindex _lua_gettop _lua_settop _lua_pushvalue _lua_rotate _lua_copy _lua_checkstack _lua_xmove _lua_isnumber _lua_isstring _lua_iscfunction _lua_isinteger _lua_isuserdata _lua_type _lua_typename _lua_tonumberx _lua_tointegerx _lua_toboolean _lua_tolstring _lua_rawlen _lua_tocfunction _lua_touserdata _lua_tothread _lua_topointer _lua_arith _lua_rawequal _lua_compare _lua_pushnil _lua_pushnumber _lua_pushinteger _lua_pushlstring _lua_pushstring _lua_pushcclosure _lua_pushboolean _lua_pushlightuserdata _lua_pushthread _lua_getglobal _lua_gettable _lua_getfield _lua_geti _lua_rawget _lua_rawgeti _lua_rawgetp _lua_createtable _lua_newuserdatauv _lua_getmetatable _lua_getiuservalue _lua_setglobal _lua_settable _lua_setfield _lua_seti _lua_rawset _lua_rawseti _lua_rawsetp _lua_setmetatable _lua_setiuservalue _lua_callk _lua_pcallk _lua_load _lua_dump _lua_yieldk _lua_resume _lua_status _lua_isyieldable _lua_setwarnf _lua_warning _lua_error _lua_next _lua_concat _lua_len _lua_stringtonumber _lua_getallocf _lua_setallocf _lua_toclose _lua_closeslot _lua_getstack _lua_getinfo _lua_getlocal _lua_setlocal _lua_getupvalue _lua_setupvalue _lua_upvalueid _lua_upvaluejoin _lua_sethook _lua_gethook _lua_gethookmask _lua_gethookcount _lua_setcstacklimit _luaopen_base _luaopen_coroutine _luaopen_table _luaopen_io _luaopen_os _luaopen_string _luaopen_utf8 _luaopen_math _luaopen_debug _luaopen_package _luaL_openlibs _memory ___indirect_function_table _fflush onRuntimeInitialized".split(" ").forEach(e=>{Object.getOwnPropertyDescriptor(s.ready,e)||Object.defineProperty(s.ready,e,{get:()=>U("You are getting "+e+" on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js"),set:()=>U("You are setting "+e+" on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js")})});var p=Object.assign({},s),w="./this.program",S=(e,n)=>{throw n},x=typeof window=="object",I=typeof importScripts=="function",F=typeof process=="object"&&typeof process.versions=="object"&&typeof process.versions.node=="string",D=!x&&!F&&!I;if(s.ENVIRONMENT)throw Error("Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)");var B="",be,ye,we;if(F){if(typeof process=="undefined"||!process.release||process.release.name!=="node")throw Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");var In=process.versions.node,Ce=In.split(".").slice(0,3);if(Ce=1e4*Ce[0]+100*Ce[1]+1*Ce[2].split("-")[0],16e4>Ce)throw Error("This emscripten-generated code requires node v16.0.0 (detected v"+In+")");let{createRequire:e}=await import("module");var ve=e(typeof document=="undefined"&&typeof location=="undefined"?Be("url").pathToFileURL(__filename).href:typeof document=="undefined"?location.href:P&&P.src||new URL("index.js",document.baseURI).href),en=ve("fs"),nn=ve("path");I?B=nn.dirname(B)+"/":B=ve("url").fileURLToPath(new URL("./",typeof document=="undefined"&&typeof location=="undefined"?Be("url").pathToFileURL(__filename).href:typeof document=="undefined"?location.href:P&&P.src||new URL("index.js",document.baseURI).href)),be=(n,a)=>(n=Pe(n)?new URL(n):nn.normalize(n),en.readFileSync(n,a?void 0:"utf8")),we=n=>(n=be(n,!0),n.buffer||(n=new Uint8Array(n)),g(n.buffer),n),ye=(n,a,r,o=!0)=>{n=Pe(n)?new URL(n):nn.normalize(n),en.readFile(n,o?void 0:"utf8",(u,f)=>{u?r(u):a(o?f.buffer:f)})},!s.thisProgram&&1<process.argv.length&&(w=process.argv[1].replace(/\\/g,"/")),process.argv.slice(2),S=(n,a)=>{throw process.exitCode=n,a},s.inspect=()=>"[Emscripten Module object]"}else if(D){if(typeof process=="object"&&typeof ve=="function"||typeof window=="object"||typeof importScripts=="function")throw Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");typeof read!="undefined"&&(be=read),we=e=>typeof readbuffer=="function"?new Uint8Array(readbuffer(e)):(e=read(e,"binary"),g(typeof e=="object"),e),ye=(e,n)=>{setTimeout(()=>n(we(e)))},typeof clearTimeout=="undefined"&&(globalThis.clearTimeout=()=>{}),typeof setTimeout=="undefined"&&(globalThis.setTimeout=e=>typeof e=="function"?e():U()),typeof quit=="function"&&(S=(e,n)=>{throw setTimeout(()=>{if(!(n instanceof jn)){let a=n;n&&typeof n=="object"&&n.stack&&(a=[n,n.stack]),Y(`exiting due to exception: ${a}`)}quit(e)}),n}),typeof print!="undefined"&&(typeof console=="undefined"&&(console={}),console.log=print,console.warn=console.error=typeof printErr!="undefined"?printErr:print)}else if(x||I){if(I?B=self.location.href:typeof document!="undefined"&&document.currentScript&&(B=document.currentScript.src),m&&(B=m),B.indexOf("blob:")!==0?B=B.substr(0,B.replace(/[?#].*/,"").lastIndexOf("/")+1):B="",typeof window!="object"&&typeof importScripts!="function")throw Error("not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)");be=e=>{var n=new XMLHttpRequest;return n.open("GET",e,!1),n.send(null),n.responseText},I&&(we=e=>{var n=new XMLHttpRequest;return n.open("GET",e,!1),n.responseType="arraybuffer",n.send(null),new Uint8Array(n.response)}),ye=(e,n,a)=>{var r=new XMLHttpRequest;r.open("GET",e,!0),r.responseType="arraybuffer",r.onload=()=>{r.status==200||r.status==0&&r.response?n(r.response):a()},r.onerror=a,r.send(null)}}else throw Error("environment detection error");var ke=console.log.bind(console),Y=console.error.bind(console);Object.assign(s,p),p=null,T("ENVIRONMENT"),T("GL_MAX_TEXTURE_IMAGE_UNITS"),T("SDL_canPlayWithWebAudio"),T("SDL_numSimultaneouslyQueuedBuffers"),T("INITIAL_MEMORY"),T("wasmMemory"),T("arguments"),T("buffer"),T("canvas"),T("doNotCaptureKeyboard"),T("dynamicLibraries"),T("elementPointerLock"),T("extraStackTrace"),T("forcedAspectRatio"),T("instantiateWasm"),T("keyboardListeningElement"),T("freePreloadedMediaOnUse"),T("loadSplitModule"),T("logReadFiles"),T("mainScriptUrlOrBlob"),T("mem"),T("monitorRunDependencies"),T("noExitRuntime"),T("noInitialRun"),T("onAbort"),T("onCustomMessage"),T("onExit"),T("onFree"),T("onFullScreen"),T("onMalloc"),T("onRealloc"),T("onRuntimeInitialized"),T("postMainLoop"),T("postRun"),T("preInit"),T("preMainLoop"),T("preinitializedWebGLContext"),T("memoryInitializerRequest"),T("preloadPlugins"),T("print"),T("printErr"),T("quit"),T("setStatus"),T("statusMessage"),T("stderr"),T("stdin"),T("stdout"),T("thisProgram"),T("wasm"),T("wasmBinary"),T("websocket"),T("fetchSettings"),ee("arguments","arguments_"),ee("thisProgram","thisProgram"),ee("quit","quit_"),g(typeof s.memoryInitializerPrefixURL=="undefined","Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead"),g(typeof s.pthreadMainPrefixURL=="undefined","Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead"),g(typeof s.cdInitializerPrefixURL=="undefined","Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead"),g(typeof s.filePackagePrefixURL=="undefined","Module.filePackagePrefixURL option was removed, use Module.locateFile instead"),g(typeof s.read=="undefined","Module.read option was removed (modify read_ in JS)"),g(typeof s.readAsync=="undefined","Module.readAsync option was removed (modify readAsync in JS)"),g(typeof s.readBinary=="undefined","Module.readBinary option was removed (modify readBinary in JS)"),g(typeof s.setWindowTitle=="undefined","Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)"),g(typeof s.TOTAL_MEMORY=="undefined","Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY"),ee("asm","wasmExports"),ee("read","read_"),ee("readAsync","readAsync"),ee("readBinary","readBinary"),ee("setWindowTitle","setWindowTitle"),g(!D,"shell environment detected but not enabled at build time.  Add 'shell' to `-sENVIRONMENT` to enable."),ee("wasmBinary","wasmBinary"),typeof WebAssembly!="object"&&U("no native wasm support detected");var Fe,Ie=!1;function g(e,n){e||U("Assertion failed"+(n?": "+n:""))}var q,ze,xe,v,N,tn,qe,an;function Rn(){var e=Fe.buffer;s.HEAP8=q=new Int8Array(e),s.HEAP16=xe=new Int16Array(e),s.HEAPU8=ze=new Uint8Array(e),s.HEAPU16=new Uint16Array(e),s.HEAP32=v=new Int32Array(e),s.HEAPU32=N=new Uint32Array(e),s.HEAPF32=tn=new Float32Array(e),s.HEAPF64=an=new Float64Array(e),s.HEAP64=qe=new BigInt64Array(e),s.HEAPU64=new BigUint64Array(e)}g(!s.STACK_SIZE,"STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time"),g(typeof Int32Array!="undefined"&&typeof Float64Array!="undefined"&&Int32Array.prototype.subarray!=null&&Int32Array.prototype.set!=null,"JS engine does not provide full typed array support"),g(!s.wasmMemory,"Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally"),g(!s.INITIAL_MEMORY,"Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically");function sn(){if(!Ie){var e=Ln();e==0&&(e+=4);var n=N[e>>2],a=N[e+4>>2];n==34821223&&a==2310721022||U(`Stack overflow! Stack cookie has been overwritten at ${Me(e)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${Me(a)} ${Me(n)}`),N[0]!=1668509029&&U("Runtime error: The application has corrupted its heap memory area (address zero)!")}}var Dn=new Int16Array(1),Pn=new Int8Array(Dn.buffer);if(Dn[0]=25459,Pn[0]!==115||Pn[1]!==99)throw"Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)";var rn=[],on=[],Mn=[],ln=!1;g(Math.imul,"This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"),g(Math.fround,"This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"),g(Math.clz32,"This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill"),g(Math.trunc,"This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill");var Re=0,oe=null,De=null,Te={};function Nn(e){for(var n=e;;){if(!Te[e])return e;e=n+Math.random()}}function dn(e){Re++,e?(g(!Te[e]),Te[e]=1,oe===null&&typeof setInterval!="undefined"&&(oe=setInterval(()=>{if(Ie)clearInterval(oe),oe=null;else{var n=!1,a;for(a in Te)n||(n=!0,Y("still waiting on run dependencies:")),Y(`dependency: ${a}`);n&&Y("(end of list)")}},1e4))):Y("warning: run dependency added without ID")}function Ve(e){Re--,e?(g(Te[e]),delete Te[e]):Y("warning: run dependency removed without ID"),Re==0&&(oe!==null&&(clearInterval(oe),oe=null),De&&(e=De,De=null,e()))}function U(e){throw e="Aborted("+e+")",Y(e),Ie=!0,e=new WebAssembly.RuntimeError(e),l(e),e}var Bn=e=>e.startsWith("data:application/octet-stream;base64,"),Pe=e=>e.startsWith("file://");function _(e){return function(){g(ln,`native function \`${e}\` called before runtime initialization`);var n=pe[e];return g(n,`exported native function \`${e}\` not found`),n.apply(null,arguments)}}var ie;if(s.locateFile){if(ie="glue.wasm",!Bn(ie)){var Un=ie;ie=s.locateFile?s.locateFile(Un,B):B+Un}}else ie=new URL("glue.wasm",typeof document=="undefined"&&typeof location=="undefined"?Be("url").pathToFileURL(__filename).href:typeof document=="undefined"?location.href:P&&P.src||new URL("index.js",document.baseURI).href).href;function Yn(e){if(we)return we(e);throw"both async and sync fetching of the wasm failed"}function Ht(e){if(x||I){if(typeof fetch=="function"&&!Pe(e))return fetch(e,{credentials:"same-origin"}).then(n=>{if(!n.ok)throw"failed to load wasm binary file at '"+e+"'";return n.arrayBuffer()}).catch(()=>Yn(e));if(ye)return new Promise((n,a)=>{ye(e,r=>n(new Uint8Array(r)),a)})}return Promise.resolve().then(()=>Yn(e))}function zn(e,n,a){return Ht(e).then(r=>WebAssembly.instantiate(r,n)).then(r=>r).then(a,r=>{Y(`failed to asynchronously prepare wasm: ${r}`),Pe(ie)&&Y(`warning: Loading from a file URI (${ie}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`),U(r)})}function jt(e,n){var a=ie;return typeof WebAssembly.instantiateStreaming!="function"||Bn(a)||Pe(a)||F||typeof fetch!="function"?zn(a,e,n):fetch(a,{credentials:"same-origin"}).then(r=>WebAssembly.instantiateStreaming(r,e).then(n,function(o){return Y(`wasm streaming compile failed: ${o}`),Y("falling back to ArrayBuffer instantiation"),zn(a,e,n)}))}function ee(e,n){Object.getOwnPropertyDescriptor(s,e)||Object.defineProperty(s,e,{configurable:!0,get(){U(`\`Module.${e}\` has been replaced by \`${n}\` (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)`)}})}function T(e){Object.getOwnPropertyDescriptor(s,e)&&U(`\`Module.${e}\` was supplied but \`${e}\` not included in INCOMING_MODULE_JS_API`)}function qn(e){return e==="FS_createPath"||e==="FS_createDataFile"||e==="FS_createPreloadedFile"||e==="FS_unlink"||e==="addRunDependency"||e==="FS_createLazyFile"||e==="FS_createDevice"||e==="removeRunDependency"}function Vn(e,n){typeof globalThis!="undefined"&&Object.defineProperty(globalThis,e,{configurable:!0,get(){Ee(`\`${e}\` is not longer defined by emscripten. ${n}`)}})}Vn("buffer","Please use HEAP8.buffer or wasmMemory.buffer"),Vn("asm","Please use wasmExports instead");function Hn(e){Object.getOwnPropertyDescriptor(s,e)||Object.defineProperty(s,e,{configurable:!0,get(){var n=`'${e}' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`;qn(e)&&(n+=". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you"),U(n)}})}function jn(e){this.name="ExitStatus",this.message=`Program terminated with exit(${e})`,this.status=e}var Me=e=>(g(typeof e=="number"),"0x"+(e>>>0).toString(16).padStart(8,"0")),Ee=e=>{un||(un={}),un[e]||(un[e]=1,F&&(e="warning: "+e),Y(e))},un,Gn=(e,n)=>{for(var a=0,r=e.length-1;0<=r;r--){var o=e[r];o==="."?e.splice(r,1):o===".."?(e.splice(r,1),a++):a&&(e.splice(r,1),a--)}if(n)for(;a;a--)e.unshift("..");return e},ne=e=>{var n=e.charAt(0)==="/",a=e.substr(-1)==="/";return(e=Gn(e.split("/").filter(r=>!!r),!n).join("/"))||n||(e="."),e&&a&&(e+="/"),(n?"/":"")+e},_n=e=>{var n=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/.exec(e).slice(1);return e=n[0],n=n[1],!e&&!n?".":(n&&(n=n.substr(0,n.length-1)),e+n)},le=e=>{if(e==="/")return"/";e=ne(e),e=e.replace(/\/$/,"");var n=e.lastIndexOf("/");return n===-1?e:e.substr(n+1)},Gt=(e,n)=>ne(e+"/"+n),Wt=()=>{if(typeof crypto=="object"&&typeof crypto.getRandomValues=="function")return a=>crypto.getRandomValues(a);if(F)try{var e=ve("crypto");if(e.randomFillSync)return a=>e.randomFillSync(a);var n=e.randomBytes;return a=>(a.set(n(a.byteLength)),a)}catch{}U("no cryptographic support found for randomDevice. consider polyfilling it if you want to use something insecure like Math.random(), e.g. put this in a --pre-js: var crypto = { getRandomValues: (array) => { for (var i = 0; i < array.length; i++) array[i] = (Math.random()*256)|0 } };")},Wn=e=>(Wn=Wt())(e);function de(){for(var e="",n=!1,a=arguments.length-1;-1<=a&&!n;a--){if(n=0<=a?arguments[a]:i.cwd(),typeof n!="string")throw new TypeError("Arguments to path.resolve must be strings");if(!n)return"";e=n+"/"+e,n=n.charAt(0)==="/"}return e=Gn(e.split("/").filter(r=>!!r),!n).join("/"),(n?"/":"")+e||"."}var $n=(e,n)=>{function a(f){for(var b=0;b<f.length&&f[b]==="";b++);for(var O=f.length-1;0<=O&&f[O]==="";O--);return b>O?[]:f.slice(b,O-b+1)}e=de(e).substr(1),n=de(n).substr(1),e=a(e.split("/")),n=a(n.split("/"));for(var r=Math.min(e.length,n.length),o=r,u=0;u<r;u++)if(e[u]!==n[u]){o=u;break}for(r=[],u=o;u<e.length;u++)r.push("..");return r=r.concat(n.slice(o)),r.join("/")},Jn=typeof TextDecoder!="undefined"?new TextDecoder("utf8"):void 0,Le=(e,n)=>{for(var a=n+NaN,r=n;e[r]&&!(r>=a);)++r;if(16<r-n&&e.buffer&&Jn)return Jn.decode(e.subarray(n,r));for(a="";n<r;){var o=e[n++];if(o&128){var u=e[n++]&63;if((o&224)==192)a+=String.fromCharCode((o&31)<<6|u);else{var f=e[n++]&63;(o&240)==224?o=(o&15)<<12|u<<6|f:((o&248)!=240&&Ee("Invalid UTF-8 leading byte "+Me(o)+" encountered when deserializing a UTF-8 string in wasm memory to a JS string!"),o=(o&7)<<18|u<<12|f<<6|e[n++]&63),65536>o?a+=String.fromCharCode(o):(o-=65536,a+=String.fromCharCode(55296|o>>10,56320|o&1023))}}else a+=String.fromCharCode(o)}return a},cn=[],Se=e=>{for(var n=0,a=0;a<e.length;++a){var r=e.charCodeAt(a);127>=r?n++:2047>=r?n+=2:55296<=r&&57343>=r?(n+=4,++a):n+=3}return n},fn=(e,n,a,r)=>{if(g(typeof e=="string",`stringToUTF8Array expects a string (got ${typeof e})`),!(0<r))return 0;var o=a;r=a+r-1;for(var u=0;u<e.length;++u){var f=e.charCodeAt(u);if(55296<=f&&57343>=f){var b=e.charCodeAt(++u);f=65536+((f&1023)<<10)|b&1023}if(127>=f){if(a>=r)break;n[a++]=f}else{if(2047>=f){if(a+1>=r)break;n[a++]=192|f>>6}else{if(65535>=f){if(a+2>=r)break;n[a++]=224|f>>12}else{if(a+3>=r)break;1114111<f&&Ee("Invalid Unicode code point "+Me(f)+" encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF)."),n[a++]=240|f>>18,n[a++]=128|f>>12&63}n[a++]=128|f>>6&63}n[a++]=128|f&63}}return n[a]=0,a-o};function He(e,n){var a=Array(Se(e)+1);return e=fn(e,a,0,a.length),n&&(a.length=e),a}var pn=[];function Kn(e,n){pn[e]={input:[],output:[],K:n},hn(e,$t)}var $t={open(e){var n=pn[e.node.rdev];if(!n)throw new i.g(43);e.tty=n,e.seekable=!1},close(e){e.tty.K.fsync(e.tty)},fsync(e){e.tty.K.fsync(e.tty)},read(e,n,a,r){if(!e.tty||!e.tty.K.ra)throw new i.g(60);for(var o=0,u=0;u<r;u++){try{var f=e.tty.K.ra(e.tty)}catch{throw new i.g(29)}if(f===void 0&&o===0)throw new i.g(6);if(f==null)break;o++,n[a+u]=f}return o&&(e.node.timestamp=Date.now()),o},write(e,n,a,r){if(!e.tty||!e.tty.K.ia)throw new i.g(60);try{for(var o=0;o<r;o++)e.tty.K.ia(e.tty,n[a+o])}catch{throw new i.g(29)}return r&&(e.node.timestamp=Date.now()),o}},Jt={ra(){e:{if(!cn.length){var e=null;if(F){var n=Buffer.alloc(256),a=0,r=process.stdin.fd;try{a=en.readSync(r,n)}catch(o){if(o.toString().includes("EOF"))a=0;else throw o}0<a?e=n.slice(0,a).toString("utf-8"):e=null}else typeof window!="undefined"&&typeof window.prompt=="function"?(e=window.prompt("Input: "),e!==null&&(e+=`
`)):typeof readline=="function"&&(e=readline(),e!==null&&(e+=`
`));if(!e){e=null;break e}cn=He(e,!0)}e=cn.shift()}return e},ia(e,n){n===null||n===10?(ke(Le(e.output,0)),e.output=[]):n!=0&&e.output.push(n)},fsync(e){e.output&&0<e.output.length&&(ke(Le(e.output,0)),e.output=[])},Ia(){return{ab:25856,cb:5,$a:191,bb:35387,Za:[3,28,127,21,4,0,1,0,17,19,26,0,18,15,23,22,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0]}},Ja(){return 0},Ka(){return[24,80]}},Kt={ia(e,n){n===null||n===10?(Y(Le(e.output,0)),e.output=[]):n!=0&&e.output.push(n)},fsync(e){e.output&&0<e.output.length&&(Y(Le(e.output,0)),e.output=[])}},Xn=()=>{U("internal error: mmapAlloc called but `emscripten_builtin_memalign` native symbol not exported")};function Qn(e,n){var a=e.m?e.m.length:0;a>=n||(n=Math.max(n,a*(1048576>a?2:1.125)>>>0),a!=0&&(n=Math.max(n,256)),a=e.m,e.m=new Uint8Array(n),0<e.o&&e.m.set(a.subarray(0,e.o),0))}var C={G:null,s(){return C.createNode(null,"/",16895,0)},createNode(e,n,a,r){if((a&61440)===24576||i.isFIFO(a))throw new i.g(63);return C.G||(C.G={dir:{node:{C:C.h.C,v:C.h.v,lookup:C.h.lookup,J:C.h.J,rename:C.h.rename,unlink:C.h.unlink,rmdir:C.h.rmdir,readdir:C.h.readdir,symlink:C.h.symlink},stream:{D:C.l.D}},file:{node:{C:C.h.C,v:C.h.v},stream:{D:C.l.D,read:C.l.read,write:C.l.write,T:C.l.T,S:C.l.S,V:C.l.V}},link:{node:{C:C.h.C,v:C.h.v,readlink:C.h.readlink},stream:{}},na:{node:{C:C.h.C,v:C.h.v},stream:i.Da}}),a=i.createNode(e,n,a,r),H(a.mode)?(a.h=C.G.dir.node,a.l=C.G.dir.stream,a.m={}):i.isFile(a.mode)?(a.h=C.G.file.node,a.l=C.G.file.stream,a.o=0,a.m=null):(a.mode&61440)===40960?(a.h=C.G.link.node,a.l=C.G.link.stream):(a.mode&61440)===8192&&(a.h=C.G.na.node,a.l=C.G.na.stream),a.timestamp=Date.now(),e&&(e.m[n]=a,e.timestamp=a.timestamp),a},lb(e){return e.m?e.m.subarray?e.m.subarray(0,e.o):new Uint8Array(e.m):new Uint8Array(0)},h:{C(e){var n={};return n.dev=(e.mode&61440)===8192?e.id:1,n.ino=e.id,n.mode=e.mode,n.nlink=1,n.uid=0,n.gid=0,n.rdev=e.rdev,H(e.mode)?n.size=4096:i.isFile(e.mode)?n.size=e.o:(e.mode&61440)===40960?n.size=e.link.length:n.size=0,n.atime=new Date(e.timestamp),n.mtime=new Date(e.timestamp),n.ctime=new Date(e.timestamp),n.Ba=4096,n.blocks=Math.ceil(n.size/n.Ba),n},v(e,n){if(n.mode!==void 0&&(e.mode=n.mode),n.timestamp!==void 0&&(e.timestamp=n.timestamp),n.size!==void 0&&(n=n.size,e.o!=n))if(n==0)e.m=null,e.o=0;else{var a=e.m;e.m=new Uint8Array(n),a&&e.m.set(a.subarray(0,Math.min(n,e.o))),e.o=n}},lookup(){throw i.da[44]},J(e,n,a,r){return C.createNode(e,n,a,r)},rename(e,n,a){if(H(e.mode)){try{var r=te(n,a)}catch{}if(r)for(var o in r.m)throw new i.g(55)}delete e.parent.m[e.name],e.parent.timestamp=Date.now(),e.name=a,n.m[a]=e,n.timestamp=e.parent.timestamp,e.parent=n},unlink(e,n){delete e.m[n],e.timestamp=Date.now()},rmdir(e,n){var a=te(e,n),r;for(r in a.m)throw new i.g(55);delete e.m[n],e.timestamp=Date.now()},readdir(e){var n=[".",".."],a;for(a in e.m)e.m.hasOwnProperty(a)&&n.push(a);return n},symlink(e,n,a){return e=C.createNode(e,n,41471,0),e.link=a,e},readlink(e){if((e.mode&61440)!==40960)throw new i.g(28);return e.link}},l:{read(e,n,a,r,o){var u=e.node.m;if(o>=e.node.o)return 0;if(e=Math.min(e.node.o-o,r),g(0<=e),8<e&&u.subarray)n.set(u.subarray(o,o+e),a);else for(r=0;r<e;r++)n[a+r]=u[o+r];return e},write(e,n,a,r,o,u){if(g(!(n instanceof ArrayBuffer)),n.buffer===q.buffer&&(u=!1),!r)return 0;if(e=e.node,e.timestamp=Date.now(),n.subarray&&(!e.m||e.m.subarray)){if(u)return g(o===0,"canOwn must imply no weird position inside the file"),e.m=n.subarray(a,a+r),e.o=r;if(e.o===0&&o===0)return e.m=n.slice(a,a+r),e.o=r;if(o+r<=e.o)return e.m.set(n.subarray(a,a+r),o),r}if(Qn(e,o+r),e.m.subarray&&n.subarray)e.m.set(n.subarray(a,a+r),o);else for(u=0;u<r;u++)e.m[o+u]=n[a+u];return e.o=Math.max(e.o,o+r),r},D(e,n,a){if(a===1?n+=e.position:a===2&&i.isFile(e.node.mode)&&(n+=e.node.o),0>n)throw new i.g(28);return n},T(e,n,a){Qn(e.node,n+a),e.node.o=Math.max(e.node.o,n+a)},S(e,n,a,r,o){if(!i.isFile(e.node.mode))throw new i.g(43);if(e=e.node.m,o&2||e.buffer!==q.buffer){if((0<a||a+n<e.length)&&(e.subarray?e=e.subarray(a,a+n):e=Array.prototype.slice.call(e,a,a+n)),a=!0,n=Xn(),!n)throw new i.g(48);q.set(e,n)}else a=!1,n=e.byteOffset;return{Ra:n,Aa:a}},V(e,n,a,r){return C.l.write(e,n,0,r,a,!1),0}}},Xt=(e,n,a)=>{var r=Nn(`al ${e}`);ye(e,o=>{g(o,`Loading data file "${e}" failed (no arrayBuffer).`),n(new Uint8Array(o)),r&&Ve(r)},()=>{if(a)a();else throw`Loading data file "${e}" failed.`}),r&&dn(r)},Qt=[],Zt=(e,n,a,r)=>{typeof Browser!="undefined"&&Browser.R();var o=!1;return Qt.forEach(u=>{!o&&u.canHandle(n)&&(u.handle(e,n,a,r),o=!0)}),o},mn=(e,n)=>{var a=0;return e&&(a|=365),n&&(a|=146),a},ea={0:"Success",1:"Arg list too long",2:"Permission denied",3:"Address already in use",4:"Address not available",5:"Address family not supported by protocol family",6:"No more processes",7:"Socket already connected",8:"Bad file number",9:"Trying to read unreadable message",10:"Mount device busy",11:"Operation canceled",12:"No children",13:"Connection aborted",14:"Connection refused",15:"Connection reset by peer",16:"File locking deadlock error",17:"Destination address required",18:"Math arg out of domain of func",19:"Quota exceeded",20:"File exists",21:"Bad address",22:"File too large",23:"Host is unreachable",24:"Identifier removed",25:"Illegal byte sequence",26:"Connection already in progress",27:"Interrupted system call",28:"Invalid argument",29:"I/O error",30:"Socket is already connected",31:"Is a directory",32:"Too many symbolic links",33:"Too many open files",34:"Too many links",35:"Message too long",36:"Multihop attempted",37:"File or path name too long",38:"Network interface is not configured",39:"Connection reset by network",40:"Network is unreachable",41:"Too many open files in system",42:"No buffer space available",43:"No such device",44:"No such file or directory",45:"Exec format error",46:"No record locks available",47:"The link has been severed",48:"Not enough core",49:"No message of desired type",50:"Protocol not available",51:"No space left on device",52:"Function not implemented",53:"Socket is not connected",54:"Not a directory",55:"Directory not empty",56:"State not recoverable",57:"Socket operation on non-socket",59:"Not a typewriter",60:"No such device or address",61:"Value too large for defined data type",62:"Previous owner died",63:"Not super-user",64:"Broken pipe",65:"Protocol error",66:"Unknown protocol",67:"Protocol wrong type for socket",68:"Math result not representable",69:"Read only file system",70:"Illegal seek",71:"No such process",72:"Stale file handle",73:"Connection timed out",74:"Text file busy",75:"Cross-device link",100:"Device not a stream",101:"Bad font file fmt",102:"Invalid slot",103:"Invalid request code",104:"No anode",105:"Block device required",106:"Channel number out of range",107:"Level 3 halted",108:"Level 3 reset",109:"Link number out of range",110:"Protocol driver not attached",111:"No CSI structure available",112:"Level 2 halted",113:"Invalid exchange",114:"Invalid request descriptor",115:"Exchange full",116:"No data (for no delay io)",117:"Timer expired",118:"Out of streams resources",119:"Machine is not on the network",120:"Package not installed",121:"The object is remote",122:"Advertise error",123:"Srmount error",124:"Communication error on send",125:"Cross mount point (not really error)",126:"Given log. name not unique",127:"f.d. invalid for this operation",128:"Remote address changed",129:"Can   access a needed shared lib",130:"Accessing a corrupted shared lib",131:".lib section in a.out corrupted",132:"Attempting to link in too many libs",133:"Attempting to exec a shared library",135:"Streams pipe error",136:"Too many users",137:"Socket type not supported",138:"Not supported",139:"Protocol family not supported",140:"Can't send after socket shutdown",141:"Too many references",142:"Host is down",148:"No medium (in tape drive)",156:"Level 2 not synchronized"},Zn={EPERM:63,ENOENT:44,ESRCH:71,EINTR:27,EIO:29,ENXIO:60,E2BIG:1,ENOEXEC:45,EBADF:8,ECHILD:12,EAGAIN:6,EWOULDBLOCK:6,ENOMEM:48,EACCES:2,EFAULT:21,ENOTBLK:105,EBUSY:10,EEXIST:20,EXDEV:75,ENODEV:43,ENOTDIR:54,EISDIR:31,EINVAL:28,ENFILE:41,EMFILE:33,ENOTTY:59,ETXTBSY:74,EFBIG:22,ENOSPC:51,ESPIPE:70,EROFS:69,EMLINK:34,EPIPE:64,EDOM:18,ERANGE:68,ENOMSG:49,EIDRM:24,ECHRNG:106,EL2NSYNC:156,EL3HLT:107,EL3RST:108,ELNRNG:109,EUNATCH:110,ENOCSI:111,EL2HLT:112,EDEADLK:16,ENOLCK:46,EBADE:113,EBADR:114,EXFULL:115,ENOANO:104,EBADRQC:103,EBADSLT:102,EDEADLOCK:16,EBFONT:101,ENOSTR:100,ENODATA:116,ETIME:117,ENOSR:118,ENONET:119,ENOPKG:120,EREMOTE:121,ENOLINK:47,EADV:122,ESRMNT:123,ECOMM:124,EPROTO:65,EMULTIHOP:36,EDOTDOT:125,EBADMSG:9,ENOTUNIQ:126,EBADFD:127,EREMCHG:128,ELIBACC:129,ELIBBAD:130,ELIBSCN:131,ELIBMAX:132,ELIBEXEC:133,ENOSYS:52,ENOTEMPTY:55,ENAMETOOLONG:37,ELOOP:32,EOPNOTSUPP:138,EPFNOSUPPORT:139,ECONNRESET:15,ENOBUFS:42,EAFNOSUPPORT:5,EPROTOTYPE:67,ENOTSOCK:57,ENOPROTOOPT:50,ESHUTDOWN:140,ECONNREFUSED:14,EADDRINUSE:3,ECONNABORTED:13,ENETUNREACH:40,ENETDOWN:38,ETIMEDOUT:73,EHOSTDOWN:142,EHOSTUNREACH:23,EINPROGRESS:26,EALREADY:7,EDESTADDRREQ:17,EMSGSIZE:35,EPROTONOSUPPORT:66,ESOCKTNOSUPPORT:137,EADDRNOTAVAIL:4,ENETRESET:39,EISCONN:30,ENOTCONN:53,ETOOMANYREFS:141,EUSERS:136,EDQUOT:19,ESTALE:72,ENOTSUP:138,ENOMEDIUM:148,EILSEQ:25,EOVERFLOW:61,ECANCELED:11,ENOTRECOVERABLE:56,EOWNERDEAD:62,ESTRPIPE:135},na=e=>e.replace(/\b_Z[\w\d_]+/g,function(n){return Ee("warning: build with -sDEMANGLE_SUPPORT to link in libcxxabi demangling"),n===n?n:n+" ["+n+"]"});function hn(e,n){i.pa[e]={l:n}}function H(e){return(e&61440)===16384}function te(e,n){var a;if(a=(a=_e(e,"x"))?a:e.h.lookup?0:2)throw new i.g(a,e);for(a=i.F[gn(e.id,n)];a;a=a.N){var r=a.name;if(a.parent.id===e.id&&r===n)return a}return i.lookup(e,n)}function z(e,n={}){if(e=de(e),!e)return{path:"",node:null};if(n=Object.assign({ba:!0,ka:0},n),8<n.ka)throw new i.g(32);e=e.split("/").filter(f=>!!f);for(var a=i.root,r="/",o=0;o<e.length;o++){var u=o===e.length-1;if(u&&n.parent)break;if(a=te(a,e[o]),r=ne(r+"/"+e[o]),a.A&&(!u||u&&n.ba)&&(a=a.A.root),!u||n.B){for(u=0;(a.mode&61440)===40960;)if(a=i.readlink(r),r=de(_n(r),a),a=z(r,{ka:n.ka+1}).node,40<u++)throw new i.g(32)}}return{path:r,node:a}}function ue(e){for(var n;;){if(i.Z(e))return e=e.s.ua,n?e[e.length-1]!=="/"?`${e}/${n}`:e+n:e;n=n?`${e.name}/${n}`:e.name,e=e.parent}}function gn(e,n){for(var a=0,r=0;r<n.length;r++)a=(a<<5)-a+n.charCodeAt(r)|0;return(e+a>>>0)%i.F.length}function et(e){var n=gn(e.parent.id,e.name);e.N=i.F[n],i.F[n]=e}function je(e){var n=gn(e.parent.id,e.name);if(i.F[n]===e)i.F[n]=e.N;else for(n=i.F[n];n;){if(n.N===e){n.N=e.N;break}n=n.N}}function nt(e){var n=["r","w","rw"][e&3];return e&512&&(n+="w"),n}function _e(e,n){if(i.ta)return 0;if(!n.includes("r")||e.mode&292){if(n.includes("w")&&!(e.mode&146)||n.includes("x")&&!(e.mode&73))return 2}else return 2;return 0}function bn(e,n){try{return te(e,n),20}catch{}return _e(e,"wx")}function Ge(e,n,a){try{var r=te(e,n)}catch(o){return o.u}if(e=_e(e,"wx"))return e;if(a){if(!H(r.mode))return 54;if(i.Z(r)||ue(r)===i.cwd())return 10}else if(H(r.mode))return 31;return 0}function ta(){for(var e=0;e<=i.xa;e++)if(!i.streams[e])return e;throw new i.g(33)}function J(e){if(e=i.qa(e),!e)throw new i.g(8);return e}function yn(e,n=-1){return i.X||(i.X=function(){this.I={}},i.X.prototype={},Object.defineProperties(i.X.prototype,{object:{get(){return this.node},set(a){this.node=a}},flags:{get(){return this.I.flags},set(a){this.I.flags=a}},position:{get(){return this.I.position},set(a){this.I.position=a}}})),e=Object.assign(new i.X,e),n==-1&&(n=ta()),e.fd=n,i.streams[n]=e}function tt(e){var n=[];for(e=[e];e.length;){var a=e.pop();n.push(a),e.push.apply(e,a.U)}return n}function We(e,n,a){return typeof a=="undefined"&&(a=n,n=438),i.J(e,n|8192,a)}function at(){i.g||(i.g=function(e,n){this.name="ErrnoError",this.node=n,this.Sa=function(a){this.u=a;for(var r in Zn)if(Zn[r]===a){this.code=r;break}},this.Sa(e),this.message=ea[e],this.stack&&(Object.defineProperty(this,"stack",{value:Error().stack,writable:!0}),this.stack=na(this.stack))},i.g.prototype=Error(),i.g.prototype.constructor=i.g,[44].forEach(e=>{i.da[e]=new i.g(e),i.da[e].stack="<generic error, no stack>"}))}function st(e,n){try{var a=z(e,{B:!n});e=a.path}catch{}var r={Z:!1,exists:!1,error:0,name:null,path:null,object:null,Oa:!1,Qa:null,Pa:null};try{a=z(e,{parent:!0}),r.Oa=!0,r.Qa=a.path,r.Pa=a.node,r.name=le(e),a=z(e,{B:!n}),r.exists=!0,r.path=a.path,r.object=a.node,r.name=a.node.name,r.Z=a.path==="/"}catch(o){r.error=o.u}return r}function aa(e,n,a,r){return e=typeof e=="string"?e:ue(e),n=ne(e+"/"+n),i.create(n,mn(a,r))}function wn(e){if(!(e.La||e.Ma||e.link||e.m)){if(typeof XMLHttpRequest!="undefined")throw Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");if(be)try{e.m=He(be(e.url),!0),e.o=e.m.length}catch{throw new i.g(29)}else throw Error("Cannot load without read() or XMLHttpRequest.")}}var i={root:null,U:[],pa:{},streams:[],Na:1,F:null,oa:"/",Y:!1,ta:!0,g:null,da:{},Fa:null,W:0,createNode(e,n,a,r){return g(typeof e=="object"),e=new i.wa(e,n,a,r),et(e),e},Z(e){return e===e.parent},isFile(e){return(e&61440)===32768},isFIFO(e){return(e&61440)===4096},isSocket(e){return(e&49152)===49152},xa:4096,qa:e=>i.streams[e],Da:{open(e){e.l=i.Ga(e.node.rdev).l,e.l.open&&e.l.open(e)},D(){throw new i.g(70)}},ha:e=>e>>8,nb:e=>e&255,M:(e,n)=>e<<8|n,Ga:e=>i.pa[e],va(e,n){function a(f){return g(0<i.W),i.W--,n(f)}function r(f){if(f){if(!r.Ea)return r.Ea=!0,a(f)}else++u>=o.length&&a(null)}typeof e=="function"&&(n=e,e=!1),i.W++,1<i.W&&Y(`warning: ${i.W} FS.syncfs operations in flight at once, probably just doing extra work`);var o=tt(i.root.s),u=0;o.forEach(f=>{if(!f.type.va)return r(null);f.type.va(f,e,r)})},s(e,n,a){if(typeof e=="string")throw e;var r=a==="/",o=!a;if(r&&i.root)throw new i.g(10);if(!r&&!o){var u=z(a,{ba:!1});if(a=u.path,u=u.node,u.A)throw new i.g(10);if(!H(u.mode))throw new i.g(54)}return n={type:e,rb:n,ua:a,U:[]},e=e.s(n),e.s=n,n.root=e,r?i.root=e:u&&(u.A=n,u.s&&u.s.U.push(n)),e},xb(e){if(e=z(e,{ba:!1}),!e.node.A)throw new i.g(28);e=e.node;var n=e.A,a=tt(n);Object.keys(i.F).forEach(r=>{for(r=i.F[r];r;){var o=r.N;a.includes(r.s)&&je(r),r=o}}),e.A=null,n=e.s.U.indexOf(n),g(n!==-1),e.s.U.splice(n,1)},lookup(e,n){return e.h.lookup(e,n)},J(e,n,a){var r=z(e,{parent:!0}).node;if(e=le(e),!e||e==="."||e==="..")throw new i.g(28);var o=bn(r,e);if(o)throw new i.g(o);if(!r.h.J)throw new i.g(63);return r.h.J(r,e,n,a)},create(e,n){return i.J(e,(n!==void 0?n:438)&4095|32768,0)},mkdir(e,n){return i.J(e,(n!==void 0?n:511)&1023|16384,0)},ob(e,n){e=e.split("/");for(var a="",r=0;r<e.length;++r)if(e[r]){a+="/"+e[r];try{i.mkdir(a,n)}catch(o){if(o.u!=20)throw o}}},symlink(e,n){if(!de(e))throw new i.g(44);var a=z(n,{parent:!0}).node;if(!a)throw new i.g(44);n=le(n);var r=bn(a,n);if(r)throw new i.g(r);if(!a.h.symlink)throw new i.g(63);return a.h.symlink(a,n,e)},rename(e,n){var a=_n(e),r=_n(n),o=le(e),u=le(n),f=z(e,{parent:!0}),b=f.node;if(f=z(n,{parent:!0}),f=f.node,!b||!f)throw new i.g(44);if(b.s!==f.s)throw new i.g(75);var O=te(b,o);if(e=$n(e,r),e.charAt(0)!==".")throw new i.g(28);if(e=$n(n,a),e.charAt(0)!==".")throw new i.g(55);try{var y=te(f,u)}catch{}if(O!==y){if(n=H(O.mode),o=Ge(b,o,n))throw new i.g(o);if(o=y?Ge(f,u,n):bn(f,u))throw new i.g(o);if(!b.h.rename)throw new i.g(63);if(O.A||y&&y.A)throw new i.g(10);if(f!==b&&(o=_e(b,"w")))throw new i.g(o);je(O);try{b.h.rename(O,f,u)}catch(A){throw A}finally{et(O)}}},rmdir(e){var n=z(e,{parent:!0}).node;e=le(e);var a=te(n,e),r=Ge(n,e,!0);if(r)throw new i.g(r);if(!n.h.rmdir)throw new i.g(63);if(a.A)throw new i.g(10);n.h.rmdir(n,e),je(a)},readdir(e){if(e=z(e,{B:!0}).node,!e.h.readdir)throw new i.g(54);return e.h.readdir(e)},unlink(e){var n=z(e,{parent:!0}).node;if(!n)throw new i.g(44);e=le(e);var a=te(n,e),r=Ge(n,e,!1);if(r)throw new i.g(r);if(!n.h.unlink)throw new i.g(63);if(a.A)throw new i.g(10);n.h.unlink(n,e),je(a)},readlink(e){if(e=z(e).node,!e)throw new i.g(44);if(!e.h.readlink)throw new i.g(28);return de(ue(e.parent),e.h.readlink(e))},stat(e,n){if(e=z(e,{B:!n}).node,!e)throw new i.g(44);if(!e.h.C)throw new i.g(63);return e.h.C(e)},lstat(e){return i.stat(e,!0)},chmod(e,n,a){if(e=typeof e=="string"?z(e,{B:!a}).node:e,!e.h.v)throw new i.g(63);e.h.v(e,{mode:n&4095|e.mode&-4096,timestamp:Date.now()})},lchmod(e,n){i.chmod(e,n,!0)},fchmod(e,n){e=J(e),i.chmod(e.node,n)},chown(e,n,a,r){if(e=typeof e=="string"?z(e,{B:!r}).node:e,!e.h.v)throw new i.g(63);e.h.v(e,{timestamp:Date.now()})},lchown(e,n,a){i.chown(e,n,a,!0)},fchown(e,n,a){e=J(e),i.chown(e.node,n,a)},truncate(e,n){if(0>n)throw new i.g(28);if(e=typeof e=="string"?z(e,{B:!0}).node:e,!e.h.v)throw new i.g(63);if(H(e.mode))throw new i.g(31);if(!i.isFile(e.mode))throw new i.g(28);var a=_e(e,"w");if(a)throw new i.g(a);e.h.v(e,{size:n,timestamp:Date.now()})},kb(e,n){if(e=J(e),!(e.flags&2097155))throw new i.g(28);i.truncate(e.node,n)},yb(e,n,a){e=z(e,{B:!0}).node,e.h.v(e,{timestamp:Math.max(n,a)})},open(e,n,a){if(e==="")throw new i.g(44);if(typeof n=="string"){var r={r:0,"r+":2,w:577,"w+":578,a:1089,"a+":1090}[n];if(typeof r=="undefined")throw Error(`Unknown file open mode: ${n}`);n=r}if(a=n&64?(typeof a=="undefined"?438:a)&4095|32768:0,typeof e=="object")var o=e;else{e=ne(e);try{o=z(e,{B:!(n&131072)}).node}catch{}}if(r=!1,n&64)if(o){if(n&128)throw new i.g(20)}else o=i.J(e,a,0),r=!0;if(!o)throw new i.g(44);if((o.mode&61440)===8192&&(n&=-513),n&65536&&!H(o.mode))throw new i.g(54);if(!r&&(a=o?(o.mode&61440)===40960?32:H(o.mode)&&(nt(n)!=="r"||n&512)?31:_e(o,nt(n)):44))throw new i.g(a);return n&512&&!r&&i.truncate(o,0),n&=-131713,o=yn({node:o,path:ue(o),flags:n,seekable:!0,position:0,l:o.l,Xa:[],error:!1}),o.l.open&&o.l.open(o),!s.logReadFiles||n&1||(i.ja||(i.ja={}),e in i.ja||(i.ja[e]=1)),o},close(e){if(e.fd===null)throw new i.g(8);e.ea&&(e.ea=null);try{e.l.close&&e.l.close(e)}catch(n){throw n}finally{i.streams[e.fd]=null}e.fd=null},D(e,n,a){if(e.fd===null)throw new i.g(8);if(!e.seekable||!e.l.D)throw new i.g(70);if(a!=0&&a!=1&&a!=2)throw new i.g(28);return e.position=e.l.D(e,n,a),e.Xa=[],e.position},read(e,n,a,r,o){if(g(0<=a),0>r||0>o)throw new i.g(28);if(e.fd===null)throw new i.g(8);if((e.flags&2097155)===1)throw new i.g(8);if(H(e.node.mode))throw new i.g(31);if(!e.l.read)throw new i.g(28);var u=typeof o!="undefined";if(!u)o=e.position;else if(!e.seekable)throw new i.g(70);return n=e.l.read(e,n,a,r,o),u||(e.position+=n),n},write(e,n,a,r,o,u){if(g(0<=a),0>r||0>o)throw new i.g(28);if(e.fd===null)throw new i.g(8);if(!(e.flags&2097155))throw new i.g(8);if(H(e.node.mode))throw new i.g(31);if(!e.l.write)throw new i.g(28);e.seekable&&e.flags&1024&&i.D(e,0,2);var f=typeof o!="undefined";if(!f)o=e.position;else if(!e.seekable)throw new i.g(70);return n=e.l.write(e,n,a,r,o,u),f||(e.position+=n),n},T(e,n,a){if(e.fd===null)throw new i.g(8);if(0>n||0>=a)throw new i.g(28);if(!(e.flags&2097155))throw new i.g(8);if(!i.isFile(e.node.mode)&&!H(e.node.mode))throw new i.g(43);if(!e.l.T)throw new i.g(138);e.l.T(e,n,a)},S(e,n,a,r,o){if(r&2&&!(o&2)&&(e.flags&2097155)!==2)throw new i.g(2);if((e.flags&2097155)===1)throw new i.g(2);if(!e.l.S)throw new i.g(43);return e.l.S(e,n,a,r,o)},V(e,n,a,r,o){return g(0<=a),e.l.V?e.l.V(e,n,a,r,o):0},qb:()=>0,fa(e,n,a){if(!e.l.fa)throw new i.g(59);return e.l.fa(e,n,a)},readFile(e,n={}){if(n.flags=n.flags||0,n.encoding=n.encoding||"binary",n.encoding!=="utf8"&&n.encoding!=="binary")throw Error(`Invalid encoding type "${n.encoding}"`);var a,r=i.open(e,n.flags);e=i.stat(e).size;var o=new Uint8Array(e);return i.read(r,o,0,e,0),n.encoding==="utf8"?a=Le(o,0):n.encoding==="binary"&&(a=o),i.close(r),a},writeFile(e,n,a={}){if(a.flags=a.flags||577,e=i.open(e,a.flags,a.mode),typeof n=="string"){var r=new Uint8Array(Se(n)+1);n=fn(n,r,0,r.length),i.write(e,r,0,n,void 0,a.Ca)}else if(ArrayBuffer.isView(n))i.write(e,n,0,n.byteLength,void 0,a.Ca);else throw Error("Unsupported data type");i.close(e)},cwd:()=>i.oa,chdir(e){if(e=z(e,{B:!0}),e.node===null)throw new i.g(44);if(!H(e.node.mode))throw new i.g(54);var n=_e(e.node,"x");if(n)throw new i.g(n);i.oa=e.path},R(e,n,a){g(!i.R.Y,"FS.init was previously called. If you want to initialize later with custom parameters, remove any earlier calls (note that one is automatically added to the generated code)"),i.R.Y=!0,at(),s.stdin=e||s.stdin,s.stdout=n||s.stdout,s.stderr=a||s.stderr,s.stdin?i.L("/dev","stdin",s.stdin):i.symlink("/dev/tty","/dev/stdin"),s.stdout?i.L("/dev","stdout",null,s.stdout):i.symlink("/dev/tty","/dev/stdout"),s.stderr?i.L("/dev","stderr",null,s.stderr):i.symlink("/dev/tty1","/dev/stderr"),e=i.open("/dev/stdin",0),n=i.open("/dev/stdout",1),a=i.open("/dev/stderr",1),g(e.fd===0,`invalid handle for stdin (${e.fd})`),g(n.fd===1,`invalid handle for stdout (${n.fd})`),g(a.fd===2,`invalid handle for stderr (${a.fd})`)},sb(){i.R.Y=!1,ft(0);for(var e=0;e<i.streams.length;e++){var n=i.streams[e];n&&i.close(n)}},jb(e,n){return e=st(e,n),e.exists?e.object:null},hb(e,n){for(e=typeof e=="string"?e:ue(e),n=n.split("/").reverse();n.length;){var a=n.pop();if(a){var r=ne(e+"/"+a);try{i.mkdir(r)}catch{}e=r}}return r},L(e,n,a,r){e=Gt(typeof e=="string"?e:ue(e),n),n=mn(!!a,!!r),i.L.ha||(i.L.ha=64);var o=i.M(i.L.ha++,0);return hn(o,{open(u){u.seekable=!1},close(){r&&r.buffer&&r.buffer.length&&r(10)},read(u,f,b,O){for(var y=0,A=0;A<O;A++){try{var k=a()}catch{throw new i.g(29)}if(k===void 0&&y===0)throw new i.g(6);if(k==null)break;y++,f[b+A]=k}return y&&(u.node.timestamp=Date.now()),y},write(u,f,b,O){for(var y=0;y<O;y++)try{r(f[b+y])}catch{throw new i.g(29)}return O&&(u.node.timestamp=Date.now()),y}}),We(e,n,o)},fb(e,n,a,r,o){function u(){this.ga=!1,this.I=[]}function f(k,M,c,L,E){if(k=k.node.m,E>=k.length)return 0;if(L=Math.min(k.length-E,L),g(0<=L),k.slice)for(var R=0;R<L;R++)M[c+R]=k[E+R];else for(R=0;R<L;R++)M[c+R]=k.get(E+R);return L}if(u.prototype.get=function(k){if(!(k>this.length-1||0>k)){var M=k%this.chunkSize;return this.sa(k/this.chunkSize|0)[M]}},u.prototype.Ha=function(k){this.sa=k},u.prototype.ma=function(){var k=new XMLHttpRequest;if(k.open("HEAD",a,!1),k.send(null),!(200<=k.status&&300>k.status||k.status===304))throw Error("Couldn't load "+a+". Status: "+k.status);var M=Number(k.getResponseHeader("Content-length")),c,L=(c=k.getResponseHeader("Accept-Ranges"))&&c==="bytes";k=(c=k.getResponseHeader("Content-Encoding"))&&c==="gzip";var E=1048576;L||(E=M);var R=this;R.Ha(V=>{var K=V*E,X=(V+1)*E-1;if(X=Math.min(X,M-1),typeof R.I[V]=="undefined"){var Sn=R.I;if(K>X)throw Error("invalid range ("+K+", "+X+") or no bytes requested!");if(X>M-1)throw Error("only "+M+" bytes available! programmer error!");var G=new XMLHttpRequest;if(G.open("GET",a,!1),M!==E&&G.setRequestHeader("Range","bytes="+K+"-"+X),G.responseType="arraybuffer",G.overrideMimeType&&G.overrideMimeType("text/plain; charset=x-user-defined"),G.send(null),!(200<=G.status&&300>G.status||G.status===304))throw Error("Couldn't load "+a+". Status: "+G.status);K=G.response!==void 0?new Uint8Array(G.response||[]):He(G.responseText||"",!0),Sn[V]=K}if(typeof R.I[V]=="undefined")throw Error("doXHR failed!");return R.I[V]}),(k||!M)&&(E=M=1,E=M=this.sa(0).length,ke("LazyFiles on gzip forces download of the whole file when length is accessed")),this.za=M,this.ya=E,this.ga=!0},typeof XMLHttpRequest!="undefined"){if(!I)throw"Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";var b=new u;Object.defineProperties(b,{length:{get:function(){return this.ga||this.ma(),this.za}},chunkSize:{get:function(){return this.ga||this.ma(),this.ya}}});var O=void 0}else O=a,b=void 0;var y=aa(e,n,r,o);b?y.m=b:O&&(y.m=null,y.url=O),Object.defineProperties(y,{o:{get:function(){return this.m.length}}});var A={};return Object.keys(y.l).forEach(k=>{var M=y.l[k];A[k]=function(){return wn(y),M.apply(null,arguments)}}),A.read=(k,M,c,L,E)=>(wn(y),f(k,M,c,L,E)),A.S=(k,M,c)=>{wn(y);var L=Xn();if(!L)throw new i.g(48);return f(k,q,L,M,c),{Ra:L,Aa:!0}},y.l=A,y},Ya(){U("FS.absolutePath has been removed; use PATH_FS.resolve instead")},eb(){U("FS.createFolder has been removed; use FS.mkdir instead")},gb(){U("FS.createLink has been removed; use FS.symlink instead")},mb(){U("FS.joinPath has been removed; use PATH.join instead")},pb(){U("FS.mmapAlloc has been replaced by the top level function mmapAlloc")},vb(){U("FS.standardizePath has been removed; use PATH.normalize instead")}},Q=e=>(g(typeof e=="number",`UTF8ToString expects a number (got ${typeof e})`),e?Le(ze,e):"");function Ne(e,n){if(n.charAt(0)==="/")return n;if(e=e===-100?i.cwd():J(e).path,n.length==0)throw new i.g(44);return ne(e+"/"+n)}var Ae=void 0;function ae(){g(Ae!=null);var e=v[+Ae>>2];return Ae+=4,e}var $e=(e,n,a)=>(g(typeof a=="number","stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!"),fn(e,ze,n,a)),Oe=e=>e%4===0&&(e%100!==0||e%400===0),rt=[0,31,60,91,121,152,182,213,244,274,305,335],it=[0,31,59,90,120,151,181,212,243,273,304,334],vn=e=>{var n=Se(e)+1,a=ra(n);return a&&$e(e,a,n),a},Je={},ot=()=>{if(!kn){var e={USER:"web_user",LOGNAME:"web_user",PATH:"/",PWD:"/",HOME:"/home/web_user",LANG:(typeof navigator=="object"&&navigator.languages&&navigator.languages[0]||"C").replace("-","_")+".UTF-8",_:w||"./this.program"},n;for(n in Je)Je[n]===void 0?delete e[n]:e[n]=Je[n];var a=[];for(n in e)a.push(`${n}=${e[n]}`);kn=a}return kn},kn,lt=[31,29,31,30,31,30,31,31,30,31,30,31],dt=[31,28,31,30,31,30,31,31,30,31,30,31],ut=(e,n)=>{g(0<=e.length,"writeArrayToMemory array must have a length (should be an array or typed array)"),q.set(e,n)},ce=[],j,xn=e=>{var n=ce[e];return n||(e>=ce.length&&(ce.length=e+1),ce[e]=n=j.get(e)),g(j.get(e)==n,"JavaScript-side Wasm function table mirror is out of date!"),n},sa=e=>{var n=s["_"+e];return g(n,"Cannot call unknown function "+e+", make sure it is exported"),n},fe,Tn=[];function _t(e,n,a,r){e||(e=this),this.parent=e,this.s=e.s,this.A=null,this.id=i.Na++,this.name=n,this.mode=a,this.h={},this.l={},this.rdev=r}Object.defineProperties(_t.prototype,{read:{get:function(){return(this.mode&365)===365},set:function(e){e?this.mode|=365:this.mode&=-366}},write:{get:function(){return(this.mode&146)===146},set:function(e){e?this.mode|=146:this.mode&=-147}},Ma:{get:function(){return H(this.mode)}},La:{get:function(){return(this.mode&61440)===8192}}}),i.wa=_t,i.ib=(e,n,a,r,o,u,f,b,O,y)=>{function A(c){function L(E){if(y&&y(),!b){var R=e,V=n;if(R&&(R=typeof R=="string"?R:ue(R),V=n?ne(R+"/"+n):R),R=mn(r,o),V=i.create(V,R),E){if(typeof E=="string"){for(var K=Array(E.length),X=0,Sn=E.length;X<Sn;++X)K[X]=E.charCodeAt(X);E=K}i.chmod(V,R|146),K=i.open(V,577),i.write(K,E,0,E.length,0,O),i.close(K),i.chmod(V,R)}}u&&u(),Ve(M)}Zt(c,k,L,()=>{f&&f(),Ve(M)})||L(c)}var k=n?de(ne(e+"/"+n)):e,M=Nn(`cp ${k}`);dn(M),typeof a=="string"?Xt(a,c=>A(c),f):A(a)},at(),i.F=Array(4096),i.s(C,{},"/"),i.mkdir("/tmp"),i.mkdir("/home"),i.mkdir("/home/web_user"),function(){i.mkdir("/dev"),hn(i.M(1,3),{read:()=>0,write:(r,o,u,f)=>f}),We("/dev/null",i.M(1,3)),Kn(i.M(5,0),Jt),Kn(i.M(6,0),Kt),We("/dev/tty",i.M(5,0)),We("/dev/tty1",i.M(6,0));var e=new Uint8Array(1024),n=0,a=()=>(n===0&&(n=Wn(e).byteLength),e[--n]);i.L("/dev","random",a),i.L("/dev","urandom",a),i.mkdir("/dev/shm"),i.mkdir("/dev/shm/tmp")}(),function(){i.mkdir("/proc");var e=i.mkdir("/proc/self");i.mkdir("/proc/self/fd"),i.s({s(){var n=i.createNode(e,"fd",16895,73);return n.h={lookup(a,r){var o=J(+r);return a={parent:null,s:{ua:"fake"},h:{readlink:()=>o.path}},a.parent=a}},n}},{},"/proc/self/fd")}(),i.Fa={MEMFS:C};var ct={__syscall_dup3:function(e,n,a){try{var r=J(e);if(g(!a),r.fd===n)return-28;var o=i.qa(n);return o&&i.close(o),yn(r,n).fd}catch(u){if(typeof i=="undefined"||u.name!=="ErrnoError")throw u;return-u.u}},__syscall_fcntl64:function(e,n,a){Ae=a;try{var r=J(e);switch(n){case 0:var o=ae();if(0>o)return-28;for(;i.streams[o];)o++;return yn(r,o).fd;case 1:case 2:return 0;case 3:return r.flags;case 4:return o=ae(),r.flags|=o,0;case 5:return o=ae(),xe[o+0>>1]=2,0;case 6:case 7:return 0;case 16:case 8:return-28;case 9:return v[En()>>2]=28,-1;default:return-28}}catch(u){if(typeof i=="undefined"||u.name!=="ErrnoError")throw u;return-u.u}},__syscall_ioctl:function(e,n,a){Ae=a;try{var r=J(e);switch(n){case 21509:return r.tty?0:-59;case 21505:if(!r.tty)return-59;if(r.tty.K.Ia){e=[3,28,127,21,4,0,1,0,17,19,26,0,18,15,23,22,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];var o=ae();v[o>>2]=25856,v[o+4>>2]=5,v[o+8>>2]=191,v[o+12>>2]=35387;for(var u=0;32>u;u++)q[o+u+17>>0]=e[u]||0}return 0;case 21510:case 21511:case 21512:return r.tty?0:-59;case 21506:case 21507:case 21508:if(!r.tty)return-59;if(r.tty.K.Ja)for(o=ae(),e=[],u=0;32>u;u++)e.push(q[o+u+17>>0]);return 0;case 21519:return r.tty?(o=ae(),v[o>>2]=0):-59;case 21520:return r.tty?-28:-59;case 21531:return o=ae(),i.fa(r,n,o);case 21523:return r.tty?(r.tty.K.Ka&&(u=[24,80],o=ae(),xe[o>>1]=u[0],xe[o+2>>1]=u[1]),0):-59;case 21524:return r.tty?0:-59;case 21515:return r.tty?0:-59;default:return-28}}catch(f){if(typeof i=="undefined"||f.name!=="ErrnoError")throw f;return-f.u}},__syscall_openat:function(e,n,a,r){Ae=r;try{n=Q(n),n=Ne(e,n);var o=r?ae():0;return i.open(n,a,o).fd}catch(u){if(typeof i=="undefined"||u.name!=="ErrnoError")throw u;return-u.u}},__syscall_readlinkat:function(e,n,a,r){try{if(n=Q(n),n=Ne(e,n),0>=r)return-28;var o=i.readlink(n),u=Math.min(r,Se(o)),f=q[a+u];return $e(o,a,r+1),q[a+u]=f,u}catch(b){if(typeof i=="undefined"||b.name!=="ErrnoError")throw b;return-b.u}},__syscall_renameat:function(e,n,a,r){try{return n=Q(n),r=Q(r),n=Ne(e,n),r=Ne(a,r),i.rename(n,r),0}catch(o){if(typeof i=="undefined"||o.name!=="ErrnoError")throw o;return-o.u}},__syscall_rmdir:function(e){try{return e=Q(e),i.rmdir(e),0}catch(n){if(typeof i=="undefined"||n.name!=="ErrnoError")throw n;return-n.u}},__syscall_unlinkat:function(e,n,a){try{return n=Q(n),n=Ne(e,n),a===0?i.unlink(n):a===512?i.rmdir(n):U("Invalid flags passed to unlinkat"),0}catch(r){if(typeof i=="undefined"||r.name!=="ErrnoError")throw r;return-r.u}},_emscripten_get_now_is_monotonic:()=>1,_emscripten_throw_longjmp:()=>{throw 1/0},_gmtime_js:function(e,n){e=-9007199254740992>e||9007199254740992<e?NaN:Number(e),e=new Date(1e3*e),v[n>>2]=e.getUTCSeconds(),v[n+4>>2]=e.getUTCMinutes(),v[n+8>>2]=e.getUTCHours(),v[n+12>>2]=e.getUTCDate(),v[n+16>>2]=e.getUTCMonth(),v[n+20>>2]=e.getUTCFullYear()-1900,v[n+24>>2]=e.getUTCDay(),v[n+28>>2]=(e.getTime()-Date.UTC(e.getUTCFullYear(),0,1,0,0,0,0))/864e5|0},_localtime_js:function(e,n){e=-9007199254740992>e||9007199254740992<e?NaN:Number(e),e=new Date(1e3*e),v[n>>2]=e.getSeconds(),v[n+4>>2]=e.getMinutes(),v[n+8>>2]=e.getHours(),v[n+12>>2]=e.getDate(),v[n+16>>2]=e.getMonth(),v[n+20>>2]=e.getFullYear()-1900,v[n+24>>2]=e.getDay(),v[n+28>>2]=(Oe(e.getFullYear())?rt:it)[e.getMonth()]+e.getDate()-1|0,v[n+36>>2]=-(60*e.getTimezoneOffset());var a=new Date(e.getFullYear(),6,1).getTimezoneOffset(),r=new Date(e.getFullYear(),0,1).getTimezoneOffset();v[n+32>>2]=(a!=r&&e.getTimezoneOffset()==Math.min(r,a))|0},_mktime_js:function(e){var n=new Date(v[e+20>>2]+1900,v[e+16>>2],v[e+12>>2],v[e+8>>2],v[e+4>>2],v[e>>2],0),a=v[e+32>>2],r=n.getTimezoneOffset(),o=new Date(n.getFullYear(),6,1).getTimezoneOffset(),u=new Date(n.getFullYear(),0,1).getTimezoneOffset(),f=Math.min(u,o);return 0>a?v[e+32>>2]=+(o!=u&&f==r):0<a!=(f==r)&&(o=Math.max(u,o),n.setTime(n.getTime()+6e4*((0<a?f:o)-r))),v[e+24>>2]=n.getDay(),v[e+28>>2]=(Oe(n.getFullYear())?rt:it)[n.getMonth()]+n.getDate()-1|0,v[e>>2]=n.getSeconds(),v[e+4>>2]=n.getMinutes(),v[e+8>>2]=n.getHours(),v[e+12>>2]=n.getDate(),v[e+16>>2]=n.getMonth(),v[e+20>>2]=n.getYear(),e=n.getTime(),isNaN(e)?(v[En()>>2]=61,e=-1):e/=1e3,BigInt(e)},_tzset_js:(e,n,a)=>{function r(O){return(O=O.toTimeString().match(/\(([A-Za-z ]+)\)$/))?O[1]:"GMT"}var o=new Date().getFullYear(),u=new Date(o,0,1),f=new Date(o,6,1);o=u.getTimezoneOffset();var b=f.getTimezoneOffset();N[e>>2]=60*Math.max(o,b),v[n>>2]=+(o!=b),e=r(u),n=r(f),e=vn(e),n=vn(n),b<o?(N[a>>2]=e,N[a+4>>2]=n):(N[a>>2]=n,N[a+4>>2]=e)},abort:()=>{U("native code called abort()")},emscripten_date_now:()=>Date.now(),emscripten_get_now:()=>performance.now(),emscripten_resize_heap:e=>{var n=ze.length;if(e>>>=0,g(e>n),2147483648<e)return Y(`Cannot enlarge memory, requested ${e} bytes, but the limit is ${2147483648} bytes!`),!1;for(var a=1;4>=a;a*=2){var r=n*(1+.2/a);r=Math.min(r,e+100663296);var o=Math;r=Math.max(e,r),o=o.min.call(o,2147483648,r+(65536-r%65536)%65536);e:{r=o;var u=Fe.buffer,f=(r-u.byteLength+65535)/65536;try{Fe.grow(f),Rn();var b=1;break e}catch(O){Y(`growMemory: Attempted to grow heap from ${u.byteLength} bytes to ${r} bytes, but got error: ${O}`)}b=void 0}if(b)return!0}return Y(`Failed to grow the heap from ${n} bytes to ${o} bytes, not enough memory!`),!1},environ_get:(e,n)=>{var a=0;return ot().forEach((r,o)=>{var u=n+a;for(o=N[e+4*o>>2]=u,u=0;u<r.length;++u)g(r.charCodeAt(u)===(r.charCodeAt(u)&255)),q[o++>>0]=r.charCodeAt(u);q[o>>0]=0,a+=r.length+1}),0},environ_sizes_get:(e,n)=>{var a=ot();N[e>>2]=a.length;var r=0;return a.forEach(o=>r+=o.length+1),N[n>>2]=r,0},exit:e=>{la(),Ie=!0,S(e,new jn(e))},fd_close:function(e){try{var n=J(e);return i.close(n),0}catch(a){if(typeof i=="undefined"||a.name!=="ErrnoError")throw a;return a.u}},fd_read:function(e,n,a,r){try{e:{var o=J(e);e=n;for(var u,f=n=0;f<a;f++){var b=N[e>>2],O=N[e+4>>2];e+=8;var y=i.read(o,q,b,O,u);if(0>y){var A=-1;break e}if(n+=y,y<O)break;typeof u!="undefined"&&(u+=y)}A=n}return N[r>>2]=A,0}catch(k){if(typeof i=="undefined"||k.name!=="ErrnoError")throw k;return k.u}},fd_seek:function(e,n,a,r){n=-9007199254740992>n||9007199254740992<n?NaN:Number(n);try{if(isNaN(n))return 61;var o=J(e);return i.D(o,n,a),qe[r>>3]=BigInt(o.position),o.ea&&n===0&&a===0&&(o.ea=null),0}catch(u){if(typeof i=="undefined"||u.name!=="ErrnoError")throw u;return u.u}},fd_write:function(e,n,a,r){try{e:{var o=J(e);e=n;for(var u,f=n=0;f<a;f++){var b=N[e>>2],O=N[e+4>>2];e+=8;var y=i.write(o,q,b,O,u);if(0>y){var A=-1;break e}n+=y,typeof u!="undefined"&&(u+=y)}A=n}return N[r>>2]=A,0}catch(k){if(typeof i=="undefined"||k.name!=="ErrnoError")throw k;return k.u}},invoke_vii:oa,strftime:(e,n,a,r)=>{function o(c,L,E){for(c=typeof c=="number"?c.toString():c||"";c.length<L;)c=E[0]+c;return c}function u(c,L){return o(c,L,"0")}function f(c,L){function E(V){return 0>V?-1:0<V?1:0}var R;return(R=E(c.getFullYear()-L.getFullYear()))===0&&(R=E(c.getMonth()-L.getMonth()))===0&&(R=E(c.getDate()-L.getDate())),R}function b(c){switch(c.getDay()){case 0:return new Date(c.getFullYear()-1,11,29);case 1:return c;case 2:return new Date(c.getFullYear(),0,3);case 3:return new Date(c.getFullYear(),0,2);case 4:return new Date(c.getFullYear(),0,1);case 5:return new Date(c.getFullYear()-1,11,31);case 6:return new Date(c.getFullYear()-1,11,30)}}function O(c){var L=c.O;for(c=new Date(new Date(c.P+1900,0,1).getTime());0<L;){var E=c.getMonth(),R=(Oe(c.getFullYear())?lt:dt)[E];if(L>R-c.getDate())L-=R-c.getDate()+1,c.setDate(1),11>E?c.setMonth(E+1):(c.setMonth(0),c.setFullYear(c.getFullYear()+1));else{c.setDate(c.getDate()+L);break}}return E=new Date(c.getFullYear()+1,0,4),L=b(new Date(c.getFullYear(),0,4)),E=b(E),0>=f(L,c)?0>=f(E,c)?c.getFullYear()+1:c.getFullYear():c.getFullYear()-1}var y=N[r+40>>2];r={Va:v[r>>2],Ua:v[r+4>>2],$:v[r+8>>2],la:v[r+12>>2],aa:v[r+16>>2],P:v[r+20>>2],H:v[r+24>>2],O:v[r+28>>2],wb:v[r+32>>2],Ta:v[r+36>>2],Wa:y?Q(y):""},a=Q(a),y={"%c":"%a %b %d %H:%M:%S %Y","%D":"%m/%d/%y","%F":"%Y-%m-%d","%h":"%b","%r":"%I:%M:%S %p","%R":"%H:%M","%T":"%H:%M:%S","%x":"%m/%d/%y","%X":"%H:%M:%S","%Ec":"%c","%EC":"%C","%Ex":"%m/%d/%y","%EX":"%H:%M:%S","%Ey":"%y","%EY":"%Y","%Od":"%d","%Oe":"%e","%OH":"%H","%OI":"%I","%Om":"%m","%OM":"%M","%OS":"%S","%Ou":"%u","%OU":"%U","%OV":"%V","%Ow":"%w","%OW":"%W","%Oy":"%y"};for(var A in y)a=a.replace(new RegExp(A,"g"),y[A]);var k="Sunday Monday Tuesday Wednesday Thursday Friday Saturday".split(" "),M="January February March April May June July August September October November December".split(" ");y={"%a":c=>k[c.H].substring(0,3),"%A":c=>k[c.H],"%b":c=>M[c.aa].substring(0,3),"%B":c=>M[c.aa],"%C":c=>u((c.P+1900)/100|0,2),"%d":c=>u(c.la,2),"%e":c=>o(c.la,2," "),"%g":c=>O(c).toString().substring(2),"%G":c=>O(c),"%H":c=>u(c.$,2),"%I":c=>(c=c.$,c==0?c=12:12<c&&(c-=12),u(c,2)),"%j":c=>{for(var L=0,E=0;E<=c.aa-1;L+=(Oe(c.P+1900)?lt:dt)[E++]);return u(c.la+L,3)},"%m":c=>u(c.aa+1,2),"%M":c=>u(c.Ua,2),"%n":()=>`
`,"%p":c=>0<=c.$&&12>c.$?"AM":"PM","%S":c=>u(c.Va,2),"%t":()=>"	","%u":c=>c.H||7,"%U":c=>u(Math.floor((c.O+7-c.H)/7),2),"%V":c=>{var L=Math.floor((c.O+7-(c.H+6)%7)/7);if(2>=(c.H+371-c.O-2)%7&&L++,L)L==53&&(E=(c.H+371-c.O)%7,E==4||E==3&&Oe(c.P)||(L=1));else{L=52;var E=(c.H+7-c.O-1)%7;(E==4||E==5&&Oe(c.P%400-1))&&L++}return u(L,2)},"%w":c=>c.H,"%W":c=>u(Math.floor((c.O+7-(c.H+6)%7)/7),2),"%y":c=>(c.P+1900).toString().substring(2),"%Y":c=>c.P+1900,"%z":c=>{c=c.Ta;var L=0<=c;return c=Math.abs(c)/60,(L?"+":"-")+("0000"+(c/60*100+c%60)).slice(-4)},"%Z":c=>c.Wa,"%%":()=>"%"},a=a.replace(/%%/g,"\0\0");for(A in y)a.includes(A)&&(a=a.replace(new RegExp(A,"g"),y[A](r)));return a=a.replace(/\0\0/g,"%"),A=He(a,!1),A.length>n?0:(ut(A,e),A.length-1)},system:e=>{if(F){if(!e)return 1;if(e=Q(e),!e.length)return 0;e=ve("child_process").ub(e,[],{tb:!0,stdio:"inherit"});var n=(a,r)=>a<<8|r;return e.status===null?n(0,(a=>{switch(a){case"SIGHUP":return 1;case"SIGQUIT":return 3;case"SIGFPE":return 8;case"SIGKILL":return 9;case"SIGALRM":return 14;case"SIGTERM":return 15}return 2})(e.signal)):e.status<<8|0}return e?(v[En()>>2]=52,-1):0}},pe=function(){var e={env:ct,wasi_snapshot_preview1:ct};dn("wasm-instantiate");var n=s;return jt(e,function(a){g(s===n,"the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?"),n=null,pe=a.instance.exports,Fe=pe.memory,g(Fe,"memory not found in wasm exports"),Rn(),j=pe.__indirect_function_table,g(j,"table not found in wasm exports"),on.unshift(pe.__wasm_call_ctors),Ve("wasm-instantiate")}).catch(l),{}}();s._lua_checkstack=_("lua_checkstack"),s._lua_xmove=_("lua_xmove"),s._lua_atpanic=_("lua_atpanic"),s._lua_version=_("lua_version"),s._lua_absindex=_("lua_absindex"),s._lua_gettop=_("lua_gettop"),s._lua_settop=_("lua_settop"),s._lua_closeslot=_("lua_closeslot"),s._lua_rotate=_("lua_rotate"),s._lua_copy=_("lua_copy"),s._lua_pushvalue=_("lua_pushvalue"),s._lua_type=_("lua_type"),s._lua_typename=_("lua_typename"),s._lua_iscfunction=_("lua_iscfunction"),s._lua_isinteger=_("lua_isinteger"),s._lua_isnumber=_("lua_isnumber"),s._lua_isstring=_("lua_isstring"),s._lua_isuserdata=_("lua_isuserdata"),s._lua_rawequal=_("lua_rawequal"),s._lua_arith=_("lua_arith"),s._lua_compare=_("lua_compare"),s._lua_stringtonumber=_("lua_stringtonumber"),s._lua_tonumberx=_("lua_tonumberx"),s._lua_tointegerx=_("lua_tointegerx"),s._lua_toboolean=_("lua_toboolean"),s._lua_tolstring=_("lua_tolstring"),s._lua_rawlen=_("lua_rawlen"),s._lua_tocfunction=_("lua_tocfunction"),s._lua_touserdata=_("lua_touserdata"),s._lua_tothread=_("lua_tothread"),s._lua_topointer=_("lua_topointer"),s._lua_pushnil=_("lua_pushnil"),s._lua_pushnumber=_("lua_pushnumber"),s._lua_pushinteger=_("lua_pushinteger"),s._lua_pushlstring=_("lua_pushlstring"),s._lua_pushstring=_("lua_pushstring"),s._lua_pushcclosure=_("lua_pushcclosure"),s._lua_pushboolean=_("lua_pushboolean"),s._lua_pushlightuserdata=_("lua_pushlightuserdata"),s._lua_pushthread=_("lua_pushthread"),s._lua_getglobal=_("lua_getglobal"),s._lua_gettable=_("lua_gettable"),s._lua_getfield=_("lua_getfield"),s._lua_geti=_("lua_geti"),s._lua_rawget=_("lua_rawget"),s._lua_rawgeti=_("lua_rawgeti"),s._lua_rawgetp=_("lua_rawgetp"),s._lua_createtable=_("lua_createtable"),s._lua_getmetatable=_("lua_getmetatable"),s._lua_getiuservalue=_("lua_getiuservalue"),s._lua_setglobal=_("lua_setglobal"),s._lua_settable=_("lua_settable"),s._lua_setfield=_("lua_setfield"),s._lua_seti=_("lua_seti"),s._lua_rawset=_("lua_rawset"),s._lua_rawsetp=_("lua_rawsetp"),s._lua_rawseti=_("lua_rawseti"),s._lua_setmetatable=_("lua_setmetatable"),s._lua_setiuservalue=_("lua_setiuservalue"),s._lua_callk=_("lua_callk"),s._lua_pcallk=_("lua_pcallk"),s._lua_load=_("lua_load"),s._lua_dump=_("lua_dump"),s._lua_status=_("lua_status"),s._lua_error=_("lua_error"),s._lua_next=_("lua_next"),s._lua_toclose=_("lua_toclose"),s._lua_concat=_("lua_concat"),s._lua_len=_("lua_len"),s._lua_getallocf=_("lua_getallocf"),s._lua_setallocf=_("lua_setallocf"),s._lua_setwarnf=_("lua_setwarnf"),s._lua_warning=_("lua_warning"),s._lua_newuserdatauv=_("lua_newuserdatauv"),s._lua_getupvalue=_("lua_getupvalue"),s._lua_setupvalue=_("lua_setupvalue"),s._lua_upvalueid=_("lua_upvalueid"),s._lua_upvaluejoin=_("lua_upvaluejoin"),s._luaL_traceback=_("luaL_traceback"),s._lua_getstack=_("lua_getstack"),s._lua_getinfo=_("lua_getinfo"),s._luaL_buffinit=_("luaL_buffinit"),s._luaL_addstring=_("luaL_addstring"),s._luaL_prepbuffsize=_("luaL_prepbuffsize"),s._luaL_addvalue=_("luaL_addvalue"),s._luaL_pushresult=_("luaL_pushresult"),s._luaL_argerror=_("luaL_argerror"),s._luaL_typeerror=_("luaL_typeerror"),s._luaL_getmetafield=_("luaL_getmetafield"),s._luaL_where=_("luaL_where"),s._luaL_fileresult=_("luaL_fileresult");var En=_("__errno_location");s._luaL_execresult=_("luaL_execresult"),s._luaL_newmetatable=_("luaL_newmetatable"),s._luaL_setmetatable=_("luaL_setmetatable"),s._luaL_testudata=_("luaL_testudata"),s._luaL_checkudata=_("luaL_checkudata"),s._luaL_optlstring=_("luaL_optlstring"),s._luaL_checklstring=_("luaL_checklstring"),s._luaL_checkstack=_("luaL_checkstack"),s._luaL_checktype=_("luaL_checktype"),s._luaL_checkany=_("luaL_checkany"),s._luaL_checknumber=_("luaL_checknumber"),s._luaL_optnumber=_("luaL_optnumber"),s._luaL_checkinteger=_("luaL_checkinteger"),s._luaL_optinteger=_("luaL_optinteger"),s._luaL_setfuncs=_("luaL_setfuncs"),s._luaL_addlstring=_("luaL_addlstring"),s._luaL_pushresultsize=_("luaL_pushresultsize"),s._luaL_buffinitsize=_("luaL_buffinitsize"),s._luaL_ref=_("luaL_ref"),s._luaL_unref=_("luaL_unref"),s._luaL_loadfilex=_("luaL_loadfilex"),s._luaL_loadbufferx=_("luaL_loadbufferx"),s._luaL_loadstring=_("luaL_loadstring"),s._luaL_callmeta=_("luaL_callmeta"),s._luaL_len=_("luaL_len"),s._luaL_tolstring=_("luaL_tolstring"),s._luaL_getsubtable=_("luaL_getsubtable"),s._luaL_requiref=_("luaL_requiref"),s._luaL_addgsub=_("luaL_addgsub"),s._luaL_gsub=_("luaL_gsub"),s._luaL_newstate=_("luaL_newstate"),s._lua_newstate=_("lua_newstate"),s._free=_("free"),s._realloc=_("realloc");var ft=s._fflush=_("fflush");s._luaL_checkversion_=_("luaL_checkversion_"),s._luaopen_base=_("luaopen_base"),s._luaopen_coroutine=_("luaopen_coroutine"),s._lua_newthread=_("lua_newthread"),s._lua_yieldk=_("lua_yieldk"),s._lua_isyieldable=_("lua_isyieldable"),s._lua_resetthread=_("lua_resetthread"),s._lua_resume=_("lua_resume"),s._luaopen_debug=_("luaopen_debug"),s._lua_gethookmask=_("lua_gethookmask"),s._lua_gethook=_("lua_gethook"),s._lua_gethookcount=_("lua_gethookcount"),s._lua_getlocal=_("lua_getlocal"),s._lua_sethook=_("lua_sethook"),s._lua_setlocal=_("lua_setlocal"),s._lua_setcstacklimit=_("lua_setcstacklimit");var ra=s._malloc=_("malloc");s._luaL_openlibs=_("luaL_openlibs"),s._luaopen_package=_("luaopen_package"),s._luaopen_table=_("luaopen_table"),s._luaopen_io=_("luaopen_io"),s._luaopen_os=_("luaopen_os"),s._luaopen_string=_("luaopen_string"),s._luaopen_math=_("luaopen_math"),s._luaopen_utf8=_("luaopen_utf8"),s._lua_close=_("lua_close");var ia=_("setThrew"),pt=()=>(pt=pe.emscripten_stack_init)(),Ln=()=>(Ln=pe.emscripten_stack_get_end)(),mt=_("stackSave"),ht=_("stackRestore"),gt=_("stackAlloc");function oa(e,n,a){var r=mt();try{xn(e)(n,a)}catch(o){if(ht(r),o!==o+0)throw o;ia(1,0)}}s.ENV=Je,s.ccall=(e,n,a,r)=>{var o={string:y=>{var A=0;if(y!=null&&y!==0){A=Se(y)+1;var k=gt(A);$e(y,k,A),A=k}return A},array:y=>{var A=gt(y.length);return ut(y,A),A}};e=sa(e);var u=[],f=0;if(g(n!=="array",'Return type should not be "array".'),r)for(var b=0;b<r.length;b++){var O=o[a[b]];O?(f===0&&(f=mt()),u[b]=O(r[b])):u[b]=r[b]}return a=e.apply(null,u),a=function(y){return f!==0&&ht(f),n==="string"?Q(y):n==="boolean"?!!y:y}(a)},s.addFunction=(e,n)=>{if(g(typeof e!="undefined"),!fe){fe=new WeakMap;var a=j.length;if(fe)for(var r=0;r<0+a;r++){var o=xn(r);o&&fe.set(o,r)}}if(a=fe.get(e)||0)return a;if(Tn.length)a=Tn.pop();else{try{j.grow(1)}catch(b){throw b instanceof RangeError?"Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.":b}a=j.length-1}try{r=a,j.set(r,e),ce[r]=j.get(r)}catch(b){if(!(b instanceof TypeError))throw b;if(g(typeof n!="undefined","Missing signature argument to addFunction: "+e),typeof WebAssembly.Function=="function"){r=WebAssembly.Function,o={i:"i32",j:"i64",f:"f32",d:"f64",e:"externref",p:"i32"};for(var u={parameters:[],results:n[0]=="v"?[]:[o[n[0]]]},f=1;f<n.length;++f)g(n[f]in o,"invalid signature char: "+n[f]),u.parameters.push(o[n[f]]);n=new r(u,e)}else{for(r=[1],o=n.slice(0,1),n=n.slice(1),u={i:127,p:127,j:126,f:125,d:124,e:111},r.push(96),f=n.length,g(16384>f),128>f?r.push(f):r.push(f%128|128,f>>7),f=0;f<n.length;++f)g(n[f]in u,"invalid signature char: "+n[f]),r.push(u[n[f]]);o=="v"?r.push(0):r.push(1,u[o]),n=[0,97,115,109,1,0,0,0,1],o=r.length,g(16384>o),128>o?n.push(o):n.push(o%128|128,o>>7),n.push.apply(n,r),n.push(2,7,1,1,101,1,102,0,0,7,5,1,1,102,0,0),n=new WebAssembly.Module(new Uint8Array(n)),n=new WebAssembly.Instance(n,{e:{f:e}}).exports.f}r=a,j.set(r,n),ce[r]=j.get(r)}return fe.set(e,a),a},s.removeFunction=e=>{fe.delete(xn(e)),j.set(e,null),ce[e]=j.get(e),Tn.push(e)},s.setValue=function(e,n,a="i8"){switch(a.endsWith("*")&&(a="*"),a){case"i1":q[e>>0]=n;break;case"i8":q[e>>0]=n;break;case"i16":xe[e>>1]=n;break;case"i32":v[e>>2]=n;break;case"i64":qe[e>>3]=BigInt(n);break;case"float":tn[e>>2]=n;break;case"double":an[e>>3]=n;break;case"*":N[e>>2]=n;break;default:U(`invalid type for setValue: ${a}`)}},s.getValue=function(e,n="i8"){switch(n.endsWith("*")&&(n="*"),n){case"i1":return q[e>>0];case"i8":return q[e>>0];case"i16":return xe[e>>1];case"i32":return v[e>>2];case"i64":return qe[e>>3];case"float":return tn[e>>2];case"double":return an[e>>3];case"*":return N[e>>2];default:U(`invalid type for getValue: ${n}`)}},s.stringToUTF8=$e,s.lengthBytesUTF8=Se,s.stringToNewUTF8=vn,s.FS=i,"writeI53ToI64 writeI53ToI64Clamped writeI53ToI64Signaling writeI53ToU64Clamped writeI53ToU64Signaling readI53FromI64 readI53FromU64 convertI32PairToI53 convertI32PairToI53Checked convertU32PairToI53 inetPton4 inetNtop4 inetPton6 inetNtop6 readSockaddr writeSockaddr getHostByName getCallstack emscriptenLog convertPCtoSourceLocation readEmAsmArgs jstoi_q jstoi_s listenOnce autoResumeAudioContext getDynCaller dynCall handleException runtimeKeepalivePush runtimeKeepalivePop callUserCallback maybeExit asmjsMangle handleAllocatorInit HandleAllocator getNativeTypeSize STACK_SIZE STACK_ALIGN POINTER_SIZE ASSERTIONS cwrap reallyNegative unSign strLen reSign formatString intArrayToString AsciiToString UTF16ToString stringToUTF16 lengthBytesUTF16 UTF32ToString stringToUTF32 lengthBytesUTF32 registerKeyEventCallback maybeCStringToJsString findEventTarget findCanvasEventTarget getBoundingClientRect fillMouseEventData registerMouseEventCallback registerWheelEventCallback registerUiEventCallback registerFocusEventCallback fillDeviceOrientationEventData registerDeviceOrientationEventCallback fillDeviceMotionEventData registerDeviceMotionEventCallback screenOrientation fillOrientationChangeEventData registerOrientationChangeEventCallback fillFullscreenChangeEventData registerFullscreenChangeEventCallback JSEvents_requestFullscreen JSEvents_resizeCanvasForFullscreen registerRestoreOldStyle hideEverythingExceptGivenElement restoreHiddenElements setLetterbox softFullscreenResizeWebGLRenderTarget doRequestFullscreen fillPointerlockChangeEventData registerPointerlockChangeEventCallback registerPointerlockErrorEventCallback requestPointerLock fillVisibilityChangeEventData registerVisibilityChangeEventCallback registerTouchEventCallback fillGamepadEventData registerGamepadEventCallback registerBeforeUnloadEventCallback fillBatteryEventData battery registerBatteryEventCallback setCanvasElementSize getCanvasElementSize jsStackTrace stackTrace checkWasiClock wasiRightsToMuslOFlags wasiOFlagsToMuslOFlags createDyncallWrapper safeSetTimeout setImmediateWrapped clearImmediateWrapped polyfillSetImmediate getPromise makePromise idsToPromises makePromiseCallback setMainLoop getSocketFromFD getSocketAddress FS_unlink FS_mkdirTree _setNetworkCallback".split(" ").forEach(function(e){typeof globalThis=="undefined"||Object.getOwnPropertyDescriptor(globalThis,e)||Object.defineProperty(globalThis,e,{configurable:!0,get(){var n=`\`${e}\` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line`,a=e;a.startsWith("_")||(a="$"+e),n+=` (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='${a}')`,qn(e)&&(n+=". Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you"),Ee(n)}}),Hn(e)}),"run addOnPreRun addOnInit addOnPreMain addOnExit addOnPostRun addRunDependency removeRunDependency FS_createFolder FS_createPath FS_createLazyFile FS_createLink FS_createDevice FS_readFile out err callMain abort wasmMemory wasmExports stackAlloc stackSave stackRestore getTempRet0 setTempRet0 writeStackCookie checkStackCookie MAX_INT53 MIN_INT53 bigintToI53Checked ptrToString zeroMemory exitJS getHeapMax growMemory MONTH_DAYS_REGULAR MONTH_DAYS_LEAP MONTH_DAYS_REGULAR_CUMULATIVE MONTH_DAYS_LEAP_CUMULATIVE isLeapYear ydayFromDate arraySum addDays ERRNO_CODES ERRNO_MESSAGES setErrNo DNS Protocols Sockets initRandomFill randomFill timers warnOnce UNWIND_CACHE readEmAsmArgsArray getExecutableName keepRuntimeAlive asyncLoad alignMemory mmapAlloc wasmTable noExitRuntime getCFunc uleb128Encode sigToWasmTypes generateFuncType convertJsFunctionToWasm freeTableIndexes functionsInTableMap getEmptyTableSlot updateTableMap getFunctionAddress PATH PATH_FS UTF8Decoder UTF8ArrayToString UTF8ToString stringToUTF8Array intArrayFromString stringToAscii UTF16Decoder stringToUTF8OnStack writeArrayToMemory JSEvents specialHTMLTargets currentFullscreenStrategy restoreOldWindowedStyle demangle demangleAll ExitStatus getEnvStrings doReadv doWritev promiseMap Browser wget SYSCALLS preloadPlugins FS_createPreloadedFile FS_modeStringToFlags FS_getMode FS_stdin_getChar_buffer FS_stdin_getChar FS_createDataFile MEMFS TTY PIPEFS SOCKFS".split(" ").forEach(Hn);var Ke;De=function e(){Ke||bt(),Ke||(De=e)};function bt(){if(!(0<Re)){pt();var e=Ln();if(g((e&3)==0),e==0&&(e+=4),N[e>>2]=34821223,N[e+4>>2]=2310721022,N[0]=1668509029,s.preRun)for(typeof s.preRun=="function"&&(s.preRun=[s.preRun]);s.preRun.length;)e=s.preRun.shift(),rn.unshift(e);for(;0<rn.length;)rn.shift()(s);if(!(0<Re)){if(!Ke&&(Ke=!0,s.calledRun=!0,!Ie)){for(g(!ln),ln=!0,sn(),s.noFSInit||i.R.Y||i.R(),i.ta=!1;0<on.length;)on.shift()(s);for(d(s),g(!s._main,'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]'),sn();0<Mn.length;)Mn.shift()(s)}sn()}}}function la(){var e=ke,n=Y,a=!1;ke=Y=()=>{a=!0};try{ft(0),["stdout","stderr"].forEach(function(r){(r=st("/dev/"+r))&&(r=pn[r.object.rdev])&&r.output&&r.output.length&&(a=!0)})}catch{}ke=e,Y=n,a&&Ee("stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.")}return bt(),t.ready}})();class Ye{static async initialize(t,s){let d=await zt({locateFile:(l,p)=>t||p+l,preRun:l=>{typeof s=="object"&&Object.entries(s).forEach(([p,w])=>l.ENV[p]=w)}});return new Ye(d)}constructor(t){this.referenceTracker=new WeakMap,this.referenceMap=new Map,this.availableReferences=[],this.module=t,this.luaL_checkversion_=this.cwrap("luaL_checkversion_",null,["number","number","number"]),this.luaL_getmetafield=this.cwrap("luaL_getmetafield","number",["number","number","string"]),this.luaL_callmeta=this.cwrap("luaL_callmeta","number",["number","number","string"]),this.luaL_tolstring=this.cwrap("luaL_tolstring","string",["number","number","number"]),this.luaL_argerror=this.cwrap("luaL_argerror","number",["number","number","string"]),this.luaL_typeerror=this.cwrap("luaL_typeerror","number",["number","number","string"]),this.luaL_checklstring=this.cwrap("luaL_checklstring","string",["number","number","number"]),this.luaL_optlstring=this.cwrap("luaL_optlstring","string",["number","number","string","number"]),this.luaL_checknumber=this.cwrap("luaL_checknumber","number",["number","number"]),this.luaL_optnumber=this.cwrap("luaL_optnumber","number",["number","number","number"]),this.luaL_checkinteger=this.cwrap("luaL_checkinteger","number",["number","number"]),this.luaL_optinteger=this.cwrap("luaL_optinteger","number",["number","number","number"]),this.luaL_checkstack=this.cwrap("luaL_checkstack",null,["number","number","string"]),this.luaL_checktype=this.cwrap("luaL_checktype",null,["number","number","number"]),this.luaL_checkany=this.cwrap("luaL_checkany",null,["number","number"]),this.luaL_newmetatable=this.cwrap("luaL_newmetatable","number",["number","string"]),this.luaL_setmetatable=this.cwrap("luaL_setmetatable",null,["number","string"]),this.luaL_testudata=this.cwrap("luaL_testudata","number",["number","number","string"]),this.luaL_checkudata=this.cwrap("luaL_checkudata","number",["number","number","string"]),this.luaL_where=this.cwrap("luaL_where",null,["number","number"]),this.luaL_fileresult=this.cwrap("luaL_fileresult","number",["number","number","string"]),this.luaL_execresult=this.cwrap("luaL_execresult","number",["number","number"]),this.luaL_ref=this.cwrap("luaL_ref","number",["number","number"]),this.luaL_unref=this.cwrap("luaL_unref",null,["number","number","number"]),this.luaL_loadfilex=this.cwrap("luaL_loadfilex","number",["number","string","string"]),this.luaL_loadbufferx=this.cwrap("luaL_loadbufferx","number",["number","string|number","number","string|number","string"]),this.luaL_loadstring=this.cwrap("luaL_loadstring","number",["number","string"]),this.luaL_newstate=this.cwrap("luaL_newstate","number",[]),this.luaL_len=this.cwrap("luaL_len","number",["number","number"]),this.luaL_addgsub=this.cwrap("luaL_addgsub",null,["number","string","string","string"]),this.luaL_gsub=this.cwrap("luaL_gsub","string",["number","string","string","string"]),this.luaL_setfuncs=this.cwrap("luaL_setfuncs",null,["number","number","number"]),this.luaL_getsubtable=this.cwrap("luaL_getsubtable","number",["number","number","string"]),this.luaL_traceback=this.cwrap("luaL_traceback",null,["number","number","string","number"]),this.luaL_requiref=this.cwrap("luaL_requiref",null,["number","string","number","number"]),this.luaL_buffinit=this.cwrap("luaL_buffinit",null,["number","number"]),this.luaL_prepbuffsize=this.cwrap("luaL_prepbuffsize","string",["number","number"]),this.luaL_addlstring=this.cwrap("luaL_addlstring",null,["number","string","number"]),this.luaL_addstring=this.cwrap("luaL_addstring",null,["number","string"]),this.luaL_addvalue=this.cwrap("luaL_addvalue",null,["number"]),this.luaL_pushresult=this.cwrap("luaL_pushresult",null,["number"]),this.luaL_pushresultsize=this.cwrap("luaL_pushresultsize",null,["number","number"]),this.luaL_buffinitsize=this.cwrap("luaL_buffinitsize","string",["number","number","number"]),this.lua_newstate=this.cwrap("lua_newstate","number",["number","number"]),this.lua_close=this.cwrap("lua_close",null,["number"]),this.lua_newthread=this.cwrap("lua_newthread","number",["number"]),this.lua_resetthread=this.cwrap("lua_resetthread","number",["number"]),this.lua_atpanic=this.cwrap("lua_atpanic","number",["number","number"]),this.lua_version=this.cwrap("lua_version","number",["number"]),this.lua_absindex=this.cwrap("lua_absindex","number",["number","number"]),this.lua_gettop=this.cwrap("lua_gettop","number",["number"]),this.lua_settop=this.cwrap("lua_settop",null,["number","number"]),this.lua_pushvalue=this.cwrap("lua_pushvalue",null,["number","number"]),this.lua_rotate=this.cwrap("lua_rotate",null,["number","number","number"]),this.lua_copy=this.cwrap("lua_copy",null,["number","number","number"]),this.lua_checkstack=this.cwrap("lua_checkstack","number",["number","number"]),this.lua_xmove=this.cwrap("lua_xmove",null,["number","number","number"]),this.lua_isnumber=this.cwrap("lua_isnumber","number",["number","number"]),this.lua_isstring=this.cwrap("lua_isstring","number",["number","number"]),this.lua_iscfunction=this.cwrap("lua_iscfunction","number",["number","number"]),this.lua_isinteger=this.cwrap("lua_isinteger","number",["number","number"]),this.lua_isuserdata=this.cwrap("lua_isuserdata","number",["number","number"]),this.lua_type=this.cwrap("lua_type","number",["number","number"]),this.lua_typename=this.cwrap("lua_typename","string",["number","number"]),this.lua_tonumberx=this.cwrap("lua_tonumberx","number",["number","number","number"]),this.lua_tointegerx=this.cwrap("lua_tointegerx","number",["number","number","number"]),this.lua_toboolean=this.cwrap("lua_toboolean","number",["number","number"]),this.lua_tolstring=this.cwrap("lua_tolstring","string",["number","number","number"]),this.lua_rawlen=this.cwrap("lua_rawlen","number",["number","number"]),this.lua_tocfunction=this.cwrap("lua_tocfunction","number",["number","number"]),this.lua_touserdata=this.cwrap("lua_touserdata","number",["number","number"]),this.lua_tothread=this.cwrap("lua_tothread","number",["number","number"]),this.lua_topointer=this.cwrap("lua_topointer","number",["number","number"]),this.lua_arith=this.cwrap("lua_arith",null,["number","number"]),this.lua_rawequal=this.cwrap("lua_rawequal","number",["number","number","number"]),this.lua_compare=this.cwrap("lua_compare","number",["number","number","number","number"]),this.lua_pushnil=this.cwrap("lua_pushnil",null,["number"]),this.lua_pushnumber=this.cwrap("lua_pushnumber",null,["number","number"]),this.lua_pushinteger=this.cwrap("lua_pushinteger",null,["number","number"]),this.lua_pushlstring=this.cwrap("lua_pushlstring","string",["number","string|number","number"]),this.lua_pushstring=this.cwrap("lua_pushstring","string",["number","string|number"]),this.lua_pushcclosure=this.cwrap("lua_pushcclosure",null,["number","number","number"]),this.lua_pushboolean=this.cwrap("lua_pushboolean",null,["number","number"]),this.lua_pushlightuserdata=this.cwrap("lua_pushlightuserdata",null,["number","number"]),this.lua_pushthread=this.cwrap("lua_pushthread","number",["number"]),this.lua_getglobal=this.cwrap("lua_getglobal","number",["number","string"]),this.lua_gettable=this.cwrap("lua_gettable","number",["number","number"]),this.lua_getfield=this.cwrap("lua_getfield","number",["number","number","string"]),this.lua_geti=this.cwrap("lua_geti","number",["number","number","number"]),this.lua_rawget=this.cwrap("lua_rawget","number",["number","number"]),this.lua_rawgeti=this.cwrap("lua_rawgeti","number",["number","number","number"]),this.lua_rawgetp=this.cwrap("lua_rawgetp","number",["number","number","number"]),this.lua_createtable=this.cwrap("lua_createtable",null,["number","number","number"]),this.lua_newuserdatauv=this.cwrap("lua_newuserdatauv","number",["number","number","number"]),this.lua_getmetatable=this.cwrap("lua_getmetatable","number",["number","number"]),this.lua_getiuservalue=this.cwrap("lua_getiuservalue","number",["number","number","number"]),this.lua_setglobal=this.cwrap("lua_setglobal",null,["number","string"]),this.lua_settable=this.cwrap("lua_settable",null,["number","number"]),this.lua_setfield=this.cwrap("lua_setfield",null,["number","number","string"]),this.lua_seti=this.cwrap("lua_seti",null,["number","number","number"]),this.lua_rawset=this.cwrap("lua_rawset",null,["number","number"]),this.lua_rawseti=this.cwrap("lua_rawseti",null,["number","number","number"]),this.lua_rawsetp=this.cwrap("lua_rawsetp",null,["number","number","number"]),this.lua_setmetatable=this.cwrap("lua_setmetatable","number",["number","number"]),this.lua_setiuservalue=this.cwrap("lua_setiuservalue","number",["number","number","number"]),this.lua_callk=this.cwrap("lua_callk",null,["number","number","number","number","number"]),this.lua_pcallk=this.cwrap("lua_pcallk","number",["number","number","number","number","number","number"]),this.lua_load=this.cwrap("lua_load","number",["number","number","number","string","string"]),this.lua_dump=this.cwrap("lua_dump","number",["number","number","number","number"]),this.lua_yieldk=this.cwrap("lua_yieldk","number",["number","number","number","number"]),this.lua_resume=this.cwrap("lua_resume","number",["number","number","number","number"]),this.lua_status=this.cwrap("lua_status","number",["number"]),this.lua_isyieldable=this.cwrap("lua_isyieldable","number",["number"]),this.lua_setwarnf=this.cwrap("lua_setwarnf",null,["number","number","number"]),this.lua_warning=this.cwrap("lua_warning",null,["number","string","number"]),this.lua_error=this.cwrap("lua_error","number",["number"]),this.lua_next=this.cwrap("lua_next","number",["number","number"]),this.lua_concat=this.cwrap("lua_concat",null,["number","number"]),this.lua_len=this.cwrap("lua_len",null,["number","number"]),this.lua_stringtonumber=this.cwrap("lua_stringtonumber","number",["number","string"]),this.lua_getallocf=this.cwrap("lua_getallocf","number",["number","number"]),this.lua_setallocf=this.cwrap("lua_setallocf",null,["number","number","number"]),this.lua_toclose=this.cwrap("lua_toclose",null,["number","number"]),this.lua_closeslot=this.cwrap("lua_closeslot",null,["number","number"]),this.lua_getstack=this.cwrap("lua_getstack","number",["number","number","number"]),this.lua_getinfo=this.cwrap("lua_getinfo","number",["number","string","number"]),this.lua_getlocal=this.cwrap("lua_getlocal","string",["number","number","number"]),this.lua_setlocal=this.cwrap("lua_setlocal","string",["number","number","number"]),this.lua_getupvalue=this.cwrap("lua_getupvalue","string",["number","number","number"]),this.lua_setupvalue=this.cwrap("lua_setupvalue","string",["number","number","number"]),this.lua_upvalueid=this.cwrap("lua_upvalueid","number",["number","number","number"]),this.lua_upvaluejoin=this.cwrap("lua_upvaluejoin",null,["number","number","number","number","number"]),this.lua_sethook=this.cwrap("lua_sethook",null,["number","number","number","number"]),this.lua_gethook=this.cwrap("lua_gethook","number",["number"]),this.lua_gethookmask=this.cwrap("lua_gethookmask","number",["number"]),this.lua_gethookcount=this.cwrap("lua_gethookcount","number",["number"]),this.lua_setcstacklimit=this.cwrap("lua_setcstacklimit","number",["number","number"]),this.luaopen_base=this.cwrap("luaopen_base","number",["number"]),this.luaopen_coroutine=this.cwrap("luaopen_coroutine","number",["number"]),this.luaopen_table=this.cwrap("luaopen_table","number",["number"]),this.luaopen_io=this.cwrap("luaopen_io","number",["number"]),this.luaopen_os=this.cwrap("luaopen_os","number",["number"]),this.luaopen_string=this.cwrap("luaopen_string","number",["number"]),this.luaopen_utf8=this.cwrap("luaopen_utf8","number",["number"]),this.luaopen_math=this.cwrap("luaopen_math","number",["number"]),this.luaopen_debug=this.cwrap("luaopen_debug","number",["number"]),this.luaopen_package=this.cwrap("luaopen_package","number",["number"]),this.luaL_openlibs=this.cwrap("luaL_openlibs",null,["number"])}lua_remove(t,s){this.lua_rotate(t,s,-1),this.lua_pop(t,1)}lua_pop(t,s){this.lua_settop(t,-s-1)}luaL_getmetatable(t,s){return this.lua_getfield(t,$,s)}lua_yield(t,s){return this.lua_yieldk(t,s,0,null)}lua_upvalueindex(t){return $-t}ref(t){let s=this.referenceTracker.get(t);if(s)return s.refCount++,s.index;let d=this.availableReferences.pop(),l=d===void 0?this.referenceMap.size+1:d;return this.referenceMap.set(l,t),this.referenceTracker.set(t,{refCount:1,index:l}),this.lastRefIndex=l,l}unref(t){let s=this.referenceMap.get(t);if(s===void 0)return;let d=this.referenceTracker.get(s);if(d===void 0){this.referenceTracker.delete(s),this.availableReferences.push(t);return}d.refCount--,d.refCount<=0&&(this.referenceTracker.delete(s),this.referenceMap.delete(t),this.availableReferences.push(t))}getRef(t){return this.referenceMap.get(t)}getLastRefIndex(){return this.lastRefIndex}printRefs(){for(let[t,s]of this.referenceMap.entries())console.log(t,s)}cwrap(t,s,d){return d.some(p=>p==="string|number")?(...p)=>{let w=[],S=d.map((x,I)=>{var F;if(x==="string|number"){if(typeof p[I]=="number")return"number";if(((F=p[I])===null||F===void 0?void 0:F.length)>1024){let D=this.module.stringToNewUTF8(p[I]);return p[I]=D,w.push(D),"number"}else return"string"}return x});try{return this.module.ccall(t,s,S,p)}finally{for(let x of w)this.module._free(x)}}:(...p)=>this.module.ccall(t,s,d,p)}}var qt="1.16.0";class Vt{constructor(t,s){var d;t===void 0&&(typeof window=="object"&&typeof window.document!="undefined"||typeof self=="object"&&((d=self==null?void 0:self.constructor)===null||d===void 0?void 0:d.name)==="DedicatedWorkerGlobalScope")&&(t=`https://unpkg.com/wasmoon@${qt}/dist/glue.wasm`),this.luaWasmPromise=Ye.initialize(t,s)}async mountFile(t,s){this.mountFileSync(await this.getLuaModule(),t,s)}mountFileSync(t,s,d){let l=s.lastIndexOf("/"),p=s.substring(l+1),w=s.substring(0,s.length-p.length-1);if(w.length>0){let S=w.split("/").reverse(),x="";for(;S.length;){let I=S.pop();if(!I)continue;let F=`${x}/${I}`;try{t.module.FS.mkdir(F)}catch{}x=F}}t.module.FS.writeFile(s,d)}async createEngine(t={}){return new Fn(await this.getLuaModule(),t)}async getLuaModule(){return this.luaWasmPromise}}h.Decoration=Z,h.LUAI_MAXSTACK=se,h.LUA_MULTRET=me,h.LUA_REGISTRYINDEX=$,h.LuaEngine=Fn,h.LuaFactory=Vt,h.LuaGlobal=On,h.LuaMultiReturn=he,h.LuaRawResult=Ue,h.LuaThread=ge,h.LuaTimeoutError=Qe,h.LuaTypeExtension=re,h.LuaWasm=Ye,h.PointerSize=W,h.decorate=Tt,h.decorateFunction=Ze,h.decorateProxy=Cn,h.decorateUserdata=Bt})});var xt=wt((wa,ha)=>{ha.exports=`local __bundle_require, __bundle_loaded, __bundle_register, __bundle_modules = (function(superRequire)
	local loadingPlaceholder = {[{}] = true}

	local register
	local modules = {}

	local require
	local loaded = {}

	register = function(name, body)
		if not modules[name] then
			modules[name] = body
		end
	end

	require = function(name)
		local loadedModule = loaded[name]

		if loadedModule then
			if loadedModule == loadingPlaceholder then
				return nil
			end
		else
			if not modules[name] then
				if not superRequire then
					local identifier = type(name) == 'string' and '\\"' .. name .. '\\"' or tostring(name)
					error('Tried to require ' .. identifier .. ', but no such module has been registered')
				else
					return superRequire(name)
				end
			end

			loaded[name] = loadingPlaceholder
			loadedModule = modules[name](require, loaded, register, modules)
			loaded[name] = loadedModule
		end

		return loadedModule
	end

	return require, loaded, register, modules
end)(nil)
__bundle_register("__root", function(require, _LOADED, __bundle_register, __bundle_modules)
local check = require("luacheck.check")
local filter = require("luacheck.filter")
local options = require("luacheck.options")
local format = require("luacheck.format")
local utils = require("luacheck.utils")

local luacheck = {
   _VERSION = "0.23.0"
}

local function raw_validate_options(fname, opts, stds, context)
   local ok, err = options.validate(options.all_options, opts, stds)

   if not ok then
      if context then
         error(("bad argument #2 to '%s' (%s: %s)"):format(fname, context, err))
      else
         error(("bad argument #2 to '%s' (%s)"):format(fname, err))
      end
   end
end

local function validate_options(fname, items, opts, stds)
   raw_validate_options(fname, opts)

   if opts ~= nil then
      for i in ipairs(items) do
         raw_validate_options(fname, opts[i], stds, ("invalid options at index [%d]"):format(i))

         if opts[i] ~= nil then
            for j, nested_opts in ipairs(opts[i]) do
               raw_validate_options(fname, nested_opts, stds, ("invalid options at index [%d][%d]"):format(i, j))
            end
         end
      end
   end
end

-- Returns report for a string.
function luacheck.get_report(src)
   local msg = ("bad argument #1 to 'luacheck.get_report' (string expected, got %s)"):format(type(src))
   assert(type(src) == "string", msg)
   return check(src)
end

-- Applies options to reports. Reports with .fatal field are unchanged.
-- Options are applied to reports[i] in order: options, options[i], options[i][1], options[i][2], ...
-- Returns new array of reports, adds .warnings, .errors and .fatals fields to this array.
function luacheck.process_reports(reports, opts, stds)
   local msg = ("bad argument #1 to 'luacheck.process_reports' (table expected, got %s)"):format(type(reports))
   assert(type(reports) == "table", msg)
   validate_options("luacheck.process_reports", reports, opts, stds)
   local report = filter.filter(reports, opts, stds)
   report.warnings = 0
   report.errors = 0
   report.fatals = 0

   for _, file_report in ipairs(report) do
      if file_report.fatal then
         report.fatals = report.fatals + 1
      else
         for _, event in ipairs(file_report) do
            if event.code:sub(1, 1) == "0" then
               report.errors = report.errors + 1
            else
               report.warnings = report.warnings + 1
            end
         end
      end
   end

   return report
end

-- Checks strings with options, returns report.
-- Tables with .fatal field are unchanged.
function luacheck.check_strings(srcs, opts)
   local msg = ("bad argument #1 to 'luacheck.check_strings' (table expected, got %s)"):format(type(srcs))
   assert(type(srcs) == "table", msg)

   for _, item in ipairs(srcs) do
      msg = ("bad argument #1 to 'luacheck.check_strings' (array of strings or tables expected, got %s)"):format(
         type(item))
      assert(type(item) == "string" or type(item) == "table", msg)
   end

   validate_options("luacheck.check_strings", srcs, opts)

   local reports = {}

   for i, src in ipairs(srcs) do
      if type(src) == "table" and src.fatal then
         reports[i] = src
      else
         reports[i] = luacheck.get_report(src)
      end
   end

   return luacheck.process_reports(reports, opts)
end

function luacheck.check_files(files, opts)
   local msg = ("bad argument #1 to 'luacheck.check_files' (table expected, got %s)"):format(type(files))
   assert(type(files) == "table", msg)

   for _, item in ipairs(files) do
      msg = ("bad argument #1 to 'luacheck.check_files' (array of paths or file handles expected, got %s)"):format(
         type(item))
      assert(type(item) == "string" or io.type(item) == "file", msg
      )
   end

   validate_options("luacheck.check_files", files, opts)

   local srcs = {}

   for i, file in ipairs(files) do
      local src, err = utils.read_file(file)
      srcs[i] = src or {fatal = "I/O", msg = err}
   end

   return luacheck.check_strings(srcs, opts)
end

function luacheck.get_message(issue)
   local msg = ("bad argument #1 to 'luacheck.get_message' (table expected, got %s)"):format(type(issue))
   assert(type(issue) == "table", msg)
   return format.get_message(issue)
end

setmetatable(luacheck, {__call = function(_, ...)
   return luacheck.check_files(...)
end})

return luacheck

end)
__bundle_register("luacheck.utils", function(require, _LOADED, __bundle_register, __bundle_modules)
-- luacheck: push compat
local unpack = table.unpack or unpack
local pack = table.pack or function(...) return {n = select("#", ...), ...} end
-- luacheck: pop

local utils = {}

utils.dir_sep = package.config:sub(1,1)
utils.is_windows = utils.dir_sep == "\\\\"

local bom = "\\239\\187\\191"

-- Returns all contents of file (path or file handler) or nil + error message.
function utils.read_file(file)
   local handler

   if type(file) == "string" then
      local open_err
      handler, open_err = io.open(file, "rb")

      if not handler then
         open_err = utils.unprefix(open_err, file .. ": ")
         return nil, "couldn't read: " .. open_err
      end
   else
      handler = file
   end

   local res, read_err = handler:read("*a")
   handler:close()

   if not res then
      return nil, "couldn't read: " .. read_err
   end

   -- Use :len() instead of # operator because in some environments
   -- string library is patched to handle UTF.
   if res:sub(1, bom:len()) == bom then
      res = res:sub(bom:len() + 1)
   end

   return res
end

-- luacheck: push
-- luacheck: compat
if _VERSION:find "5.1" then
   -- Loads Lua source string in an environment, returns function or nil, error.
   function utils.load(src, env, chunkname)
      local func, err = loadstring(src, chunkname)

      if func then
         if env then
            setfenv(func, env)
         end

         return func
      else
         return nil, err
      end
   end
else
   -- Loads Lua source string in an environment, returns function or nil, error.
   function utils.load(src, env, chunkname)
      return load(src, chunkname, "t", env or _ENV)
   end
end
-- luacheck: pop

-- Loads config containing assignments to global variables from path.
-- Returns config table and return value of config or nil and error type
-- ("I/O" or "syntax" or "runtime") and error message.
function utils.load_config(path, env)
   env = env or {}
   local src, read_err = utils.read_file(path)

   if not src then
      return nil, "I/O", read_err
   end

   local func, load_err = utils.load(src, env, "chunk")

   if not func then
      return nil, "syntax", "line " .. utils.unprefix(load_err, "[string \\"chunk\\"]:")
   end

   local ok, res = pcall(func)

   if not ok then
      return nil, "runtime", "line " .. utils.unprefix(res, "[string \\"chunk\\"]:")
   end

   return env, res
end

function utils.array_to_set(array)
   local set = {}

   for index, value in ipairs(array) do
      set[value] = index
   end

   return set
end

function utils.concat_arrays(array)
   local res = {}

   for _, subarray in ipairs(array) do
      for _, item in ipairs(subarray) do
         table.insert(res, item)
      end
   end

   return res
end

function utils.update(t1, t2)
   for k, v in pairs(t2) do
      t1[k] = v
   end

   return t1
end

local class_metatable = {}

function class_metatable.__call(class, ...)
   local obj = setmetatable({}, class)

   if class.__init then
      local init_returns = pack(class.__init(obj, ...))

      if init_returns.n > 0 then
         return unpack(init_returns, 1, init_returns.n)
      end
   end

   return obj
end

function utils.class()
   local class = setmetatable({}, class_metatable)
   class.__index = class
   return class
end

function utils.is_instance(object, class)
   return rawequal(debug.getmetatable(object), class)
end

utils.Stack = utils.class()

function utils.Stack:__init()
   self.size = 0
end

function utils.Stack:push(value)
   self.size = self.size + 1
   self[self.size] = value
   self.top = value
end

function utils.Stack:pop()
   local value = self[self.size]
   self[self.size] = nil
   self.size = self.size - 1
   self.top = self[self.size]
   return value
end

local ErrorWrapper = utils.class()

function ErrorWrapper:__init(err, traceback)
   self.err = err
   self.traceback = traceback
end

function ErrorWrapper:__tostring()
   return tostring(self.err) .. "\\n" .. self.traceback
end

local function error_handler(err)
   if utils.is_instance(err, ErrorWrapper) then
      return err
   else
      return ErrorWrapper(err, debug.traceback())
   end
end

-- Like pcall, but wraps errors in {err = err, traceback = traceback}
-- tables unless already wrapped.
function utils.try(f, ...)
   local args = {...}
   local num_args = select("#", ...)

   local function task()
      return f(unpack(args, 1, num_args))
   end

   return xpcall(task, error_handler)
end

local function ripairs_iterator(array, i)
   if i == 1 then
      return nil
   else
      i = i - 1
      return i, array[i]
   end
end

function utils.ripairs(array)
   return ripairs_iterator, array, #array + 1
end

function utils.sorted_pairs(t)
   local keys = {}

   for key in pairs(t) do
      table.insert(keys, key)
   end

   table.sort(keys)

   local index = 1

   return function()
      local key = keys[index]

      if key == nil then
         return
      end

      index = index + 1

      return key, t[key]
   end
end

function utils.unprefix(str, prefix)
   if str:sub(1, #prefix) == prefix then
      return str:sub(#prefix + 1)
   else
      return str
   end
end

function utils.after(str, pattern)
   local _, last_matched_index = str:find(pattern)

   if last_matched_index then
      return str:sub(last_matched_index + 1)
   end
end

function utils.strip(str)
   local _, last_start_space = str:find("^%s*")
   local first_end_space = str:find("%s*$")
   return str:sub(last_start_space + 1, first_end_space - 1)
end

-- \`sep\` must be nil or a single character. Behaves like python's \`str.split\`.
function utils.split(str, sep)
   local parts = {}
   local pattern

   if sep then
      pattern = sep .. "([^" .. sep .. "]*)"
      str = sep .. str
   else
      pattern = "%S+"
   end

   for part in str:gmatch(pattern) do
      table.insert(parts, part)
   end

   return parts
end

utils.InvalidPatternError = utils.class()

function utils.InvalidPatternError:__init(err, pattern)
   self.err = err
   self.pattern = pattern
end

function utils.InvalidPatternError:__tostring()
   return self.err
end

-- Behaves like string.match, except it normally returns boolean and
-- throws an instance of utils.InvalidPatternError on invalid pattern.
-- The error object turns into original error when tostring is used on it,
-- to ensure behaviour is predictable when luacheck is used as a module.
function utils.pmatch(str, pattern)
   assert(type(str) == "string")
   assert(type(pattern) == "string")

   local ok, res = pcall(string.match, str, pattern)

   if not ok then
      error(utils.InvalidPatternError(res, pattern), 0)
   else
      return not not res
   end
end

-- Maps func over array.
function utils.map(func, array)
   local res = {}

   for i, item in ipairs(array) do
      res[i] = func(item)
   end

   return res
end

-- Returns validator checking type.
function utils.has_type(type_)
   return function(x)
      if type(x) == type_ then
         return true
      else
         return false, ("%s expected, got %s"):format(type_, type(x))
      end
   end
end

-- Returns validator checking type and allowing false.
function utils.has_type_or_false(type_)
   return function(x)
      if type(x) == type_ then
         return true
      elseif type(x) == "boolean" then
         if x then
            return false, ("%s or false expected, got true"):format(type_)
         else
            return true
         end
      else
         return false, ("%s or false expected, got %s"):format(type_, type(x))
      end
   end
end

-- Returns validator checking two type possibilities.
function utils.has_either_type(type1, type2)
   return function(x)
      if type(x) == type1 or type(x) == type2 then
         return true
      else
         return false, ("%s or %s expected, got %s"):format(type1, type2, type(x))
      end
   end
end

-- Returns validator checking that value is an array with elements of type.
function utils.array_of(type_)
   return function(x)
      if type(x) ~= "table" then
         return false, ("array of %ss expected, got %s"):format(type_, type(x))
      end

      for index, item in ipairs(x) do
         if type(item) ~= type_ then
            return false, ("array of %ss expected, got %s at index [%d]"):format(type_, type(item), index)
         end
      end

      return true
   end
end

return utils

end)
__bundle_register("luacheck.format", function(require, _LOADED, __bundle_register, __bundle_modules)
local stages = require("luacheck.stages.init")
local utils = require("luacheck.utils")

local format = {}

local color_support = not utils.is_windows or os.getenv("ANSICON")

local function get_message_format(warning)
   local message_format = assert(stages.warnings[warning.code], "Unkown warning code " .. warning.code).message_format

   if type(message_format) == "function" then
      return message_format(warning)
   else
      return message_format
   end
end

local function plural(number)
   return (number == 1) and "" or "s"
end

local color_codes = {
   reset = 0,
   bright = 1,
   red = 31,
   green = 32
}

local function encode_color(c)
   return "\\27[" .. tostring(color_codes[c]) .. "m"
end

local function colorize(str, ...)
   str = str .. encode_color("reset")

   for _, color in ipairs({...}) do
      str = encode_color(color) .. str
   end

   return encode_color("reset") .. str
end

local function format_color(str, color, ...)
   return color and colorize(str, ...) or str
end

local function format_number(number, color)
   return format_color(tostring(number), color, "bright", (number > 0) and "red" or "reset")
end

-- Substitutes markers within string format with values from a table.
-- "{field_name}" marker is replaced with \`values.field_name\`.
-- "{field_name!}" marker adds highlight or quoting depending on color
-- option.
local function substitute(string_format, values, color)
   return (string_format:gsub("{([_a-zA-Z0-9]+)(!?)}", function(field_name, highlight)
      local value = tostring(assert(values[field_name], "No field " .. field_name))

      if highlight == "!" then
         if color then
            return colorize(value, "bright")
         else
            return "'" .. value .. "'"
         end
      else
         return value
      end
   end))
end

local function format_message(event, color)
   return substitute(get_message_format(event), event, color)
end

-- Returns formatted message for an issue, without color.
function format.get_message(event)
   return format_message(event)
end

local function capitalize(str)
   return str:gsub("^.", string.upper)
end

local function fatal_type(file_report)
   return capitalize(file_report.fatal) .. " error"
end

local function count_warnings_errors(events)
   local warnings, errors = 0, 0

   for _, event in ipairs(events) do
      if event.code:sub(1, 1) == "0" then
         errors = errors + 1
      else
         warnings = warnings + 1
      end
   end

   return warnings, errors
end

local function format_file_report_header(report, file_name, opts)
   local label = "Checking " .. file_name
   local status

   if report.fatal then
      status = format_color(fatal_type(report), opts.color, "bright")
   elseif #report == 0 then
      status = format_color("OK", opts.color, "bright", "green")
   else
      local warnings, errors = count_warnings_errors(report)

      if warnings > 0 then
         status = format_color(tostring(warnings).." warning"..plural(warnings), opts.color, "bright", "red")
      end

      if errors > 0 then
         status = status and (status.." / ") or ""
         status = status..(format_color(tostring(errors).." error"..plural(errors), opts.color, "bright"))
      end
   end

   return label .. (" "):rep(math.max(50 - #label, 1)) .. status
end

local function format_location(file, location, opts)
   local res = ("%s:%d:%d"):format(file, location.line, location.column)

   if opts.ranges then
      res = ("%s-%d"):format(res, location.end_column)
   end

   return res
end

local function event_code(event)
   return (event.code:sub(1, 1) == "0" and "E" or "W")..event.code
end

local function format_event(file_name, event, opts)
   local message = format_message(event, opts.color)

   if opts.codes then
      message = ("(%s) %s"):format(event_code(event), message)
   end

   return format_location(file_name, event, opts) .. ": " .. message
end

local function format_file_report(report, file_name, opts)
   local buf = {format_file_report_header(report, file_name, opts)}

   if #report > 0 then
      table.insert(buf, "")

      for _, event in ipairs(report) do
         table.insert(buf, "    " .. format_event(file_name, event, opts))
      end

      table.insert(buf, "")
   elseif report.fatal then
      table.insert(buf, "")
      table.insert(buf, "    " .. file_name .. ": " .. report.msg)
      table.insert(buf, "")
   end

   return table.concat(buf, "\\n")
end

local function escape_xml(str)
   str = str:gsub("&", "&amp;")
   str = str:gsub('"', "&quot;")
   str = str:gsub("'", "&apos;")
   str = str:gsub("<", "&lt;")
   str = str:gsub(">", "&gt;")
   return str
end

format.builtin_formatters = {}

function format.builtin_formatters.default(report, file_names, opts)
   local buf = {}

   if opts.quiet <= 2 then
      for i, file_report in ipairs(report) do
         if opts.quiet == 0 or file_report.fatal or #file_report > 0 then
            table.insert(buf, (opts.quiet == 2 and format_file_report_header or format_file_report) (
               file_report, file_names[i], opts))
         end
      end

      if #buf > 0 and buf[#buf]:sub(-1) ~= "\\n" then
         table.insert(buf, "")
      end
   end

   local total = ("Total: %s warning%s / %s error%s in %d file%s"):format(
      format_number(report.warnings, opts.color), plural(report.warnings),
      format_number(report.errors, opts.color), plural(report.errors),
      #report - report.fatals, plural(#report - report.fatals))

   if report.fatals > 0 then
      total = total..(", couldn't check %s file%s"):format(
         report.fatals, plural(report.fatals))
   end

   table.insert(buf, total)
   return table.concat(buf, "\\n")
end

function format.builtin_formatters.TAP(report, file_names, opts)
   opts.color = false
   local buf = {}

   for i, file_report in ipairs(report) do
      if file_report.fatal then
         table.insert(buf, ("not ok %d %s: %s"):format(#buf + 1, file_names[i], fatal_type(file_report)))
      elseif #file_report == 0 then
         table.insert(buf, ("ok %d %s"):format(#buf + 1, file_names[i]))
      else
         for _, warning in ipairs(file_report) do
            table.insert(buf, ("not ok %d %s"):format(#buf + 1, format_event(file_names[i], warning, opts)))
         end
      end
   end

   table.insert(buf, 1, "1.." .. tostring(#buf))
   return table.concat(buf, "\\n")
end

function format.builtin_formatters.JUnit(report, file_names)
   -- JUnit formatter doesn't support any options.
   local opts = {}
   local buf = {[[<?xml version="1.0" encoding="UTF-8"?>]]}
   local num_testcases = 0

   for _, file_report in ipairs(report) do
      if file_report.fatal or #file_report == 0 then
         num_testcases = num_testcases + 1
      else
         num_testcases = num_testcases + #file_report
      end
   end

   table.insert(buf, ([[<testsuite name="Luacheck report" tests="%d">]]):format(num_testcases))

   for file_i, file_report in ipairs(report) do
      if file_report.fatal then
         table.insert(buf, ([[    <testcase name="%s" classname="%s">]]):format(
            escape_xml(file_names[file_i]), escape_xml(file_names[file_i])))
         table.insert(buf, ([[        <error type="%s"/>]]):format(escape_xml(fatal_type(file_report))))
         table.insert(buf, [[    </testcase>]])
      elseif #file_report == 0 then
         table.insert(buf, ([[    <testcase name="%s" classname="%s"/>]]):format(
            escape_xml(file_names[file_i]), escape_xml(file_names[file_i])))
      else
         for event_i, event in ipairs(file_report) do
            table.insert(buf, ([[    <testcase name="%s:%d" classname="%s">]]):format(
               escape_xml(file_names[file_i]), event_i, escape_xml(file_names[file_i])))
            table.insert(buf, ([[        <failure type="%s" message="%s"/>]]):format(
               escape_xml(event_code(event)), escape_xml(format_event(file_names[file_i], event, opts))))
            table.insert(buf, [[    </testcase>]])
         end
      end
   end

   table.insert(buf, [[</testsuite>]])
   return table.concat(buf, "\\n")
end

local fatal_error_codes = {
   ["I/O"] = "F1",
   ["syntax"] = "F2",
   ["runtime"] = "F3"
}

function format.builtin_formatters.visual_studio(report, file_names)
   local buf = {}

   for i, file_report in ipairs(report) do
      if file_report.fatal then
         -- Older docs suggest that line number after a file name is optional; newer docs mark it as required.
         -- Just use tool name as origin and put file name into the message.
         table.insert(buf, ("luacheck : fatal error %s: couldn't check %s: %s"):format(
            fatal_error_codes[file_report.fatal], file_names[i], file_report.msg))
      else
         for _, event in ipairs(file_report) do
               -- Older documentation on the format suggests that it could support column range.
               -- Newer docs don't mention it. Don't use it for now.
               local event_type = event.code:sub(1, 1) == "0" and "error" or "warning"
               local message = format_message(event)
               table.insert(buf, ("%s(%d,%d) : %s %s: %s"):format(
                  file_names[i], event.line, event.column, event_type, event_code(event), message))
         end
      end
   end

   return table.concat(buf, "\\n")
end

function format.builtin_formatters.plain(report, file_names, opts)
   opts.color = false
   local buf = {}

   for i, file_report in ipairs(report) do
      if file_report.fatal then
         table.insert(buf, ("%s: %s (%s)"):format(file_names[i], fatal_type(file_report), file_report.msg))
      else
         for _, event in ipairs(file_report) do
            table.insert(buf, format_event(file_names[i], event, opts))
         end
      end
   end

   return table.concat(buf, "\\n")
end

--- Formats a report.
-- Recognized options:
--    \`options.formatter\`: name of used formatter. Default: "default".
--    \`options.quiet\`: integer in range 0-3. See CLI. Default: 0.
--    \`options.color\`: should use ansicolors? Default: true.
--    \`options.codes\`: should output warning codes? Default: false.
--    \`options.ranges\`: should output token end column? Default: false.
function format.format(report, file_names, options)
   return format.builtin_formatters[options.formatter or "default"](report, file_names, {
      quiet = options.quiet or 0,
      color = (options.color ~= false) and color_support,
      codes = options.codes,
      ranges = options.ranges
   })
end

return format

end)
__bundle_register("luacheck.stages.init", function(require, _LOADED, __bundle_register, __bundle_modules)
local utils = require("luacheck.utils")

local stages = {}

-- Checking is organized into stages run one after another.
-- Each stage is in its own module and provides \`run\` function operating on a check state,
-- and optionally \`warnings\` table mapping issue codes to tables with fields \`message_format\`
-- containing format string for the issue or a function returning it given the issue,
-- and \`fields\` containing array of extra fields this warning can have.

stages.modules = {}

table.insert(stages.modules, require("luacheck.stages.parse"))
table.insert(stages.modules, require("luacheck.stages.unwrap_parens"))
table.insert(stages.modules, require("luacheck.stages.linearize"))
table.insert(stages.modules, require("luacheck.stages.parse_inline_options"))
table.insert(stages.modules, require("luacheck.stages.name_functions"))
table.insert(stages.modules, require("luacheck.stages.resolve_locals"))
table.insert(stages.modules, require("luacheck.stages.detect_bad_whitespace"))
table.insert(stages.modules, require("luacheck.stages.detect_cyclomatic_complexity"))
table.insert(stages.modules, require("luacheck.stages.detect_empty_blocks"))
table.insert(stages.modules, require("luacheck.stages.detect_empty_statements"))
table.insert(stages.modules, require("luacheck.stages.detect_globals"))
table.insert(stages.modules, require("luacheck.stages.detect_reversed_fornum_loops"))
table.insert(stages.modules, require("luacheck.stages.detect_unbalanced_assignments"))
table.insert(stages.modules, require("luacheck.stages.detect_uninit_accesses"))
table.insert(stages.modules, require("luacheck.stages.detect_unreachable_code"))
table.insert(stages.modules, require("luacheck.stages.detect_unused_fields"))
table.insert(stages.modules, require("luacheck.stages.detect_unused_locals"))

stages.warnings = {}

local base_fields = {"code", "line", "column", "end_column"}

local function register_warnings(warnings)
   for code, warning in pairs(warnings) do
      assert(not stages.warnings[code])
      assert(warning.message_format)
      assert(warning.fields)

      local full_fields = utils.concat_arrays({base_fields, warning.fields})

      stages.warnings[code] = {
         message_format = warning.message_format,
         fields = full_fields,
         fields_set = utils.array_to_set(full_fields)
      }
   end
end

-- Issues that do not originate from normal check stages (excluding global related ones).
register_warnings({
   ["011"] = {message_format = "{msg}", fields = {"msg", "prev_line", "prev_column", "prev_end_column"}},
   ["631"] = {message_format = "line is too long ({end_column} > {max_length})", fields = {}}
})

for _, stage_module in ipairs(stages.modules) do
   if stage_module.warnings then
      register_warnings(stage_module.warnings)
   end
end

function stages.run(chstate)
   for _, stage_module in ipairs(stages.modules) do
      stage_module.run(chstate)
   end
end

return stages

end)
__bundle_register("luacheck.stages.detect_unused_locals", function(require, _LOADED, __bundle_register, __bundle_modules)
local utils = require("luacheck.utils")

local stage = {}

local function unused_local_message_format(warning)
   if warning.func then
      if warning.recursive then
         return "unused recursive function {name!}"
      elseif warning.mutually_recursive then
         return "unused mutually recursive function {name!}"
      else
         return "unused function {name!}"
      end
   else
      return "unused variable {name!}"
   end
end

local function unused_arg_message_format(warning)
   if warning.name == "..." then
      return "unused variable length argument"
   else
      return "unused argument {name!}"
   end
end

local function unused_or_overwritten_warning(message_format)
   return {
      message_format = function(warning)
         if warning.overwritten_line then
            return message_format .. " is overwritten on line {overwritten_line} before use"
         else
            return message_format .. " is unused"
         end
      end,
      fields = {"name", "secondary", "overwritten_line", "overwritten_column", "overwritten_end_column"}
   }
end

stage.warnings = {
   ["211"] = {message_format = unused_local_message_format,
      fields = {"name", "func", "secondary", "useless", "recursive", "mutually_recursive"}},
   ["212"] = {message_format = unused_arg_message_format, fields = {"name", "self"}},
   ["213"] = {message_format = "unused loop variable {name!}", fields = {"name"}},
   ["221"] = {message_format = "variable {name!} is never set", fields = {"name", "secondary"}},
   ["231"] = {message_format = "variable {name!} is never accessed", fields = {"name", "secondary"}},
   ["232"] = {message_format = "argument {name!} is never accessed", fields = {"name"}},
   ["233"] = {message_format = "loop variable {name!} is never accessed", fields = {"name"}},
   ["241"] = {message_format = "variable {name!} is mutated but never accessed", fields = {"name", "secondary"}},
   ["311"] = unused_or_overwritten_warning("value assigned to variable {name!}"),
   ["312"] = unused_or_overwritten_warning("value of argument {name!}"),
   ["313"] = unused_or_overwritten_warning("value of loop variable {name!}"),
   ["331"] = {message_format = "value assigned to variable {name!} is mutated but never accessed",
      fields = {"name", "secondary"}}
}

local function is_secondary(value)
   return value.secondaries and value.secondaries.used
end

local type_codes = {
   var = "1",
   func = "1",
   arg = "2",
   loop = "3",
   loopi = "3"
}

local function warn_unused_var(chstate, value, is_useless)
   chstate:warn_value("21" .. type_codes[value.var.type], value, {
      secondary = is_secondary(value) or nil,
      func = value.type == "func" or nil,
      self = value.var.self,
      useless = value.var.name == "_" and is_useless or nil
   })
end

local function warn_unaccessed_var(chstate, var, is_mutated)
   -- Mark as secondary if all assigned values are secondary.
   -- It is guaranteed that there are at least two values.
   local secondary = true

   for _, value in ipairs(var.values) do
      if not value.empty and not is_secondary(value) then
         secondary = nil
         break
      end
   end

   chstate:warn_var("2" .. (is_mutated and "4" or "3") .. type_codes[var.type], var, {
      secondary = secondary
   })
end

local function warn_unused_value(chstate, value, overwriting_node)
   local warning = chstate:warn_value("3" .. (value.mutated and "3" or "1") .. type_codes[value.type], value, {
      secondary = is_secondary(value) or nil
   })

   if overwriting_node then
      warning.overwritten_line = overwriting_node.line
      warning.overwritten_column = chstate:offset_to_column(overwriting_node.line, overwriting_node.offset)
      warning.overwritten_end_column = chstate:offset_to_column(overwriting_node.line, overwriting_node.end_offset)
   end
end

-- Returns \`true\` if a variable should be reported as a function instead of simply local,
-- \`false\` otherwise.
-- A variable is considered a function if it has a single assignment and the value is a function,
-- or if there is a forward declaration with a function assignment later.
local function is_function_var(var)
   return (#var.values == 1 and var.values[1].type == "func") or (
      #var.values == 2 and var.values[1].empty and var.values[2].type == "func")
end

local externally_accessible_tags = utils.array_to_set({"Id", "Index", "Call", "Invoke", "Op", "Paren", "Dots"})

local function is_externally_accessible(value)
   return value.type ~= "var" or (value.node and externally_accessible_tags[value.node.tag])
end

local function get_overwriting_lhs_node(item, value)
   for _, node in ipairs(item.lhs) do
      if node.var == value.var then
         return node
      end
   end
end

local function get_second_overwriting_lhs_node(item, value)
   local after_value_node

   for _, node in ipairs(item.lhs) do
      if node.var == value.var then
         if after_value_node then
            return node
         elseif node == value.var_node then
            after_value_node = true
         end
      end
   end
end

local function detect_unused_local(chstate, var)
   if is_function_var(var) then
      local value = var.values[2] or var.values[1]

      if not value.used then
         warn_unused_var(chstate, value)
      end
   elseif #var.values == 1 then
      local value = var.values[1]

      if not value.used then
         if value.mutated then
            if not is_externally_accessible(value) then
               warn_unaccessed_var(chstate, var, true)
            end
         else
            warn_unused_var(chstate, value, value.empty)
         end
      elseif value.empty then
         chstate:warn_var("221", var)
      end
   elseif not var.accessed and not var.mutated then
      warn_unaccessed_var(chstate, var)
   else
      local no_values_externally_accessible = true

      for _, value in ipairs(var.values) do
         if is_externally_accessible(value) then
            no_values_externally_accessible = false
         end
      end

      if not var.accessed and no_values_externally_accessible then
         warn_unaccessed_var(chstate, var, true)
      end

      for _, value in ipairs(var.values) do
         if not value.empty then
            if not value.used then
               if not value.mutated then
                  local overwriting_node

                  if value.overwriting_item then
                     if value.overwriting_item ~= value.item then
                        overwriting_node = get_overwriting_lhs_node(value.overwriting_item, value)
                     end
                  else
                     overwriting_node = get_second_overwriting_lhs_node(value.item, value)
                  end

                  warn_unused_value(chstate, value, overwriting_node)
               elseif not is_externally_accessible(value) then
                  if var.accessed or not no_values_externally_accessible then
                     warn_unused_value(chstate, value)
                  end
               end
            end
         end
      end
   end
end

local function detect_unused_locals_in_line(chstate, line)
   for _, item in ipairs(line.items) do
      if item.tag == "Local" then
         for var in pairs(item.set_variables) do
            -- Do not check the implicit top level vararg.
            if var.node.line then
               detect_unused_local(chstate, var)
            end
         end
      end
   end
end

local function detect_unused_locals(chstate)
   for _, line in ipairs(chstate.lines) do
      detect_unused_locals_in_line(chstate, line)
   end
end

local function mark_reachable_lines(edges, marked, line)
   for connected_line in pairs(edges[line]) do
      if not marked[connected_line] then
         marked[connected_line] = true
         mark_reachable_lines(edges, marked, connected_line)
      end
   end
end

local function detect_unused_rec_funcs(chstate)
   -- Build a graph of usage relations of all closures.
   -- Closure A is used by closure B iff either B is parent
   -- of A and A is not assigned to a local/upvalue, or
   -- B uses local/upvalue value that is A.
   -- Closures not reachable from root closure are unused,
   -- report corresponding values/variables if not done already.

   local line = chstate.top_line

   -- Initialize edges maps.
   local forward_edges = {[line] = {}}
   local backward_edges = {[line] = {}}

   for _, nested_line in ipairs(line.lines) do
      forward_edges[nested_line] = {}
      backward_edges[nested_line] = {}
   end

   -- Add edges leading to each nested line.
   for _, nested_line in ipairs(line.lines) do
      if nested_line.node.value then
         for using_line in pairs(nested_line.node.value.using_lines) do
            forward_edges[using_line][nested_line] = true
            backward_edges[nested_line][using_line] = true
         end
      elseif nested_line.parent then
         forward_edges[nested_line.parent][nested_line] = true
         backward_edges[nested_line][nested_line.parent] = true
      end
   end

   -- Recursively mark all closures reachable from root closure and unused closures.
   -- Closures reachable from main chunk are used; closure reachable from unused closures
   -- depend on that closure; that is, fixing warning about parent unused closure
   -- fixes warning about the child one, so issuing a warning for the child is superfluous.
   local marked = {[line] = true}
   mark_reachable_lines(forward_edges, marked, line)

   for _, nested_line in ipairs(line.lines) do
      if nested_line.node.value and not nested_line.node.value.used then
         marked[nested_line] = true
         mark_reachable_lines(forward_edges, marked, nested_line)
      end
   end

   -- Deal with unused closures.
   for _, nested_line in ipairs(line.lines) do
      local value = nested_line.node.value

      if value and value.used and not marked[nested_line] then
         -- This closure is used by some closure, but is not marked as reachable
         -- from main chunk or any of reported closures.
         -- Find candidate group of mutually recursive functions containing this one:
         -- mark sets of closures reachable from it by forward and backward edges,
         -- intersect them. Ignore already marked closures in the process to avoid
         -- issuing superfluous, dependent warnings.
         local forward_marked = setmetatable({}, {__index = marked})
         local backward_marked = setmetatable({}, {__index = marked})
         mark_reachable_lines(forward_edges, forward_marked, nested_line)
         mark_reachable_lines(backward_edges, backward_marked, nested_line)

         -- Iterate over closures in the group.
         for mut_rec_line in pairs(forward_marked) do
            if rawget(backward_marked, mut_rec_line) then
               marked[mut_rec_line] = true
               value = mut_rec_line.node.value

               if value then
                  -- Report this closure as self recursive or mutually recursive.
                  local is_self_recursive = forward_edges[mut_rec_line][mut_rec_line]

                  if is_function_var(value.var) then
                     chstate:warn_value("211", value, {
                        func = true,
                        mutually_recursive = not is_self_recursive or nil,
                        recursive = is_self_recursive or nil
                     })
                  else
                     chstate:warn_value("311", value)
                  end
               end
            end
         end
      end
   end
end

-- Warns about unused local variables and their values as well as locals that
-- are accessed but never set or set but never accessed.
-- Warns about unused recursive functions.
function stage.run(chstate)
   detect_unused_locals(chstate)
   detect_unused_rec_funcs(chstate)
end

return stage

end)
__bundle_register("luacheck.stages.detect_unused_fields", function(require, _LOADED, __bundle_register, __bundle_modules)
local core_utils = require("luacheck.core_utils")

local stage = {}

local function unused_field_value_message_format(warning)
   local target = warning.index and "index" or "field"
   return "value assigned to " .. target .. " {field!} is overwritten on line {overwritten_line} before use"
end

stage.warnings = {
   ["314"] = {message_format = unused_field_value_message_format,
      fields = {"field", "index", "overwritten_line","overwritten_column", "overwritten_end_column"}}
}

local function warn_unused_field_value(chstate, node, field_repr, is_index, overwriting_node)
   chstate:warn_range("314", node, {
      field = field_repr,
      index = is_index,
      overwritten_line = overwriting_node.line,
      overwritten_column = chstate:offset_to_column(overwriting_node.line, overwriting_node.offset),
      overwritten_end_column = chstate:offset_to_column(overwriting_node.line, overwriting_node.end_offset)
   })
end

local function check_table(chstate, node)
   local array_index = 1.0
   local key_value_to_node = {}
   local key_node_to_repr = {}
   local index_key_nodes = {}

   for _, pair in ipairs(node) do
      local key_value
      local key_repr
      local key_node

      if pair.tag == "Pair" then
         key_node = pair[1]
         key_value, key_repr = core_utils.eval_const_node(key_node)
      else
         key_node = pair
         key_value = array_index
         key_repr = tostring(math.floor(key_value))
         array_index = array_index + 1.0
      end

      if key_value then
         local prev_key_node = key_value_to_node[key_value]
         local prev_key_repr = key_node_to_repr[prev_key_node]
         local prev_key_is_index = index_key_nodes[prev_key_node]

         if prev_key_node then
            warn_unused_field_value(chstate, prev_key_node, prev_key_repr, prev_key_is_index, key_node)
         end

         key_value_to_node[key_value] = key_node
         key_node_to_repr[key_node] = key_repr

         if pair.tag ~= "Pair" then
            index_key_nodes[key_node] = true
         end
      end
   end
end

local function check_nodes(chstate, nodes)
   for _, node in ipairs(nodes) do
      if type(node) == "table" then
         if node.tag == "Table" then
            check_table(chstate, node)
         end

         check_nodes(chstate, node)
      end
   end
end

function stage.run(chstate)
   check_nodes(chstate, chstate.ast)
end

return stage

end)
__bundle_register("luacheck.core_utils", function(require, _LOADED, __bundle_register, __bundle_modules)
local decoder = require("luacheck.decoder")
local utils = require("luacheck.utils")

local core_utils = {}

-- Attempts to evaluate a node as a Lua value, without resolving locals.
-- Returns Lua value and its string representation on success, nothing on failure.
function core_utils.eval_const_node(node)
   if node.tag == "True" then
      return true, "true"
   elseif node.tag == "False" then
      return false, "false"
   elseif node.tag == "String" then
      local chars = decoder.decode(node[1])
      return node[1], chars:get_printable_substring(1, chars:get_length())
   else
      local is_negative

      if node.tag == "Op" and node[1] == "unm" then
         is_negative = true
         node = node[2]
      end

      if node.tag ~= "Number" then
         return
      end

      local str = node[1]

      if str:find("[iIuUlL]") then
         -- Ignore LuaJIT cdata literals.
         return
      end

      -- On Lua 5.3 convert to float to get same results as on Lua 5.1 and 5.2.
      if _VERSION == "Lua 5.3" and not str:find("[%.eEpP]") then
         str = str .. ".0"
      end

      local number = tonumber(str)

      if not number then
         return
      end

      if is_negative then
         number = -number
      end

      if number == number and number < 1/0 and number > -1/0 then
         return number, (is_negative and "-" or "") .. node[1]
      end
   end
end

local statement_containing_tags = utils.array_to_set({"Do", "While", "Repeat", "Fornum", "Forin", "If"})

-- \`items\` is an array of nodes or nested item arrays.
local function scan_for_statements(chstate, items, tags, callback, ...)
   for _, item in ipairs(items) do
      if tags[item.tag] then
         callback(chstate, item, ...)
      end

      if not item.tag or statement_containing_tags[item.tag] then
         scan_for_statements(chstate, item, tags, callback, ...)
      end
   end
end

-- Calls \`callback(chstate, node, ...)\` for each statement node within AST with tag in given array.
function core_utils.each_statement(chstate, tags_array, callback, ...)
   local tags = utils.array_to_set(tags_array)

   for _, line in ipairs(chstate.lines) do
      scan_for_statements(chstate, line.node[2], tags, callback, ...)
   end
end

local function location_comparator(warning1, warning2)
   if warning1.line ~= warning2.line then
      return warning1.line < warning2.line
   elseif warning1.column ~= warning2.column then
      return warning1.column < warning2.column
   else
      return warning1.code < warning2.code
   end
end

-- Sorts an array of warnings by location information as provided in \`line\` and \`column\` fields.
function core_utils.sort_by_location(warnings)
   table.sort(warnings, location_comparator)
end

return core_utils

end)
__bundle_register("luacheck.decoder", function(require, _LOADED, __bundle_register, __bundle_modules)
local unicode = require("luacheck.unicode")
local utils = require("luacheck.utils")

local decoder = {}

local sbyte = string.byte
local sfind = string.find
local sgsub = string.gsub
local ssub = string.sub

-- \`LatinChars\` and \`UnicodeChars\` objects represent source strings
-- and provide Unicode-aware access to them with a common interface.
-- Source bytes should not be accessed directly.
-- Provided methods are:
-- \`Chars:get_codepoint(index)\`: returns codepoint at given index as integer or nil if index is out of range.
-- \`Chars:get_substring(from, to)\`: returns substring of original bytes corresponding to characters from \`from\` to \`to\`.
-- \`Chars:get_printable_substring(from. to)\`: like get_substring but escapes not printable characters.
-- \`Chars:get_length()\`: returns total number of characters.
-- \`Chars:find(pattern, from)\`: \`string.find\` but \`from\` is in characters. Return values are still in bytes.

-- \`LatinChars\` is an optimized special case for latin1 strings.
local LatinChars = utils.class()

function LatinChars:__init(bytes)
   self._bytes = bytes
end

function LatinChars:get_codepoint(index)
   return sbyte(self._bytes, index)
end

function LatinChars:get_substring(from, to)
   return ssub(self._bytes, from, to)
end

local function hexadecimal_escaper(byte)
   return ("\\\\x%02X"):format(sbyte(byte))
end

function LatinChars:get_printable_substring(from, to)
   return (sgsub(ssub(self._bytes, from, to), "[^\\32-\\126]", hexadecimal_escaper))
end

function LatinChars:get_length()
   return #self._bytes
end

function LatinChars:find(pattern, from)
   return sfind(self._bytes, pattern, from)
end

-- Decodes \`bytes\` as UTF8. Returns arrays of codepoints as integers and their byte offsets.
-- Byte offsets have one extra item pointing to one byte past the end of \`bytes\`.
-- On decoding error returns nothing.
local function get_codepoints_and_byte_offsets(bytes)
   local codepoints = {}
   local byte_offsets = {}

   local byte_index = 1
   local codepoint_index = 1

   while true do
      byte_offsets[codepoint_index] = byte_index

      -- Attempt to decode the next codepoint from UTF8.
      local codepoint = sbyte(bytes, byte_index)

      if not codepoint then
         return codepoints, byte_offsets
      end

      byte_index = byte_index + 1

      if codepoint >= 0x80 then
         -- Not ASCII.

         if codepoint < 0xC0 then
            return
         end

         local cont = (sbyte(bytes, byte_index) or 0) - 0x80

         if cont < 0 or cont >= 0x40 then
            return
         end

         byte_index = byte_index + 1

         if codepoint < 0xE0 then
            -- Two bytes.
            codepoint = cont + (codepoint - 0xC0) * 0x40
         elseif codepoint < 0xF0 then
            -- Three bytes.
            codepoint = cont + (codepoint - 0xE0) * 0x40

            cont = (sbyte(bytes, byte_index) or 0) - 0x80

            if cont < 0 or cont >= 0x40 then
               return
            end

            byte_index = byte_index + 1

            codepoint = cont + codepoint * 0x40
         elseif codepoint < 0xF8 then
            -- Four bytes.
            codepoint = cont + (codepoint - 0xF0) * 0x40

            cont = (sbyte(bytes, byte_index) or 0) - 0x80

            if cont < 0 or cont >= 0x40 then
               return
            end

            byte_index = byte_index + 1

            codepoint = cont + codepoint * 0x40

            cont = (sbyte(bytes, byte_index) or 0) - 0x80

            if cont < 0 or cont >= 0x40 then
               return
            end

            byte_index = byte_index + 1

            codepoint = cont + codepoint * 0x40

            if codepoint > 0x10FFFF then
               return
            end
         else
            return
         end
      end

      codepoints[codepoint_index] = codepoint
      codepoint_index = codepoint_index + 1
   end
end

-- \`UnicodeChars\` is the general case for non-latin1 strings.
-- Assumes UTF8, on decoding error falls back to latin1.
local UnicodeChars = utils.class()

function UnicodeChars:__init(bytes, codepoints, byte_offsets)
   self._bytes = bytes
   self._codepoints = codepoints
   self._byte_offsets = byte_offsets
end

function UnicodeChars:get_codepoint(index)
   return self._codepoints[index]
end

function UnicodeChars:get_substring(from, to)
   local byte_offsets = self._byte_offsets
   return ssub(self._bytes, byte_offsets[from], byte_offsets[to + 1] - 1)
end

function UnicodeChars:get_printable_substring(from, to)
   -- This is only called on syntax error, it's okay to be slow.
   local parts = {}

   for index = from, to do
      local codepoint = self._codepoints[index]

      if unicode.is_printable(codepoint) then
         table.insert(parts, self:get_substring(index, index))
      else
         table.insert(parts, (codepoint > 255 and "\\\\u{%X}" or "\\\\x%02X"):format(codepoint))
      end
   end

   return table.concat(parts)
end

function UnicodeChars:get_length()
   return #self._codepoints
end

function UnicodeChars:find(pattern, from)
   return sfind(self._bytes, pattern, self._byte_offsets[from])
end

function decoder.decode(bytes)
   -- Only use UnicodeChars if necessary. LatinChars isn't much faster but noticeably more memory efficient.
   if sfind(bytes, "[\\128-\\255]") then
      local codepoints, byte_offsets = get_codepoints_and_byte_offsets(bytes)

      if codepoints then
         return UnicodeChars(bytes, codepoints, byte_offsets)
      end
   end

   return LatinChars(bytes)
end

return decoder

end)
__bundle_register("luacheck.unicode", function(require, _LOADED, __bundle_register, __bundle_modules)
local unicode_printability_boundaries = require("luacheck.unicode_printability_boundaries")

local unicode = {}

-- unicode_printability_boundaries is an array of first codepoints of
-- each continuous block of codepoints that are all printable or all not printable.

function unicode.is_printable(codepoint)
   -- Binary search for index of the first boundary less than or equal to given codepoint.
   local floor_boundary_index

   -- Target index is always in [begin_index..end_index).
   local begin_index = 1
   local end_index = #unicode_printability_boundaries + 1

   while end_index - begin_index > 1 do
      local mid_index = math.floor((begin_index + end_index) / 2)
      local mid_codepoint = unicode_printability_boundaries[mid_index]

      if codepoint < mid_codepoint then
         end_index = mid_index
      elseif codepoint > mid_codepoint then
         begin_index = mid_index
      else
         floor_boundary_index = mid_index
         break
      end
   end

   floor_boundary_index = floor_boundary_index or begin_index
   -- floor_boundary_index is the number of the block containing codepoint.
   -- Printable and not printable blocks alternate and the first one is not printable (zero is not printable).
   return floor_boundary_index % 2 == 0
end

return unicode

end)
__bundle_register("luacheck.unicode_printability_boundaries", function(require, _LOADED, __bundle_register, __bundle_modules)
-- Autogenerated using data from https://www.unicode.org/Public/11.0.0/ucd/UnicodeData.txt
return {0,32,127,160,173,174,888,890,896,900,907,908,909,910,930,931,1328,1329,1367,1369,1419,1421,1424,1425,1480,1488,1515,1519,1525,1542,1564,1566,1757,1758,1806,1808,1867,1869,1970,1984,2043,2045,2094,2096,2111,2112,2140,2142,2143,2144,2155,2208,2229,2230,2238,2259,2274,2275,2436,2437,2445,2447,2449,2451,2473,2474,2481,2482,2483,2486,2490,2492,2501,2503,2505,2507,2511,2519,2520,2524,2526,2527,2532,2534,2559,2561,2564,2565,2571,2575,2577,2579,2601,2602,2609,2610,2612,2613,2615,2616,2618,2620,2621,2622,2627,2631,2633,2635,2638,2641,2642,2649,2653,2654,2655,2662,2679,2689,2692,2693,2702,2703,2706,2707,2729,2730,2737,2738,2740,2741,2746,2748,2758,2759,2762,2763,2766,2768,2769,2784,2788,2790,2802,2809,2816,2817,2820,2821,2829,2831,2833,2835,2857,2858,2865,2866,2868,2869,2874,2876,2885,2887,2889,2891,2894,2902,2904,2908,2910,2911,2916,2918,2936,2946,2948,2949,2955,2958,2961,2962,2966,2969,2971,2972,2973,2974,2976,2979,2981,2984,2987,2990,3002,3006,3011,3014,3017,3018,3022,3024,3025,3031,3032,3046,3067,3072,3085,3086,3089,3090,3113,3114,3130,3133,3141,3142,3145,3146,3150,3157,3159,3160,3163,3168,3172,3174,3184,3192,3213,3214,3217,3218,3241,3242,3252,3253,3258,3260,3269,3270,3273,3274,3278,3285,3287,3294,3295,3296,3300,3302,3312,3313,3315,3328,3332,3333,3341,3342,3345,3346,3397,3398,3401,3402,3408,3412,3428,3430,3456,3458,3460,3461,3479,3482,3506,3507,3516,3517,3518,3520,3527,3530,3531,3535,3541,3542,3543,3544,3552,3558,3568,3570,3573,3585,3643,3647,3676,3713,3715,3716,3717,3719,3721,3722,3723,3725,3726,3732,3736,3737,3744,3745,3748,3749,3750,3751,3752,3754,3756,3757,3770,3771,3774,3776,3781,3782,3783,3784,3790,3792,3802,3804,3808,3840,3912,3913,3949,3953,3992,3993,4029,4030,4045,4046,4059,4096,4294,4295,4296,4301,4302,4304,4681,4682,4686,4688,4695,4696,4697,4698,4702,4704,4745,4746,4750,4752,4785,4786,4790,4792,4799,4800,4801,4802,4806,4808,4823,4824,4881,4882,4886,4888,4955,4957,4989,4992,5018,5024,5110,5112,5118,5120,5789,5792,5881,5888,5901,5902,5909,5920,5943,5952,5972,5984,5997,5998,6001,6002,6004,6016,6110,6112,6122,6128,6138,6144,6158,6160,6170,6176,6265,6272,6315,6320,6390,6400,6431,6432,6444,6448,6460,6464,6465,6468,6510,6512,6517,6528,6572,6576,6602,6608,6619,6622,6684,6686,6751,6752,6781,6783,6794,6800,6810,6816,6830,6832,6847,6912,6988,6992,7037,7040,7156,7164,7224,7227,7242,7245,7305,7312,7355,7357,7368,7376,7418,7424,7674,7675,7958,7960,7966,7968,8006,8008,8014,8016,8024,8025,8026,8027,8028,8029,8030,8031,8062,8064,8117,8118,8133,8134,8148,8150,8156,8157,8176,8178,8181,8182,8191,8192,8203,8208,8232,8239,8288,8304,8306,8308,8335,8336,8349,8352,8384,8400,8433,8448,8588,8592,9255,9280,9291,9312,11124,11126,11158,11160,11209,11210,11263,11264,11311,11312,11359,11360,11508,11513,11558,11559,11560,11565,11566,11568,11624,11631,11633,11647,11671,11680,11687,11688,11695,11696,11703,11704,11711,11712,11719,11720,11727,11728,11735,11736,11743,11744,11855,11904,11930,11931,12020,12032,12246,12272,12284,12288,12352,12353,12439,12441,12544,12549,12592,12593,12687,12688,12731,12736,12772,12784,12831,12832,13055,13056,19894,19904,40944,40960,42125,42128,42183,42192,42540,42560,42744,42752,42938,42999,43052,43056,43066,43072,43128,43136,43206,43214,43226,43232,43348,43359,43389,43392,43470,43471,43482,43486,43519,43520,43575,43584,43598,43600,43610,43612,43715,43739,43767,43777,43783,43785,43791,43793,43799,43808,43815,43816,43823,43824,43878,43888,44014,44016,44026,44032,55204,55216,55239,55243,55292,63744,64110,64112,64218,64256,64263,64275,64280,64285,64311,64312,64317,64318,64319,64320,64322,64323,64325,64326,64450,64467,64832,64848,64912,64914,64968,65008,65022,65024,65050,65056,65107,65108,65127,65128,65132,65136,65141,65142,65277,65281,65471,65474,65480,65482,65488,65490,65496,65498,65501,65504,65511,65512,65519,65532,65534,65536,65548,65549,65575,65576,65595,65596,65598,65599,65614,65616,65630,65664,65787,65792,65795,65799,65844,65847,65935,65936,65948,65952,65953,66000,66046,66176,66205,66208,66257,66272,66300,66304,66340,66349,66379,66384,66427,66432,66462,66463,66500,66504,66518,66560,66718,66720,66730,66736,66772,66776,66812,66816,66856,66864,66916,66927,66928,67072,67383,67392,67414,67424,67432,67584,67590,67592,67593,67594,67638,67639,67641,67644,67645,67647,67670,67671,67743,67751,67760,67808,67827,67828,67830,67835,67868,67871,67898,67903,67904,67968,68024,68028,68048,68050,68100,68101,68103,68108,68116,68117,68120,68121,68150,68152,68155,68159,68169,68176,68185,68192,68256,68288,68327,68331,68343,68352,68406,68409,68438,68440,68467,68472,68498,68505,68509,68521,68528,68608,68681,68736,68787,68800,68851,68858,68904,68912,68922,69216,69247,69376,69416,69424,69466,69632,69710,69714,69744,69759,69821,69822,69826,69840,69865,69872,69882,69888,69941,69942,69959,69968,70007,70016,70094,70096,70112,70113,70133,70144,70162,70163,70207,70272,70279,70280,70281,70282,70286,70287,70302,70303,70314,70320,70379,70384,70394,70400,70404,70405,70413,70415,70417,70419,70441,70442,70449,70450,70452,70453,70458,70459,70469,70471,70473,70475,70478,70480,70481,70487,70488,70493,70500,70502,70509,70512,70517,70656,70746,70747,70748,70749,70751,70784,70856,70864,70874,71040,71094,71096,71134,71168,71237,71248,71258,71264,71277,71296,71352,71360,71370,71424,71451,71453,71468,71472,71488,71680,71740,71840,71923,71935,71936,72192,72264,72272,72324,72326,72355,72384,72441,72704,72713,72714,72759,72760,72774,72784,72813,72816,72848,72850,72872,72873,72887,72960,72967,72968,72970,72971,73015,73018,73019,73020,73022,73023,73032,73040,73050,73056,73062,73063,73065,73066,73103,73104,73106,73107,73113,73120,73130,73440,73465,73728,74650,74752,74863,74864,74869,74880,75076,77824,78895,82944,83527,92160,92729,92736,92767,92768,92778,92782,92784,92880,92910,92912,92918,92928,92998,93008,93018,93019,93026,93027,93048,93053,93072,93760,93851,93952,94021,94032,94079,94095,94112,94176,94178,94208,100338,100352,101107,110592,110879,110960,111356,113664,113771,113776,113789,113792,113801,113808,113818,113820,113824,118784,119030,119040,119079,119081,119155,119163,119273,119296,119366,119520,119540,119552,119639,119648,119673,119808,119893,119894,119965,119966,119968,119970,119971,119973,119975,119977,119981,119982,119994,119995,119996,119997,120004,120005,120070,120071,120075,120077,120085,120086,120093,120094,120122,120123,120127,120128,120133,120134,120135,120138,120145,120146,120486,120488,120780,120782,121484,121499,121504,121505,121520,122880,122887,122888,122905,122907,122914,122915,122917,122918,122923,124928,125125,125127,125143,125184,125259,125264,125274,125278,125280,126065,126133,126464,126468,126469,126496,126497,126499,126500,126501,126503,126504,126505,126515,126516,126520,126521,126522,126523,126524,126530,126531,126535,126536,126537,126538,126539,126540,126541,126544,126545,126547,126548,126549,126551,126552,126553,126554,126555,126556,126557,126558,126559,126560,126561,126563,126564,126565,126567,126571,126572,126579,126580,126584,126585,126589,126590,126591,126592,126602,126603,126620,126625,126628,126629,126634,126635,126652,126704,126706,126976,127020,127024,127124,127136,127151,127153,127168,127169,127184,127185,127222,127232,127245,127248,127340,127344,127405,127462,127491,127504,127548,127552,127561,127568,127570,127584,127590,127744,128725,128736,128749,128752,128762,128768,128884,128896,128985,129024,129036,129040,129096,129104,129114,129120,129160,129168,129198,129280,129292,129296,129343,129344,129393,129395,129399,129402,129403,129404,129443,129456,129466,129472,129475,129488,129536,129632,129646,131072,173783,173824,177973,177984,178206,178208,183970,183984,191457,194560,195102,917760,918000,}

end)
__bundle_register("luacheck.stages.detect_unreachable_code", function(require, _LOADED, __bundle_register, __bundle_modules)
local stage = {}

stage.warnings = {
   ["511"] = {message_format = "unreachable code", fields = {}},
   ["512"] = {message_format = "loop is executed at most once", fields = {}}
}

local function noop_callback() end

local function detect_unreachable_code(chstate, line)
   local reachable_indexes = {}

   -- Mark all items reachable from the function start.
   line:walk(reachable_indexes, 1, noop_callback)

   -- All remaining items are unreachable.
   -- However, there is no point in reporting all of them.
   -- Only report those that are not reachable from any already reported ones.
   for item_index, item in ipairs(line.items) do
      if not reachable_indexes[item_index] then
         if item.node then
            chstate:warn_range(item.loop_end and "512" or "511", item.node)
            -- Mark all items reachable from the item just reported.
            line:walk(reachable_indexes, item_index, noop_callback)
         end
      end
   end
end

function stage.run(chstate)
   for _, line in ipairs(chstate.lines) do
      detect_unreachable_code(chstate, line)
   end
end

return stage

end)
__bundle_register("luacheck.stages.detect_uninit_accesses", function(require, _LOADED, __bundle_register, __bundle_modules)
local stage = {}

stage.warnings = {
   ["321"] = {message_format = "accessing uninitialized variable {name!}", fields = {"name"}},
   ["341"] = {message_format = "mutating uninitialized variable {name!}", fields = {"name"}}
}

local function detect_uninit_access_in_line(chstate, line)
   for _, item in ipairs(line.items) do
      for _, action_key in ipairs({"accesses", "mutations"}) do
         local code = action_key == "accesses" and "321" or "341"
         local item_var_map = item[action_key]

         if item_var_map then
            for var, accessing_nodes in pairs(item_var_map) do
               -- If there are no values at all reaching this access, not even the empty one,
               -- this item (or a closure containing it) is not reachable from variable definition.
               -- It will be reported as unreachable code, no need to report uninitalized accesses in it.
               if item.used_values[var] then
                  -- If this variable is has only one, empty value then it's already reported as never set,
                  -- no need to report each access.
                  if not (#var.values == 1 and var.values[1].empty) then
                     local all_possible_values_empty = true

                     for _, possible_value in ipairs(item.used_values[var]) do
                        if not possible_value.empty then
                           all_possible_values_empty = false
                           break
                        end
                     end

                     if all_possible_values_empty then
                        for _, accessing_node in ipairs(accessing_nodes) do
                           chstate:warn_range(code, accessing_node, {
                              name = accessing_node[1]
                           })
                        end
                     end
                  end
               end
            end
         end
      end
   end
end

-- Warns about accesses and mutations that don't resolve to any values except initial empty one.
function stage.run(chstate)
   for _, line in ipairs(chstate.lines) do
      detect_uninit_access_in_line(chstate, line)
   end
end

return stage

end)
__bundle_register("luacheck.stages.detect_unbalanced_assignments", function(require, _LOADED, __bundle_register, __bundle_modules)
local core_utils = require("luacheck.core_utils")

local stage = {}

stage.warnings = {
   ["531"] = {message_format = "right side of assignment has more values than left side expects", fields = {}},
   ["532"] = {message_format = "right side of assignment has less values than left side expects", fields = {}}
}

local function is_unpacking(node)
   return node.tag == "Dots" or node.tag == "Call" or node.tag == "Invoke"
end

local function check_assignment(chstate, node)
   local rhs = node[2]

   if not rhs then
      return
   end

   local lhs = node[1]

   if #rhs > #lhs then
      chstate:warn_range("531", node)
   elseif #rhs < #lhs and node.tag == "Set" and not is_unpacking(rhs[#rhs]) then
      chstate:warn_range("532", node)
   end
end

function stage.run(chstate)
   core_utils.each_statement(chstate, {"Set", "Local"}, check_assignment)
end

return stage

end)
__bundle_register("luacheck.stages.detect_reversed_fornum_loops", function(require, _LOADED, __bundle_register, __bundle_modules)
local core_utils = require("luacheck.core_utils")

local stage = {}

stage.warnings = {
   ["571"] = {message_format = "numeric for loop goes from #(expr) down to {limit} but loop step is not negative",
      fields = {"limit"}}
}

local function check_fornum(chstate, node)
   if node[2].tag ~= "Op" or node[2][1] ~= "len" then
      return
   end

   local limit, limit_repr = core_utils.eval_const_node(node[3])

   if not limit or limit > 1 then
      return
   end

   local step = 1

   if node[5] then
      step = core_utils.eval_const_node(node[4])
   end

   if step and step >= 0 then
      chstate:warn_range("571", node, {
         limit = limit_repr
      })
   end
end

-- Warns about loops trying to go from \`#(expr)\` to \`1\` with positive step.
function stage.run(chstate)
   core_utils.each_statement(chstate, {"Fornum"}, check_fornum)
end

return stage

end)
__bundle_register("luacheck.stages.detect_globals", function(require, _LOADED, __bundle_register, __bundle_modules)
local utils = require("luacheck.utils")

local stage = {}

local function prefix_if_indirect(message)
   return function(warning)
      if warning.indirect then
         return "indirectly " .. message
      else
         return message
      end
   end
end

local function setting_global_format_message(warning)
   -- \`module\` field is set during filtering.
   if warning.module then
      return "setting non-module global variable {name!}"
   else
      return "setting non-standard global variable {name!}"
   end
end
local global_warning_fields = {"name", "indexing", "previous_indexing_len", "top", "indirect"}

stage.warnings = {
   ["111"] = {message_format = setting_global_format_message, fields = global_warning_fields},
   ["112"] = {message_format = "mutating non-standard global variable {name!}", fields = global_warning_fields},
   ["113"] = {message_format = "accessing undefined variable {name!}", fields = global_warning_fields},
   -- The following warnings are added during filtering.
   ["121"] = {message_format = "setting read-only global variable {name!}", fields = {}},
   ["122"] = {message_format = prefix_if_indirect("setting read-only field {field!} of global {name!}"), fields = {}},
   ["131"] = {message_format = "unused global variable {name!}", fields = {}},
   ["142"] = {message_format = prefix_if_indirect("setting undefined field {field!} of global {name!}"), fields = {}},
   ["143"] = {message_format = prefix_if_indirect("accessing undefined field {field!} of global {name!}"), fields = {}}
}

local action_codes = {
   set = "1",
   mutate = "2",
   access = "3"
}

-- \`index\` describes an indexing, where \`index[1]\` is a global node
-- and other items describe keys: each one is a string node, "not_string",
-- or "unknown". \`node\` is literal base node that's indexed.
-- E.g. in \`local a = table.a; a.b = "c"\` \`node\` is \`a\` node of the second
-- statement and \`index\` describes \`table.a.b\`.
-- \`index.previous_indexing_len\` is optional length of prefix of \`index\` array representing last assignment
-- in the aliasing chain, e.g. \`2\` in the previous example (because last indexing is \`table.a\`).
local function warn_global(chstate, node, index, is_lhs, is_top_line)
   local global = index[1]
   local action = is_lhs and (#index == 1 and "set" or "mutate") or "access"

   local indexing

   if #index > 1 then
      indexing = {}

      for i, field in ipairs(index) do
         if i > 1 then
            if field == "unknown" then
               indexing[i - 1] = true
            elseif field == "not_string" then
               indexing[i - 1] = false
            else
               indexing[i - 1] = field[1]
            end
         end
      end
   end

   chstate:warn_range("11" .. action_codes[action], node, {
      name = global[1],
      indexing = indexing,
      previous_indexing_len = index.previous_indexing_len,
      top = is_top_line and action == "set" or nil,
      indirect = node ~= global or nil
   })
end

local function resolved_to_index(resolution)
   return resolution ~= "unknown" and resolution ~= "not_string" and resolution.tag ~= "String"
end

local literal_tags = utils.array_to_set({"Nil", "True", "False", "Number", "String", "Table", "Function"})

local deep_resolve -- Forward declaration.

local function resolve_node(node, item)
   if node.tag == "Id" or node.tag == "Index" then
      deep_resolve(node, item)
      return node.resolution
   elseif literal_tags[node.tag] then
      return node.tag == "String" and node or "not_string"
   else
      return "unknown"
   end
end

-- Resolves value of an identifier or index node, tracking through simple
-- assignments like \`local foo = bar.baz\`.
-- Can be given an \`Invoke\` node to resolve the method field.
-- Sets \`node.resolution\` to "unknown", "not_string", \`string node\`, or
-- {previous_indexing_len = index, global_node, key...}.
-- Each key can be "unknown", "not_string" or \`string_node\`.
function deep_resolve(node, item)
   if node.resolution then
      return
   end

   -- Common case.
   -- Also protects against infinite recursion, if it's even possible.
   node.resolution = "unknown"

   local base = node
   local base_tag = node.tag == "Id" and "Id" or "Index"
   local keys = {}

   while base_tag == "Index" do
      table.insert(keys, 1, base[2])
      base = base[1]
      base_tag = base.tag
   end

   if base_tag ~= "Id" then
      return
   end

   local var = base.var
   local base_resolution
   local previous_indexing_len

   if var then
      if not item.used_values[var] or #item.used_values[var] ~= 1 then
         -- Do not know where the value for the base local came from.
         return
      end

      local value = item.used_values[var][1]

      if not value.node then
         return
      end

      base_resolution = resolve_node(value.node, value.item)

      if resolved_to_index(base_resolution) then
         previous_indexing_len = #base_resolution
      end
   else
      base_resolution = {base}
   end

   if #keys == 0 then
      node.resolution = base_resolution
   elseif not resolved_to_index(base_resolution) then
      -- Indexing something unknown or indexing a literal.
      node.resolution = "unknown"
   else
      local resolution = utils.update({}, base_resolution)
      resolution.previous_indexing_len = previous_indexing_len

      for _, key in ipairs(keys) do
         local key_resolution = resolve_node(key, item)

         if resolved_to_index(key_resolution) then
            key_resolution = "unknown"
         end

         table.insert(resolution, key_resolution)
      end

      -- Assign resolution only after all the recursive calls.
      node.resolution = resolution
   end
end

local function detect_in_node(chstate, item, node, is_top_line, is_lhs)
   if node.tag == "Index" or node.tag == "Invoke" or node.tag == "Id" then
      if node.tag == "Id" and node.var then
         -- Do not warn about assignments to and accesses of local variables
         -- that resolve to globals or their fields.
         return
      end

      deep_resolve(node, item)
      local resolution = node.resolution

      -- Still need to recurse into base and key nodes.
      -- E.g. don't miss a global in \`(global1())[global2()].

      if node.tag == "Invoke" then
         for i = 3, #node do
            detect_in_node(chstate, item, node[i], is_top_line)
         end
      end

      if node.tag ~= "Id" then
         repeat
            detect_in_node(chstate, item, node[2], is_top_line)
            node = node[1]
         until node.tag ~= "Index"

         if node.tag ~= "Id" then
            detect_in_node(chstate, item, node, is_top_line)
         end
      end

      if resolved_to_index(resolution) then
         warn_global(chstate, node, resolution, is_lhs, is_top_line)
      end
   elseif node.tag ~= "Function" then
      for _, nested_node in ipairs(node) do
         if type(nested_node) == "table" then
            detect_in_node(chstate, item, nested_node, is_top_line)
         end
      end
   end
end

local function detect_in_nodes(chstate, item, nodes, is_top_line, is_lhs)
   for _, node in ipairs(nodes) do
      detect_in_node(chstate, item, node, is_top_line, is_lhs)
   end
end

local function detect_globals_in_line(chstate, line)
   local is_top_line = line == chstate.top_line

   for _, item in ipairs(line.items) do
      if item.tag == "Eval" then
         detect_in_node(chstate, item, item.node, is_top_line)
      elseif item.tag == "Local" then
         if item.rhs then
            detect_in_nodes(chstate, item, item.rhs, is_top_line)
         end
      elseif item.tag == "Set" then
         detect_in_nodes(chstate, item, item.lhs, is_top_line, true)
         detect_in_nodes(chstate, item, item.rhs, is_top_line)
      end
   end
end

-- Warns about assignments, field accesses, and mutations of global variables,
-- tracing through localizing assignments such as \`local t = table\`.
function stage.run(chstate)
   for _, line in ipairs(chstate.lines) do
      detect_globals_in_line(chstate, line)
   end
end

return stage

end)
__bundle_register("luacheck.stages.detect_empty_statements", function(require, _LOADED, __bundle_register, __bundle_modules)
local stage = {}

stage.warnings = {
   ["551"] = {message_format = "empty statement", fields = {}}
}

function stage.run(chstate)
   for _, range in ipairs(chstate.useless_semicolons) do
      chstate:warn_range("551", range)
   end
end

return stage

end)
__bundle_register("luacheck.stages.detect_empty_blocks", function(require, _LOADED, __bundle_register, __bundle_modules)
local core_utils = require("luacheck.core_utils")

local stage = {}

stage.warnings = {
   ["541"] = {message_format = "empty do..end block", fields = {}},
   ["542"] = {message_format = "empty if branch", fields = {}}
}

local function check_block(chstate, block, code)
   if #block == 0 then
      chstate:warn_range(code, block)
   end
end


local function check_node(chstate, node)
   if node.tag == "Do" then
      check_block(chstate, node, "541")
      return
   end

   for index = 2, #node, 2 do
      check_block(chstate, node[index], "542")
   end

   if #node % 2 == 1 then
      check_block(chstate, node[#node], "542")
   end
end

function stage.run(chstate)
   core_utils.each_statement(chstate, {"Do", "If"}, check_node)
end

return stage

end)
__bundle_register("luacheck.stages.detect_cyclomatic_complexity", function(require, _LOADED, __bundle_register, __bundle_modules)
local utils = require("luacheck.utils")

local stage = {}

local function cyclomatic_complexity_message_format(warning)
   local template = "cyclomatic complexity of %s is too high ({complexity} > {max_complexity})"

   local function_descr

   if warning.function_type == "main_chunk" then
      function_descr = "main chunk"
   elseif warning.function_name then
      function_descr = "{function_type} {function_name!}"
   else
      function_descr = "function"
   end

   return template:format(function_descr)
end

stage.warnings = {
   ["561"] = {message_format = cyclomatic_complexity_message_format,
      fields = {"complexity", "function_type", "function_name"}}
}

local function warn_cyclomatic_complexity(chstate, line, complexity)
   if line == chstate.top_line then
      chstate:warn("561", 1, 1, 1, {
         complexity = complexity,
         function_type = "main_chunk"
      })
   else
      local node = line.node

      chstate:warn_range("561", node, {
         complexity = complexity,
         function_type = node[1][1] and node[1][1].implicit and "method" or "function",
         function_name = node.name
      })
   end
end

local CyclomaticComplexityMetric = utils.class()

function CyclomaticComplexityMetric:incr_decisions(count)
   self.count = self.count + count
end

function CyclomaticComplexityMetric:calc_expr(node)
   if node.tag == "Op" and (node[1] == "and" or node[1] == "or") then
      self:incr_decisions(1)
   end

   if node.tag ~= "Function" then
      self:calc_exprs(node)
   end
end

function CyclomaticComplexityMetric:calc_exprs(exprs)
   for _, expr in ipairs(exprs) do
      if type(expr) == "table" then
         self:calc_expr(expr)
      end
   end
end

function CyclomaticComplexityMetric:calc_item_Eval(item)
   self:calc_expr(item.node)
end

function CyclomaticComplexityMetric:calc_item_Local(item)
   if item.rhs then
      self:calc_exprs(item.rhs)
   end
end

function CyclomaticComplexityMetric:calc_item_Set(item)
   self:calc_exprs(item.rhs)
end

function CyclomaticComplexityMetric:calc_item(item)
   local f = self["calc_item_" .. item.tag]
   if f then
      f(self, item)
   end
end

function CyclomaticComplexityMetric:calc_items(items)
   for _, item in ipairs(items) do
      self:calc_item(item)
   end
end

-- stmt if: {condition, block; condition, block; ... else_block}
function CyclomaticComplexityMetric:calc_stmt_If(node)
   for i = 1, #node - 1, 2 do
      self:incr_decisions(1)
      self:calc_stmts(node[i+1])
   end

   if #node % 2 == 1 then
      self:calc_stmts(node[#node])
   end
end

-- stmt while: {condition, block}
function CyclomaticComplexityMetric:calc_stmt_While(node)
   self:incr_decisions(1)
   self:calc_stmts(node[2])
end

-- stmt repeat: {block, condition}
function CyclomaticComplexityMetric:calc_stmt_Repeat(node)
   self:incr_decisions(1)
   self:calc_stmts(node[1])
end

-- stmt forin: {iter_vars, expression_list, block}
function CyclomaticComplexityMetric:calc_stmt_Forin(node)
   self:incr_decisions(1)
   self:calc_stmts(node[3])
end

-- stmt fornum: {first_var, expression, expression, expression[optional], block}
function CyclomaticComplexityMetric:calc_stmt_Fornum(node)
   self:incr_decisions(1)
   self:calc_stmts(node[5] or node[4])
end

function CyclomaticComplexityMetric:calc_stmt(node)
   local f = self["calc_stmt_" .. node.tag]
   if f then
      f(self, node)
   end
end

function CyclomaticComplexityMetric:calc_stmts(stmts)
   for _, stmt in ipairs(stmts) do
      self:calc_stmt(stmt)
   end
end

-- Cyclomatic complexity of a function equals to the number of decision points plus 1.
function CyclomaticComplexityMetric:report(chstate, line)
   self.count = 1
   self:calc_stmts(line.node[2])
   self:calc_items(line.items)
   warn_cyclomatic_complexity(chstate, line, self.count)
end

function stage.run(chstate)
   local ccmetric = CyclomaticComplexityMetric()

   for _, line in ipairs(chstate.lines) do
      ccmetric:report(chstate, line)
   end
end

return stage

end)
__bundle_register("luacheck.stages.detect_bad_whitespace", function(require, _LOADED, __bundle_register, __bundle_modules)
local stage = {}

stage.warnings = {
   ["611"] = {message_format = "line contains only whitespace", fields = {}},
   ["612"] = {message_format = "line contains trailing whitespace", fields = {}},
   ["613"] = {message_format = "trailing whitespace in a string", fields = {}},
   ["614"] = {message_format = "trailing whitespace in a comment", fields = {}},
   ["621"] = {message_format = "inconsistent indentation (SPACE followed by TAB)", fields = {}}
}

function stage.run(chstate)
   local num_lines = #chstate.line_offsets

   for line_number = 1, num_lines do
      local line_offset = chstate.line_offsets[line_number]
      local line_length = chstate.line_lengths[line_number]

      if line_length > 0 then
         local trailing_ws_pattern

         if line_number == num_lines then
            trailing_ws_pattern = "^[^\\r\\n]-()[ \\t\\f\\v]+()[\\r\\n]?$"
         else
            trailing_ws_pattern = "^[^\\r\\n]-()[ \\t\\f\\v]+()[\\r\\n]"
         end

         local line_start_byte, _, trailing_ws_start_byte, line_end_byte = chstate.source:find(
            trailing_ws_pattern, line_offset)

         local trailing_ws_code

         if trailing_ws_start_byte then

            if trailing_ws_start_byte == line_start_byte then
               -- Line contains only whitespace (thus never considered "code").
               trailing_ws_code = "611"
            elseif not chstate.line_endings[line_number] then
               -- Trailing whitespace on code line or after long comment.
               trailing_ws_code = "612"
            elseif chstate.line_endings[line_number] == "string" then
               -- Trailing whitespace embedded in a string literal.
               trailing_ws_code = "613"
            elseif chstate.line_endings[line_number] == "comment" then
            -- Trailing whitespace at the end of a line comment or inside long comment.
               trailing_ws_code = "614"
            end

            -- The difference between the start and the end of the warning range
            -- is the same in bytes and in characters because whitespace characters are ASCII.
            -- Can calculate one based on the three others.
            local trailing_ws_end_byte = line_end_byte - 1
            local trailing_ws_end_char = line_offset + line_length - 1
            local trailing_ws_start_char = trailing_ws_end_char - (trailing_ws_end_byte - trailing_ws_start_byte)

            chstate:warn(trailing_ws_code, line_number, trailing_ws_start_char, trailing_ws_end_char)
         end

         -- Don't look for inconsistent whitespace in pure whitespace lines.
         if trailing_ws_code ~= "611" then
            local leading_ws_start_byte, leading_ws_end_byte = chstate.source:find(
               "^[ \\t\\f\\v]- \\t[ \\t\\f\\v]*", line_offset)

            if leading_ws_start_byte then
               -- Inconsistent leading whitespace (SPACE followed by TAB).

               -- Calculate warning end in characters using same logic as above.
               local leading_ws_start_char = line_offset
               local leading_ws_end_char = leading_ws_start_char + (leading_ws_end_byte - leading_ws_start_byte)
               chstate:warn("621", line_number, line_offset, leading_ws_end_char)
            end
         end
      end
   end
end

return stage

end)
__bundle_register("luacheck.stages.resolve_locals", function(require, _LOADED, __bundle_register, __bundle_modules)
local stage = {}

-- The main part of analysis is connecting assignments to locals or upvalues
-- with accesses that may use the assigned value.
-- Accesses and assignments are split into two groups based on whether they happen
-- in the closure that defines subject local variable (main assignment, main access)
-- or in some nested closure (closure assignment, closure access).
-- To avoid false positives, it's assumed that a closure may be called at any point
-- starting from expression that creates it.
-- Additionally, all operations on upvalues are considered in bulk, as in,
-- when a closure is called, it's assumed that any subset of its upvalue assignments
-- and accesses may happen, in any order.

-- Assignments and accesses are connected based on whether they can reach each other.
-- A main assignment is connected with a main access when the assignment can reach the access.
-- A main assignment is connected with a closure access when the assignment can reach the closure creation
-- or the closure creation can reach the assignment.
-- A closure assignment is connected with a main access when the closure creation can reach the access.
-- A closure assignment is connected with a closure access when either closure creation can reach the other one.

-- To determine what flow graph nodes an assignment or a closure creation can reach,
-- they are independently propagated along the graph.
-- Closure creation propagation is not bounded.
-- Main assignment propagation is bounded by entrance and exit conditions for each reached flow graph node.
-- Entrance condition checks that target local variable is still in scope. If entrance condition fails,
-- nothing in the node can refer to the variable, and the scope can't be reentered later.
-- So, in this case, assignment does not reach the node, and propagation does not continue.
-- Exit condition checks that target local variable is not overwritten by an assignment in the node.
-- If it fails, the assignment still reaches the node (because all accesses in a node are evaluated before any
-- assignments take effect), but propagation does not continue.

local function register_value(values_per_var, var, value)
   if not values_per_var[var] then
      values_per_var[var] = {}
   end

   table.insert(values_per_var[var], value)
end

-- Called when assignment of \`value\` is connected to an access.
-- \`item\` contains the access, and \`line\` contains the item.
local function add_resolution(line, item, var, value, is_mutation)
   register_value(item.used_values, var, value)
   value[is_mutation and "mutated" or "used"] = true
   value.using_lines[line] = true

   if value.secondaries then
      value.secondaries.used = true
   end
end

-- Connects accesses in given items array with an assignment of \`value\`.
-- \`items\` may be \`nil\` instead of empty.
local function add_resolutions(line, items, var, value, is_mutation)
   if not items then
      return
   end

   for _, item in ipairs(items) do
      add_resolution(line, item, var, value, is_mutation)
   end
end

-- Connects all accesses (and mutations) in \`access_line\` with corresponding
-- assignments in \`set_line\`.
local function cross_resolve_closures(access_line, set_line)
   for var, setting_items in pairs(set_line.set_upvalues) do
      for _, setting_item in ipairs(setting_items) do
         add_resolutions(access_line, access_line.accessed_upvalues[var],
            var, setting_item.set_variables[var])
         add_resolutions(access_line, access_line.mutated_upvalues[var],
            var, setting_item.set_variables[var], true)
      end
   end
end

local function in_scope(var, index)
   return (var.scope_start <= index) and (index <= var.scope_end)
end

-- Called when main assignment propagation reaches a line item.
local function main_assignment_propagation_callback(line, index, item, var, value)
   -- Check entrance condition.
   if not in_scope(var, index) then
      -- Assignment reaches the end of variable scope, so it can't be dominated by any assignment.
      value.overwriting_item = false
      return true
   end

   -- Assignment reaches this item, apply its effect.

   -- Accesses (and mutations) of the variable can resolve to reaching assignment.
   if item.accesses and item.accesses[var] then
      add_resolution(line, item, var, value)
   end

   if item.mutations and item.mutations[var] then
      add_resolution(line, item, var, value, true)
   end

   -- Accesses (and mutations) of the variable inside closures created in this item
   -- can resolve to reaching assignment.
   if item.lines then
      for _, created_line in ipairs(item.lines) do
         add_resolutions(created_line, created_line.accessed_upvalues[var], var, value)
         add_resolutions(created_line, created_line.mutated_upvalues[var], var, value, true)
      end
   end

   -- Check exit condition.
   if item.set_variables and item.set_variables[var] then
      if value.overwriting_item ~= false then
         if value.overwriting_item and value.overwriting_item ~= item then
            value.overwriting_item = false
         else
            value.overwriting_item = item
         end
      end

      return true
   end
end

-- Connects main assignments with main accesses and closure accesses in reachable closures.
-- Additionally, sets \`overwriting_item\` field of values to an item with an assignment overwriting
-- the value, but only if the overwriting is not avoidable (i.e. it's impossible to reach end of function
-- from the first assignment without going through the second one). Otherwise value of the field may be
-- \`false\` or \`nil\`.
local function propagate_main_assignments(line)
   for i, item in ipairs(line.items) do
      if item.set_variables then
         for var, value in pairs(item.set_variables) do
            if var.line == line then
               -- Assignments are not live at their own item, because assignments take effect only after all accesses
               -- are evaluated. Items with assignments can't be jumps, so they have a single following item
               -- with incremented index.
               line:walk({}, i + 1, main_assignment_propagation_callback, var, value)
            end
         end
      end
   end
end

-- Called when closure creation propagation reaches a line item.
local function closure_creation_propagation_callback(line, _, item, propagated_line)
   if not item then
      return true
   end

   -- Closure creation reaches this item, apply its effects.

   -- Accesses (and mutations) of upvalues in the propagated closure
   -- can resolve to assignments in the item.
   if item.set_variables then
      for var, value in pairs(item.set_variables) do
         add_resolutions(propagated_line, propagated_line.accessed_upvalues[var], var, value)
         add_resolutions(propagated_line, propagated_line.mutated_upvalues[var], var, value, true)
      end
   end

   if item.lines then
      for _, created_line in ipairs(item.lines) do
         -- Accesses (and mutations) of upvalues in the propagated closure
         -- can resolve to assignments in closures created in the item.
         cross_resolve_closures(propagated_line, created_line)

         -- Accesses (and mutations) of upvalues in closures created in the item
         -- can resolve to assignments in the propagated closure.
         cross_resolve_closures(created_line, propagated_line)
      end
   end

   -- Accesses (and mutations) of locals in the item can resolve
   -- to assignments in the propagated closure.
   for var, setting_items in pairs(propagated_line.set_upvalues) do
      if item.accesses and item.accesses[var] then
         for _, setting_item in ipairs(setting_items) do
            add_resolution(line, item, var, setting_item.set_variables[var])
         end
      end

      if item.mutations and item.mutations[var] then
         for _, setting_item in ipairs(setting_items) do
            add_resolution(line, item, var, setting_item.set_variables[var], true)
         end
      end
   end
end

-- Connects main assignments with closure accesses in reaching closures.
-- Connects closure assignments with main accesses and with closure accesses in reachable closures.
-- Connects closure accesses with closure assignments in reachable closures.
local function propagate_closure_creations(line)
   for i, item in ipairs(line.items) do
      if item.lines then
         for _, created_line in ipairs(item.lines) do
            -- Closures are live at the item they are created, as they can be called immediately.
            line:walk({}, i, closure_creation_propagation_callback, created_line)
         end
      end
   end
end

local function analyze_line(line)
   propagate_main_assignments(line)
   propagate_closure_creations(line)
end

-- Finds reaching assignments for all local variable accesses.
function stage.run(chstate)
   for _, line in ipairs(chstate.lines) do
      analyze_line(line)
   end
end

return stage

end)
__bundle_register("luacheck.stages.name_functions", function(require, _LOADED, __bundle_register, __bundle_modules)
local stage = {}

local function get_index_name(base_name, key_node)
   if key_node.tag == "String" then
      return base_name .. "." .. key_node[1]
   end
end

local function get_full_field_name(node)
   if node.tag == "Id" then
      return node[1]
   elseif node.tag == "Index" then
      local base_name = get_full_field_name(node[1])
      return base_name and get_index_name(base_name, node[2])
   end
end

local handle_node

local function handle_nodes(nodes)
   for _, node in ipairs(nodes) do
      if type(node) == "table" then
         handle_node(node)
      end
   end
end

function handle_node(node, name)
   if node.tag == "Function" then
      node.name = name
      handle_nodes(node[2])
   elseif node.tag == "Set" or node.tag == "Local" or node.tag == "Localrec" then
      local lhs = node[1]
      local rhs = node[2]

      -- No need to handle LHS if there is no RHS, it's always just a list of locals in that case.
      if rhs then
         handle_nodes(lhs)

         for index, rhs_node in ipairs(rhs) do
            local lhs_node = lhs[index]
            local field_name = lhs_node and get_full_field_name(lhs_node)
            handle_node(rhs_node, field_name)
         end
      end
   elseif node.tag == "Table" and name then
      for _, pair_node in ipairs(node) do
         if pair_node.tag == "Pair" then
            local key_node = pair_node[1]
            local value_node = pair_node[2]
            handle_node(key_node)
            handle_node(value_node, get_index_name(name, key_node))
         else
            handle_node(pair_node)
         end
      end
   else
      handle_nodes(node)
   end
end

-- Adds \`name\` field to \`Function\` ast nodes when possible:
-- * Function assigned to a variable (doesn't matter if local or global): "foo".
-- * Function assigned to a field: "foo.bar.baz".
--   Function can be in a table assigned to a variable or a field, e.g. \`foo.bar = {baz = function() ... end}\`.
-- * Otherwise: \`nil\`.
function stage.run(chstate)
   handle_nodes(chstate.ast)
end

return stage

end)
__bundle_register("luacheck.stages.parse_inline_options", function(require, _LOADED, __bundle_register, __bundle_modules)
local options = require("luacheck.options")
local utils = require("luacheck.utils")

local stage = {}

stage.warnings = {
   -- Also produced during filtering for options that did not pass validation.
   ["021"] = {message_format = "{msg}", fields = {"msg"}},
   ["022"] = {message_format = "unpaired push directive", fields = {}},
   ["023"] = {message_format = "unpaired pop directive", fields = {}}
}

stage.inline_option_fields = {"line", "pop_count", "options", "column", "end_column"}

local limit_opts = utils.array_to_set({"max_line_length", "max_code_line_length", "max_string_line_length",
   "max_comment_line_length", "max_cyclomatic_complexity"})

local function is_valid_option_name(name)
   if name == "std" or options.variadic_inline_options[name] then
      return true
   end

   name = name:gsub("^no_", "")
   return options.nullary_inline_options[name] or limit_opts[name]
end

-- Splits a token array for an inline option invocation into
-- option name and argument array, or nil if invocation is invalid.
local function split_invocation(tokens)
   -- Name of the option can be split into several space separated tokens.
   -- Since some valid names are prefixes of some other names
   -- (e.g. \`unused\` and \`unused arguments\`), the longest prefix of token
   -- array that is a valid option name should be considered.
   local cur_name
   local last_valid_name
   local last_valid_name_end_index

   for i, token in ipairs(tokens) do
      cur_name = cur_name and (cur_name .. "_" .. token) or token

      if is_valid_option_name(cur_name) then
         last_valid_name = cur_name
         last_valid_name_end_index = i
      end
   end

   if not last_valid_name then
      return
   end

   local args = {}

   for i = last_valid_name_end_index + 1, #tokens do
      table.insert(args, tokens[i])
   end

   return last_valid_name, args
end

local function unexpected_num_args(name, args, expected)
   return ("inline option '%s' expects %d argument%s, %d given"):format(
      name, expected, expected == 1 and "" or "s", #args)
end

-- Parses inline option body, returns options or nil and error message.
local function parse_options(body)
   local opts = {}

   local parts = utils.split(body, ",")

   for _, name_and_args in ipairs(parts) do
      local tokens = utils.split(name_and_args)
      local name, args = split_invocation(tokens)

      if not name then
         if #tokens == 0 then
            return nil, (#parts == 1) and "empty inline option" or "empty inline option invocation"
         else
            return nil, ("unknown inline option '%s'"):format(table.concat(tokens, " "))
         end
      end

      if name == "std" then
         if #args ~= 1 then
            return nil, unexpected_num_args(name, args, 1)
         end

         opts.std = args[1]
      elseif name == "ignore" and #args == 0 then
         opts.ignore = {".*"}
      elseif options.variadic_inline_options[name] then
         opts[name] = args
      else
         local full_name = name:gsub("_", " ")
         local subs
         name, subs = name:gsub("^no_", "")
         local flag = subs == 0

         if options.nullary_inline_options[name] then
            if #args ~= 0 then
               return nil, unexpected_num_args(full_name, args, 0)
            end

            opts[name] = flag
         else
            assert(limit_opts[name])

            if flag then
               if #args ~= 1 then
                  return nil, unexpected_num_args(full_name, args, 1)
               end

               local value = tonumber(args[1])

               if not value then
                  return nil, ("inline option '%s' expects number as argument"):format(name)
               end

               opts[name] = value
            else
               if #args ~= 0 then
                  return nil, unexpected_num_args(full_name, args, 0)
               end

               opts[name] = false
            end
         end
      end
   end

   return opts
end

-- Parses comment contents, returns up to two \`options\` values (tables or "push" or "pop").
-- On an invalid inline comment returns nil and an error message.
local function parse_inline_comment(comment_contents)
   local body = utils.after(utils.strip(comment_contents), "^luacheck:")

   if not body then
      return
   end

   local opts1, opts2

   -- Remove comments in balanced parens.
   body = utils.strip((body:gsub("%b()", " ")))
   local after_push = body:match("^push%s+(.*)")

   if after_push then
      opts2 = "push"
      body = after_push
   elseif body == "push" or body == "pop" then
      return body
   end

   local err_msg
   opts1, err_msg = parse_options(body)
   return opts1, err_msg or opts2
end

-- Returns an array of tables with column range info and an \`options\` field
-- containing a table of options or "push" or "pop".
-- Warns about invalid inline option comments.
local function parse_inline_comments(chstate)
   local res = {}

   for _, comment in ipairs(chstate.comments) do
      local opts1, opts2 = parse_inline_comment(comment.contents)

      if opts1 then
         table.insert(res, {
            line = comment.line,
            column = chstate:offset_to_column(comment.line, comment.offset),
            end_column = chstate:offset_to_column(comment.line, comment.end_offset),
            options = opts1
         })

         if opts2 then
            table.insert(res, {
               line = comment.line,
               column = chstate:offset_to_column(comment.line, comment.offset),
               end_column = chstate:offset_to_column(comment.line, comment.end_offset),
               options = opts2
            })
         end
      elseif opts2 then
         chstate:warn_range("021", comment, {msg = opts2})
      end
   end

   return res
end

-- Adds a table with \`line\`, \`column\`, and \`options\` fields to given array.
-- For each function a table with \`options\` set to "push" for the function start
-- and a talbe with \`options\` set to "pop" for the function end are added.
local function add_function_boundaries(inline_options_and_boundaries, chstate)
   for _, line in ipairs(chstate.top_line.lines) do
      local fn_node = line.node

      table.insert(inline_options_and_boundaries, {
         line = fn_node.line,
         column = chstate:offset_to_column(fn_node.line, fn_node.offset),
         options = "push"
      })

      table.insert(inline_options_and_boundaries, {
         line = fn_node.end_range.line,
         column = chstate:offset_to_column(fn_node.end_range.line, fn_node.end_range.offset),
         options = "pop"
      })
   end
end

local function get_order(t)
   if t.options == "push" then
      return 1
   elseif t.options == "pop" then
      return 3
   else
      return 2
   end
end

local function options_and_boundaries_comparator(t1, t2)
   if t1.line ~= t2.line then
      return t1.line < t2.line
   end

   -- For options and boundaries on the same line, all pushes are applied before options before pops.
   -- (Valid pops will be moved to the start of the next line later.)
   local order1 = get_order(t1)
   local order2 = get_order(t2)

   if order1 ~= order2 then
      return order1 < order2
   else
      return t1.column < t2.column
   end
end

-- Applies bounadaries withing \`inline_options_and_boundaries\` to replace them with pop count
-- instructions in the resulting array.
-- Comments on lines with code are popped at the end of line.
-- Warns about unpaired push and pop directives.
local function apply_boundaries(chstate, inline_options_and_boundaries)
   local res = {}
   local res_last

   -- While iterating over inline options and boundaries track push
   -- boundaries that were not popped yet plus the number of options
   -- that would be on the option stack after applying all already
   -- processed option table pushes and pops.
   local pushes = utils.Stack()
   local push_option_counts = utils.Stack()
   local option_count = 0

   for _, item in ipairs(inline_options_and_boundaries) do
      if item.options == "push" then
         pushes:push(item)
         push_option_counts:push(option_count)
      elseif item.options == "pop" then
         -- Function boundaries are implicit, don't allow inline options to pop
         -- them, don't allow function boundaries to pop inline option pushes either.
         -- Inline options boundaries have end_column, function boundaries don't.
         if not pushes.top or (item.end_column and not pushes.top.end_column) then
            -- Inline option pop against nothing or a function push, mark as unpaired.
            chstate:warn_column_range("023", item)
         else
            if not item.end_column then
               -- Function pop, remove any unpaired inline option pushes.
               while pushes.top and pushes.top.end_column do
                  chstate:warn_column_range("022", pushes.top)
                  pushes:pop()
                  push_option_counts:pop()
               end
            end

            pushes:pop()
            local prev_option_count = push_option_counts:pop()
            local pop_count = option_count - prev_option_count

            if pop_count > 0 then
               -- Place the pop instruction at the start of the next line so that getting option stack
               -- for a line amounts to applying both the pop instruction and the option push for the line.
               local line = item.line + 1

               -- Collapse with a previous table if it's on the same line. It can only be a pop count table.
               if res_last and res_last.line == line then
                  res_last.pop_count = res_last.pop_count + pop_count
               else
                  res_last = {
                     line = line,
                     pop_count = pop_count
                  }

                  table.insert(res, res_last)
               end
            end

            -- Update option stack size for this pop.
            option_count = prev_option_count
         end
      else
         -- Inline options table. Check if there is a pop count table for this line already.
         if res_last and res_last.line == item.line then
            res_last.options = item.options
            res_last.column = item.column
            res_last.end_column = item.end_column
         else
            res_last = item
            table.insert(res, item)
         end

         if chstate.code_lines[item.line] then
            -- Inline comment on a line with some code, immediately pop it.
            res_last = {
               line = item.line + 1,
               pop_count = 1
            }
            table.insert(res, res_last)
         else
            option_count = option_count + 1
         end
      end
   end

   -- Any remaining pushes are unpaired inline comments from the main chunk.
   while pushes.top do
      chstate:warn_column_range("022", pushes:pop())
   end

   return res
end

-- Warns about invalid inline options.
-- Sets \`chstate.inline_options\` to an array of tables that describe the way inline option tables
-- are pushed onto and popped from the option stack when iterating over lines.
-- Each table has field \`line\` that the array is sorted by and also ether or both sets of fields:
-- * \`pop_count\` - refers to a number of option tables that should be popped from the stack before processing
--   warnings on this line.
-- * \`options\`, \`column\`, \`end_column\` - refers to an option table that should be pushed onto the stack
--   before processing warnings on this line but after popping tables if \`pop_count\` is present.
function stage.run(chstate)
   local inline_options_and_boundaries = parse_inline_comments(chstate)
   add_function_boundaries(inline_options_and_boundaries, chstate)
   table.sort(inline_options_and_boundaries, options_and_boundaries_comparator)
   chstate.inline_options = apply_boundaries(chstate, inline_options_and_boundaries)
end

return stage

end)
__bundle_register("luacheck.options", function(require, _LOADED, __bundle_register, __bundle_modules)
local options = {}

local builtin_standards = require("luacheck.builtin_standards.init")
local standards = require("luacheck.standards")
local utils = require("luacheck.utils")

local boolean = utils.has_type("boolean")
local number_or_false = utils.has_type_or_false("number")
local array_of_strings = utils.array_of("string")

-- Validates std string.
-- Returns an array of std names with \`add\` field if there is \`+\` at the beginning of the string.
-- On validation error returns \`nil\` and an error message.
local function split_std(std, stds)
   local parts = utils.split(std, "+")

   if parts[1]:match("^%s*$") then
      parts.add = true
      table.remove(parts, 1)
   end

   for i, part in ipairs(parts) do
      parts[i] = utils.strip(part)

      if not stds[parts[i]] then
         return nil, ("unknown std '%s'"):format(parts[i])
      end
   end

   return parts
end

local function std_or_array_of_strings(x, stds)
   if type(x) == "string" then
      local ok, err = split_std(x, stds)
      return not not ok, err
   elseif type(x) == "table" then
      return standards.validate_std_table(x)
   else
      return false, "string or table expected, got " .. type(x)
   end
end

local function field_map(x)
   if type(x) == "table" then
      return standards.validate_globals_table(x)
   else
      return false, "table expected, got " .. type(x)
   end
end

options.nullary_inline_options = {
   global = boolean,
   unused = boolean,
   redefined = boolean,
   unused_args = boolean,
   unused_secondaries = boolean,
   self = boolean,
   compat = boolean,
   allow_defined = boolean,
   allow_defined_top = boolean,
   module = boolean
}

options.variadic_inline_options = {
   globals = field_map,
   read_globals = field_map,
   new_globals = field_map,
   new_read_globals = field_map,
   not_globals = array_of_strings,
   ignore = array_of_strings,
   enable = array_of_strings,
   only = array_of_strings
}

options.all_options = {
   std = std_or_array_of_strings,
   max_line_length = number_or_false,
   max_code_line_length = number_or_false,
   max_string_line_length = number_or_false,
   max_comment_line_length = number_or_false,
   max_cyclomatic_complexity = number_or_false
}

utils.update(options.all_options, options.nullary_inline_options)
utils.update(options.all_options, options.variadic_inline_options)

-- Returns true if opts is valid option_set or is nil.
-- Otherwise returns false and an error message.
function options.validate(option_set, opts, stds)
   if opts == nil then
      return true
   end

   if type(opts) ~= "table" then
      return false, "option table expected, got " .. type(opts)
   end

   stds = stds or builtin_standards

   for option, validator in utils.sorted_pairs(option_set) do
      if opts[option] ~= nil then
         local ok, err = validator(opts[option], stds)

         if not ok then
            return false, ("invalid value of option '%s': %s"):format(option, err)
         end
      end
   end

   return true
end

-- Option stack is an array of options with options closer to end
-- overriding options closer to beginning.

-- Extracts sequence of active std tables from an option stack.
local function get_std_tables(opts_stack, stds)
   local base_std
   local add_stds = {}
   local no_compat = false

   for _, opts in utils.ripairs(opts_stack) do
      if opts.compat and not no_compat then
         base_std = stds.max
         break
      elseif opts.compat == false then
         no_compat = true
      end

      if opts.std then
         if type(opts.std) == "table" then
            base_std = opts.std
            break
         else
            local parts = split_std(opts.std, stds)

            for _, part in ipairs(parts) do
               table.insert(add_stds, stds[part])
            end

            if not parts.add then
               base_std = {}
               break
            end
         end
      end
   end

   table.insert(add_stds, 1, base_std or stds.max)
   return add_stds
end

-- Returns index of the last option table in a stack that uses given option,
-- or zero if the option isn't used anywhere.
local function index_of_last_option_usage(opts_stack, option_name)
   for index, opts in utils.ripairs(opts_stack) do
      if opts[option_name] then
         return index
      end
   end

   return 0
end

local function split_field(field_name)
   return utils.split(field_name, "%.")
end

local function field_comparator(field1, field2)
   local parts1 = field1[1]
   local parts2 = field2[1]

   for i = 1, math.max(#parts1, #parts2) do
      local part1 = parts1[i]
      local part2 = parts2[i]

      if not part1 then
         return true
      elseif not part2 then
         return false
      end

      if part1 ~= part2 then
         return part1 < part2
      end
   end

   return false
end

-- Combine all stds and global related options into one final definition table.
-- A definition table may have fields \`read_only\` (boolean), \`other_fields\` (boolean),
-- and \`fields\` (maps field names to definition tables).
-- Std table format is similar, except at the top level there are two fields
-- \`globals\` and \`read_globals\` mapping to top-level field tables. Also in field tables
-- it's possible to use field names in array part as a shortcut:
-- \`{fields = {"foo"}}\` is equivalent to \`{fields = {foo = {}}}\` or \`{fields = {foo = {other_fields = true}}}\`
-- in top level fields tables.
local function get_final_std(opts_stack, stds)
   local final_std = {}
   local std_tables = get_std_tables(opts_stack, stds)

   for _, std_table in ipairs(std_tables) do
      standards.add_std_table(final_std, std_table)
   end

   local last_new_globals = index_of_last_option_usage(opts_stack, "new_globals")
   local last_new_read_globals = index_of_last_option_usage(opts_stack, "new_read_globals")

   for index, opts in ipairs(opts_stack) do
      local globals = (index >= last_new_globals) and (opts.new_globals or opts.globals)
      local read_globals = (index >= last_new_read_globals) and (opts.new_read_globals or opts.read_globals)

      local new_fields = {}

      if globals then
         for _, global in ipairs(globals) do
            table.insert(new_fields, {split_field(global), false})
         end
      end

      if read_globals then
         for _, read_global in ipairs(read_globals) do
            table.insert(new_fields, {split_field(read_global), true})
         end
      end

      if globals and read_globals then
         -- If there are both globals and read-only globals defined in one options table,
         -- it's important that more general definitions are applied first,
         -- otherwise they will completely overwrite more specific definitions.
         -- E.g. \`globals x\` should be applied before \`read globals x.y\`.
         table.sort(new_fields, field_comparator)
      end

      for _, field in ipairs(new_fields) do
         standards.overwrite_field(final_std, field[1], field[2])
      end

      standards.add_std_table(final_std, {globals = globals, read_globals = read_globals}, true, true)

      if opts.not_globals then
         for _, not_global in ipairs(opts.not_globals) do
            standards.remove_field(final_std, split_field(not_global))
         end
      end
   end

   standards.finalize(final_std)
   return final_std
end

local function get_scalar_opt(opts_stack, option, default)
   for _, opts in utils.ripairs(opts_stack) do
      if opts[option] ~= nil then
         return opts[option]
      end
   end

   return default
end

local line_length_suboptions = {"max_code_line_length", "max_string_line_length", "max_comment_line_length"}

local function get_max_line_opts(opts_stack)
   local res = {max_line_length = 120}

   for _, opt_name in ipairs(line_length_suboptions) do
      res[opt_name] = res.max_line_length
   end

   for _, opts in ipairs(opts_stack) do
      if opts.max_line_length ~= nil then
         res.max_line_length = opts.max_line_length

         for _, opt_name in ipairs(line_length_suboptions) do
            res[opt_name] = opts.max_line_length
         end
      end

      for _, opt_name in ipairs(line_length_suboptions) do
         if opts[opt_name] ~= nil then
            res[opt_name] = opts[opt_name]
         end
      end
   end

   return res
end

local function anchor_pattern(pattern, only_start)
   if not pattern then
      return
   end

   if pattern:sub(1, 1) == "^" or pattern:sub(-1) == "$" then
      return pattern
   else
      return "^" .. pattern .. (only_start and "" or "$")
   end
end

-- Returns {pair of normalized patterns for code and name}.
-- \`pattern\` can be:
--    string containing '/': first part matches warning code, second - variable name;
--    string containing letters: matches variable name;
--    otherwise: matches warning code.
-- Unless anchored by user, pattern for name is anchored from both sides
-- and pattern for code is only anchored at the beginning.
local function normalize_pattern(pattern)
   local code_pattern, name_pattern
   local slash_pos = pattern:find("/")

   if slash_pos then
      code_pattern = pattern:sub(1, slash_pos - 1)
      name_pattern = pattern:sub(slash_pos + 1)
   elseif pattern:find("[_a-zA-Z]") then
      name_pattern = pattern
   else
      code_pattern = pattern
   end

   return {anchor_pattern(code_pattern, true), anchor_pattern(name_pattern)}
end

-- From most specific to less specific, pairs {option, pattern}.
-- Applying macros in order is required to get deterministic results
-- and get sensible results when intersecting macros are used.
-- E.g. unused = false, unused_args = true should leave unused args enabled.
local macros = {
   {"unused_args", "21[23]"},
   {"global", "1"},
   {"unused", "[23]"},
   {"redefined", "4"}
}

-- Returns array of rules which should be applied in order.
-- A rule is a table {{pattern*}, type}.
-- \`pattern\` is a non-normalized pattern.
-- \`type\` can be "enable", "disable" or "only".
local function get_rules(opts_stack)
   local rules = {}
   local used_macros = {}

   for _, opts in utils.ripairs(opts_stack) do
      for _, macro_info in ipairs(macros) do
         local option, pattern = macro_info[1], macro_info[2]

         if not used_macros[option] then
            if opts[option] ~= nil then
               table.insert(rules, {{pattern}, opts[option] and "enable" or "disable"})
               used_macros[option] = true
            end
         end
      end

      if opts.ignore then
         table.insert(rules, {opts.ignore, "disable"})
      end

      if opts.only then
         table.insert(rules, {opts.only, "only"})
      end

      if opts.enable then
         table.insert(rules, {opts.enable, "enable"})
      end
   end

   return rules
end

local function normalize_patterns(rules)
   local res = {}

   for i, rule in ipairs(rules) do
      res[i] = {{}, rule[2]}

      for j, pattern in ipairs(rule[1]) do
         res[i][1][j] = normalize_pattern(pattern)
      end
   end

   return res
end

local scalar_options = {
   unused_secondaries = true,
   self = true,
   module = false,
   allow_defined = false,
   allow_defined_top = false,
   max_cyclomatic_complexity = false
}

-- Returns normalized options.
-- Normalized options have fields:
--    std: normalized std table, see \`luacheck.standards\` module;
--    unused_secondaries, self, module, allow_defined, allow_defined_top: booleans;
--    max_line_length: number or false;
--    rules: see get_rules.
function options.normalize(opts_stack, stds)
   local res = {}
   stds = stds or builtin_standards
   res.std = get_final_std(opts_stack, stds)

   for option, default in pairs(scalar_options) do
      res[option] = get_scalar_opt(opts_stack, option, default)
   end

   local max_line_opts = get_max_line_opts(opts_stack)
   utils.update(res, max_line_opts)
   res.rules = normalize_patterns(get_rules(opts_stack))

   return res
end

return options

end)
__bundle_register("luacheck.standards", function(require, _LOADED, __bundle_register, __bundle_modules)
local standards = {}

-- A standard (aka std) defines set of allowed globals, their fields,
-- and whether they are mutable.
--
-- A standard can be in several formats. Internal (normalized) format
-- is a tree. Each node defines a global or its field. Each node may have
-- boolean \`read_only\` and \`other_fields\`, and may contain definitions
-- of nested fields in \`fields\` subtable, which maps field names
-- to definition tables. For example, standard defining globals
-- of some Lua version may start like this:
-- {
--    -- Most globals are read-only by default.
--    read_only = true,
--    fields = {
--       -- The tree can't be recursive, just allow everything for \`_G\`.
--       _G = {other_fields = true, read_only = false},
--       package = {
--          fields = {
--             -- \`other_fields\` is false by default, so that an empty table
--             -- defines a field that can't be indexed further (a function in this case).
--             loadlib = {},
--             -- Allow doing everything with \`package.loaded\`.
--             loaded = {other_fields = true, read_only = false},
--             -- More fields here...
--          }
--       },
--       -- More globals here...
--    }
-- }
--
-- A similar format is used to define standards in table form
-- in config. There are two differences:
-- first, top level table can have two fields, \`globals\` and \`read_globals\`,
-- that map global names to definition tables. Default value of \`read_only\` field
-- for the these tables depends on which table they come from (\`true\` for \`read_globals\`
-- and \`false\` for \`globals\`). Additionally, all tables that map field or global names
-- to definition tables may have non-string keys, their associated values are interpreted
-- as names instead and their definition table allows indexing with any keys indefinitely.
-- E.g. \`{fields = {"foo"}}\` is equivalent to \`{fields = {foo = {other_fields = true}}}\`.
-- This feature makes it easier to create less strict standards that do not care about fields,
-- to ease migration from the old format.
--
-- Additionally, there are some predefined named standards in \`luacheck.builtin_standards\` module.
-- In config and inline options its possible to use their names as strings to refer to them.

-- Validates an optional table mapping field names to field definitions or non-string keys to names.
-- \`index\` is an optional string specifying position of the field table in the root table.
-- Returns a true if the table is valid, false, an error message, and index of the table with the error otherwise.
local function validate_fields(fields, is_root, index)
   if fields == nil then
      return true
   end

   local field_type = is_root and "global" or "field"

   if type(fields) ~= "table" then
      return false, ("%ss table expected, got %s"):format(field_type, type(fields)), index
   end

   for key, value in pairs(fields) do
      if type(key) == "string" then
         local new_index = (index or "") .. "." .. key

         if type(value) ~= "table" then
            return false, ("%s description table expected, got %s"):format(field_type, type(value)), new_index
         end

         if value.read_only ~= nil and type(value.read_only) ~= "boolean" then
            local err = "invalid value of option 'read_only': boolean expected, got " .. type(value.read_only)
            return false, err, new_index
         end

         if value.other_fields ~= nil and type(value.other_fields) ~= "boolean" then
            local err = "invalid value of option 'other_fields': boolean expected, got " .. type(value.other_fields)
            return false, err, new_index
         end

         local ok, err, err_index = validate_fields(value.fields, false, new_index .. ".fields")

         if not ok then
            return false, err, err_index
         end
      elseif type(value) ~= "string" then
         local key_as_string = type(key) == "number" and ("%.20g"):format(key) or ("<%s>"):format(type(key))
         local new_index = ("%s[%s]"):format(index or "", key_as_string)
         return false, ("string expected as %s name, got %s"):format(field_type, type(value)), new_index
      end
   end

   return true
end

-- Validates a field table.
-- Returns true if the table is valid, false and an error message otherwise.
function standards.validate_globals_table(globals_table)
   local ok, err, err_index = validate_fields(globals_table, true)

   if ok then
      return true
   end

   local err_prefix = err_index and ("in field %s: "):format(err_index) or ""
   return false, err_prefix .. err
end

-- Validates an std table in user-side format.
-- Returns true if the table is valid, false and an error message otherwise.
function standards.validate_std_table(std_table)
   local ok, err, err_index = validate_fields(std_table.globals, true, ".globals")

   if ok then
      ok, err, err_index = validate_fields(std_table.read_globals, true, ".read_globals")
   end

   if ok then
      return true
   end

   local err_prefix = ("in field %s: "):format(err_index)
   return false, err_prefix .. err
end

local infinitely_indexable_def = {other_fields = true}

local function add_fields(def, fields, overwrite, ignore_array_part, default_read_only)
   if not fields then
      return
   end

   for field_name, field_def in pairs(fields) do
      if type(field_name) == "string" or not ignore_array_part then
         if type(field_name) ~= "string" then
            field_name = field_def
            field_def = infinitely_indexable_def
         end

         if not def.fields then
            def.fields = {}
         end

         if not def.fields[field_name] then
            def.fields[field_name] = {}
         end

         local existing_field_def = def.fields[field_name]
         local new_read_only = field_def.read_only

         if new_read_only == nil then
            new_read_only = default_read_only
         end

         if new_read_only ~= nil then
            if overwrite or new_read_only == false then
               existing_field_def.read_only = new_read_only
            end
         end

         if field_def.other_fields ~= nil then
            if overwrite or field_def.other_fields == true then
               existing_field_def.other_fields = field_def.other_fields
            end
         end

         add_fields(existing_field_def, field_def.fields, overwrite, false, nil)
      end
   end
end

-- Merges in an std table in user-side format.
-- By default the new state of normalized std is a union of the standard tables being merged,
-- e.g. if either table allows some field to be mutated, result should allow it, too.
-- If \`overwrite\` is truthy, read-only statuses from the new std table overwrite existing values.
-- If \`ignore_top_array_part\` is truthy, non-string keys in \`globals\` and \`read_globals\` tables
-- in \`std_table\` are not processed.
function standards.add_std_table(final_std, std_table, overwrite, ignore_top_array_part)
   add_fields(final_std, std_table.globals, overwrite, ignore_top_array_part, false)
   add_fields(final_std, std_table.read_globals, overwrite, ignore_top_array_part, true)
end

-- Overwrites or adds definition of a field with given read-only status and any nested keys.
-- Field is specified as an array of field names.
function standards.overwrite_field(final_std, field_names, read_only)
   local field_def = final_std

   for _, field_name in ipairs(field_names) do
      if not field_def.fields then
         field_def.fields = {}
      end

      if not field_def.fields[field_name] then
         field_def.fields[field_name] = {read_only = read_only}
      end

      field_def = field_def.fields[field_name]
   end

   for key in pairs(field_def) do
      field_def[key] = nil
   end

   field_def.read_only = read_only
   field_def.other_fields = true
end

-- Removes definition of a field from a normalized std table.
-- Field is specified as an array of field names.
function standards.remove_field(final_std, field_names)
   local field_def = final_std
   local parent_def

   for _, field_name in ipairs(field_names) do
      parent_def = field_def

      if not field_def.fields or not field_def.fields[field_name] then
         -- The field wasn't defined in the first place.
         return
      end

      field_def = field_def.fields[field_name]
   end

   if parent_def then
      parent_def.fields[field_names[#field_names]] = nil
   end
end

local function infer_deep_read_only_statuses(def, read_only)
   local deep_read_only = not def.other_fields or read_only

   if def.fields then
      for _, field_def in pairs(def.fields) do
         local field_read_only = read_only

         if field_def.read_only ~= nil then
            field_read_only = field_def.read_only
         end

         infer_deep_read_only_statuses(field_def, field_read_only)
         deep_read_only = deep_read_only and field_read_only and field_def.deep_read_only
      end
   end

   if deep_read_only then
      def.deep_read_only = true
   end
end

-- Finishes building a normalized std tables.
-- Adds \`deep_read_only\` fields with \`true\` value to definition tables
-- that do not have any writable fields, recursively.
function standards.finalize(final_std)
   infer_deep_read_only_statuses(final_std, true)
end

local empty = {}

-- Returns a definition table containing empty fields with given names.
function standards.def_fields(...)
   local fields = {}

   for _, field in ipairs({...}) do
      fields[field] = empty
   end

   return {fields = fields}
end

return standards

end)
__bundle_register("luacheck.builtin_standards.init", function(require, _LOADED, __bundle_register, __bundle_modules)
local love = require("luacheck.builtin_standards.love")
local ngx = require("luacheck.builtin_standards.ngx")
local standards = require("luacheck.standards")

local builtin_standards = {}

local function def_to_std(def)
   return {read_globals = def.fields}
end

local function add_defs(...)
   local res = {}

   for _, def in ipairs({...}) do
      standards.add_std_table(res, def_to_std(def))
   end

   return res
end

local empty = {}

local string_defs = {}

string_defs.min = standards.def_fields("byte", "char", "dump", "find", "format", "gmatch",
   "gsub", "len", "lower", "match", "rep", "reverse", "sub", "upper")

string_defs.lua51 = add_defs(string_defs.min, standards.def_fields("gfind"))
string_defs.lua52 = string_defs.min
string_defs.lua53 = add_defs(string_defs.min, standards.def_fields("pack", "packsize", "unpack"))
string_defs.luajit = string_defs.lua51

local file_defs = {}

file_defs.min = {
   fields = {
      __gc = empty,
      __index = {other_fields = true},
      __tostring = empty,
      close = empty,
      flush = empty,
      lines = empty,
      read = empty,
      seek = empty,
      setvbuf = empty,
      write = empty
   }
}

file_defs.lua51 = file_defs.min
file_defs.lua52 = file_defs.min
file_defs.lua53 = add_defs(file_defs.min, {fields = {__name = string_defs.lua53}})
file_defs.luajit = file_defs.min

local function make_min_def(method_defs)
   local string_def = string_defs[method_defs]
   local file_def = file_defs[method_defs]

   return {
      fields = {
         _G = {other_fields = true, read_only = false},
         _VERSION = string_def,
         arg = {other_fields = true},
         assert = empty,
         collectgarbage = empty,
         coroutine = standards.def_fields("create", "resume", "running", "status", "wrap", "yield"),
         debug = standards.def_fields("debug", "gethook", "getinfo", "getlocal", "getmetatable", "getregistry",
            "getupvalue", "sethook", "setlocal", "setmetatable", "setupvalue", "traceback"),
         dofile = empty,
         error = empty,
         getmetatable = empty,
         io = {
            fields = {
               close = empty,
               flush = empty,
               input = empty,
               lines = empty,
               open = empty,
               output = empty,
               popen = empty,
               read = empty,
               stderr = file_def,
               stdin = file_def,
               stdout = file_def,
               tmpfile = empty,
               type = empty,
               write = empty
            }
         },
         ipairs = empty,
         load = empty,
         loadfile = empty,
         math = standards.def_fields("abs", "acos", "asin", "atan", "ceil", "cos",
            "deg", "exp", "floor", "fmod", "huge", "log",
            "max", "min", "modf", "pi", "rad", "random", "randomseed",
            "sin", "sqrt", "tan"),
         next = empty,
         os = standards.def_fields("clock", "date", "difftime", "execute", "exit", "getenv",
            "remove", "rename", "setlocale", "time", "tmpname"),
         package = {
            fields = {
               config = string_def,
               cpath = {fields = string_def.fields, read_only = false},
               loaded = {other_fields = true, read_only = false},
               loadlib = empty,
               path = {fields = string_def.fields, read_only = false},
               preload = {other_fields = true, read_only = false}
            }
         },
         pairs = empty,
         pcall = empty,
         print = empty,
         rawequal = empty,
         rawget = empty,
         rawset = empty,
         require = empty,
         select = empty,
         setmetatable = empty,
         string = string_def,
         table = standards.def_fields("concat", "insert", "remove", "sort"),
         tonumber = empty,
         tostring = empty,
         type = empty,
         xpcall = empty
      }
   }
end

local bit32_def = standards.def_fields("arshift", "band", "bnot", "bor", "btest", "bxor", "extract",
   "lrotate", "lshift", "replace", "rrotate", "rshift")

local lua_defs = {}

lua_defs.min = make_min_def("min")
lua_defs.lua51 = add_defs(make_min_def("lua52"), {
   fields = {
      debug = standards.def_fields("getfenv", "setfenv"),
      getfenv = empty,
      loadstring = empty,
      math = standards.def_fields("atan2", "cosh", "frexp", "ldexp", "log10", "pow", "sinh", "tanh"),
      module = empty,
      newproxy = empty,
      package = {
         fields = {
            loaders = {other_fields = true, read_only = false},
            seeall = empty
         }
      },
      setfenv = empty,
      table = standards.def_fields("maxn"),
      unpack = empty
   }
})
lua_defs.lua51c = add_defs(lua_defs.lua51, make_min_def("lua51"), {
   fields = {
      gcinfo = empty,
      math = standards.def_fields("mod"),
      table = standards.def_fields("foreach", "foreachi", "getn", "setn")
   }
})
lua_defs.lua52 = add_defs(make_min_def("lua52"), {
   fields = {
      _ENV = {other_fields = true, read_only = false},
      bit32 = bit32_def,
      debug = standards.def_fields("getuservalue", "setuservalue", "upvalueid", "upvaluejoin"),
      math = standards.def_fields("atan2", "cosh", "frexp", "ldexp", "pow", "sinh", "tanh"),
      package = {
         fields = {
            searchers = {other_fields = true, read_only = false},
            searchpath = empty
         }
      },
      rawlen = empty,
      table = standards.def_fields("pack", "unpack")
   }
})
lua_defs.lua52c = add_defs(lua_defs.lua52, {
   fields = {
      loadstring = empty,
      math = standards.def_fields("log10"),
      module = empty,
      package = {
         fields = {
            loaders = {other_fields = true, read_only = false},
            seeall = empty
         }
      },
      table = standards.def_fields("maxn"),
      unpack = empty
   }
})
lua_defs.lua53 = add_defs(make_min_def("lua53"), {
   fields = {
      _ENV = {other_fields = true, read_only = false},
      coroutine = standards.def_fields("isyieldable"),
      debug = standards.def_fields("getuservalue", "setuservalue", "upvalueid", "upvaluejoin"),
      math = standards.def_fields("maxinteger", "mininteger", "tointeger", "type", "ult"),
      package = {
         fields = {
            searchers = {other_fields = true, read_only = false},
            searchpath = empty
         }
      },
      rawlen = empty,
      table = standards.def_fields("move", "pack", "unpack"),
      utf8 = {
         fields = {
            char = empty,
            charpattern = string_defs.lua53,
            codepoint = empty,
            codes = empty,
            len = empty,
            offset = empty
         }
      }
   }
})
lua_defs.lua53c = add_defs(lua_defs.lua53, {
   fields = {
      bit32 = bit32_def,
      math = standards.def_fields("atan2", "cosh", "frexp", "ldexp", "log10", "pow", "sinh", "tanh")
   }
})
lua_defs.luajit = add_defs(make_min_def("luajit"), {
   fields = {
      bit = standards.def_fields("arshift", "band", "bnot", "bor", "bswap", "bxor", "lshift", "rol", "ror",
         "rshift", "tobit", "tohex"),
      coroutine = standards.def_fields("isyieldable"),
      debug = standards.def_fields("getfenv", "setfenv", "upvalueid", "upvaluejoin"),
      gcinfo = empty,
      getfenv = empty,
      jit = {other_fields = true},
      loadstring = empty,
      math = standards.def_fields("atan2", "cosh", "frexp", "ldexp", "log10", "mod", "pow", "sinh", "tanh"),
      module = empty,
      newproxy = empty,
      package = {
         fields = {
            loaders = {other_fields = true, read_only = false},
            searchpath = empty,
            seeall = empty
         }
      },
      setfenv = empty,
      table = standards.def_fields("clear", "foreach", "foreachi", "getn", "maxn", "move", "new"),
      unpack = empty
   }
})
lua_defs.ngx_lua = add_defs(lua_defs.luajit, ngx)
lua_defs.max = add_defs(lua_defs.lua51c, lua_defs.lua52c, lua_defs.lua53c, lua_defs.luajit)

for name, def in pairs(lua_defs) do
   builtin_standards[name] = def_to_std(def)
end

local function get_running_lua_std_name()
   if rawget(_G, "jit") then
      return "luajit"
   elseif _VERSION == "Lua 5.1" then
      return "lua51c"
   elseif _VERSION == "Lua 5.2" then
      return "lua52c"
   elseif _VERSION == "Lua 5.3" then
      return "lua53c"
   else
      return "max"
   end
end

builtin_standards._G = builtin_standards[get_running_lua_std_name()]

builtin_standards.busted = {
   read_globals = {
      "describe", "insulate", "expose", "it", "pending", "before_each", "after_each",
      "lazy_setup", "lazy_teardown", "strict_setup", "strict_teardown", "setup", "teardown",
      "context", "spec", "test", "assert", "spy", "mock", "stub", "finally", "randomize"
   }
}

builtin_standards.love = love

builtin_standards.rockspec = {
   globals = {
      "rockspec_format", "package", "version", "description", "dependencies", "supported_platforms",
      "external_dependencies", "source", "build", "hooks", "deploy", "build_dependencies", "test_dependencies", "test"
   }
}

builtin_standards.luacheckrc = {
   globals = {
      "global", "unused", "redefined", "unused_args", "unused_secondaries", "self", "compat", "allow_defined",
      "allow_defined_top", "module", "globals", "read_globals", "new_globals", "new_read_globals", "not_globals",
      "ignore", "enable", "only", "std", "max_line_length", "max_code_line_length", "max_string_line_length",
      "max_comment_line_length", "max_cyclomatic_complexity", "quiet", "color", "codes", "ranges", "formatter",
      "cache", "jobs", "files", "stds", "exclude_files", "include_files"
   }
}

builtin_standards.none = {}

return builtin_standards

end)
__bundle_register("luacheck.builtin_standards.ngx", function(require, _LOADED, __bundle_register, __bundle_modules)
local standards = require("luacheck.standards")

local empty = {}

local luajit_string_def = standards.def_fields("byte", "char", "dump", "find", "format", "gmatch",
   "gsub", "len", "lower", "match", "rep", "reverse", "sub", "upper")

-- Globals added by lua-nginx-module 0.10.10 in internal definition table format.
-- Will be added to \`luajit\` std to form \`ngx_lua\` std.
local ngx_defs = {
   fields = {
      ngx = {
         fields = {
            arg = {other_fields = true, read_only = false},
            var = {other_fields = true, read_only = false},
            OK = empty,
            ERROR = empty,
            AGAIN = empty,
            DONE = empty,
            DECLINED = empty,
            null = empty,
            HTTP_GET = empty,
            HTTP_HEAD = empty,
            HTTP_PUT = empty,
            HTTP_POST = empty,
            HTTP_DELETE = empty,
            HTTP_OPTIONS = empty,
            HTTP_MKCOL = empty,
            HTTP_COPY = empty,
            HTTP_MOVE = empty,
            HTTP_PROPFIND = empty,
            HTTP_PROPPATCH = empty,
            HTTP_LOCK = empty,
            HTTP_UNLOCK = empty,
            HTTP_PATCH = empty,
            HTTP_TRACE = empty,
            HTTP_CONTINUE = empty,
            HTTP_SWITCHING_PROTOCOLS = empty,
            HTTP_OK = empty,
            HTTP_CREATED = empty,
            HTTP_ACCEPTED = empty,
            HTTP_NO_CONTENT = empty,
            HTTP_PARTIAL_CONTENT = empty,
            HTTP_SPECIAL_RESPONSE = empty,
            HTTP_MOVED_PERMANENTLY = empty,
            HTTP_MOVED_TEMPORARILY = empty,
            HTTP_SEE_OTHER = empty,
            HTTP_NOT_MODIFIED = empty,
            HTTP_TEMPORARY_REDIRECT = empty,
            HTTP_BAD_REQUEST = empty,
            HTTP_UNAUTHORIZED = empty,
            HTTP_PAYMENT_REQUIRED = empty,
            HTTP_FORBIDDEN = empty,
            HTTP_NOT_FOUND = empty,
            HTTP_NOT_ALLOWED = empty,
            HTTP_NOT_ACCEPTABLE = empty,
            HTTP_REQUEST_TIMEOUT = empty,
            HTTP_CONFLICT = empty,
            HTTP_GONE = empty,
            HTTP_UPGRADE_REQUIRED = empty,
            HTTP_TOO_MANY_REQUESTS = empty,
            HTTP_CLOSE = empty,
            HTTP_ILLEGAL = empty,
            HTTP_INTERNAL_SERVER_ERROR = empty,
            HTTP_METHOD_NOT_IMPLEMENTED = empty,
            HTTP_BAD_GATEWAY = empty,
            HTTP_SERVICE_UNAVAILABLE = empty,
            HTTP_GATEWAY_TIMEOUT = empty,
            HTTP_VERSION_NOT_SUPPORTED = empty,
            HTTP_INSUFFICIENT_STORAGE = empty,
            STDERR = empty,
            EMERG = empty,
            ALERT = empty,
            CRIT = empty,
            ERR = empty,
            WARN = empty,
            NOTICE = empty,
            INFO = empty,
            DEBUG = empty,
            ctx = {other_fields = true, read_only = false},
            location = standards.def_fields("capture", "capture_multi"),
            status = {read_only = false},
            header = {other_fields = true, read_only = false},
            resp = standards.def_fields("get_headers"),
            req = standards.def_fields("is_internal", "start_time", "http_version", "raw_header",
               "get_method", "set_method", "set_uri", "set_uri_args", "get_uri_args",
               "get_post_args", "get_headers", "set_header", "clear_header", "read_body",
               "discard_body", "get_body_data", "get_body_file", "set_body_data",
               "set_body_file", "init_body", "append_body", "finish_body", "socket"),
            exec = empty,
            redirect = empty,
            send_headers = empty,
            headers_sent = empty,
            print = empty,
            say = empty,
            log = empty,
            flush = empty,
            exit = empty,
            eof = empty,
            sleep = empty,
            escape_uri = empty,
            unescape_uri = empty,
            encode_args = empty,
            decode_args = empty,
            encode_base64 = empty,
            decode_base64 = empty,
            crc32_short = empty,
            crc32_long = empty,
            hmac_sha1 = empty,
            md5 = empty,
            md5_bin = empty,
            sha1_bin = empty,
            quote_sql_str = empty,
            today = empty,
            time = empty,
            now = empty,
            update_time = empty,
            localtime = empty,
            utctime = empty,
            cookie_time = empty,
            http_time = empty,
            parse_http_time = empty,
            is_subrequest = empty,
            re = standards.def_fields("match", "find", "gmatch", "sub", "gsub"),
            shared = {other_fields = true, read_only = false},
            socket = standards.def_fields("udp", "tcp", "connect", "stream"),
            get_phase = empty,
            thread = standards.def_fields("spawn", "wait", "kill"),
            on_abort = empty,
            timer = standards.def_fields("at", "every", "running_count", "pending_count"),
            config = {
               fields = {
                  subsystem = luajit_string_def,
                  debug = empty,
                  prefix = empty,
                  nginx_version = empty,
                  nginx_configure = empty,
                  ngx_lua_version = empty,
               }
            },
            worker = standards.def_fields("pid", "count", "id", "exiting"),
         },
      },
      ndk = {
         fields = {
            set_var = {other_fields = true},
         },
      },
   },
}

return ngx_defs

end)
__bundle_register("luacheck.builtin_standards.love", function(require, _LOADED, __bundle_register, __bundle_modules)
local standards = require("luacheck.standards")

local empty = {}
local read_write = {read_only = false}

local love = {
   fields = {
      getVersion = empty,
      conf = read_write,
      directorydropped = read_write,
      draw = read_write,
      errhand = read_write,
      errorhandler = read_write,
      filedropped = read_write,
      focus = read_write,
      gamepadaxis = read_write,
      gamepadpressed = read_write,
      gamepadreleased = read_write,
      handlers = read_write,
      hasDeprecationOutput = empty,
      joystickadded = read_write,
      joystickaxis = read_write,
      joystickhat = read_write,
      joystickpressed = read_write,
      joystickreleased = read_write,
      joystickremoved = read_write,
      keypressed = read_write,
      keyreleased = read_write,
      load = read_write,
      lowmemory = read_write,
      mousefocus = read_write,
      mousemoved = read_write,
      mousepressed = read_write,
      mousereleased = read_write,
      quit = read_write,
      resize = read_write,
      run = read_write,
      setDeprecationOutput = empty,
      textedited = read_write,
      textinput = read_write,
      threaderror = read_write,
      touchmoved = read_write,
      touchpressed = read_write,
      touchreleased = read_write,
      update = read_write,
      visible = read_write,
      wheelmoved = read_write,

      audio = standards.def_fields("getDistanceModel","getDopplerScale","getSourceCount","getOrientation",
         "getPosition","getVelocity","getVolume","newSource","pause","play","setDistanceModel","setDopplerScale",
         "setOrientation","setPosition","setVelocity", "setVolume","stop","getActiveSourceCount","getRecordingDevices",
         "newQueueableSource","setEffect","getActiveEffects","getEffect","getMaxSceneEffects","getMaxSourceEffects",
         "isEffectsSupported","setMixWithSystem"),

      data = standards.def_fields("compress","decode","decompress","encode","getPackedSize","hash","newByteData",
         "newDataView","pack","unpack"),

      event = standards.def_fields("clear","poll","pump","push","quit","wait"),

      filesystem = standards.def_fields("append","areSymlinksEnabled","createDirectory","exists",
         "getAppdataDirectory","getDirectoryItems","getIdentity","getLastModified",
         "getRealDirectory","getRequirePath","getSaveDirectory","getSize","getSource",
         "getSourceBaseDirectory","getUserDirectory","getWorkingDirectory","init","isDirectory",
         "isFile","isFused","isSymlink","lines","load","mount","newFile","newFileData","read",
         "remove","setIdentity","setRequirePath","setSource","setSymlinksEnabled","unmount","write",
         "getInfo","setCRequirePath","getCRequirePath"),

      font = standards.def_fields("newImageRasterizer", "newGlyphData", "newTrueTypeRasterizer",
         "newBMFontRasterizer", "newRasterizer"),

      graphics = standards.def_fields("arc","circle","clear","discard","draw","ellipse","getBackgroundColor",
         "getBlendMode","getCanvas","getCanvasFormats","getColor","getColorMask",
         "getDefaultFilter","getDimensions","getFont","getHeight",
         "getLineJoin","getLineStyle","getLineWidth","getShader","getStats","getStencilTest",
         "getSupported","getSystemLimits","getPointSize","getRendererInfo","getScissor","getWidth",
         "intersectScissor","isGammaCorrect","isWireframe","line","newCanvas","newFont","newMesh",
         "newImage","newImageFont","newParticleSystem","newShader","newText","newQuad",
         "newSpriteBatch","newVideo","origin","points","polygon","pop","present",
         "print","printf","push","rectangle","reset","rotate","scale","setBackgroundColor",
         "setBlendMode","setCanvas","setColor","setColorMask","setDefaultFilter","setFont",
         "setLineJoin","setLineStyle","setLineWidth","setNewFont","setShader","setPointSize",
         "setScissor","setStencilTest","setWireframe","shear","stencil","translate",
         "captureScreenshot","getImageFormats","newArrayImage","newVolumeImage","newCubeImage",
         "getTextureTypes","drawLayer","setDepthMode","setMeshCullMode","setFrontFaceWinding",
         "applyTransform","replaceTransform","transformPoint","inverseTransformPoint","getStackDepth",
         "flushBatch","validateShader","drawInstanced","getDepthMode","getFrontFaceWinding","getMeshCullMode",
         "getDPIScale","getPixelDimensions","getPixelHeight","getPixelWidth","isActive","getDefaultMipmapFilter",
         "setDefaultMipmapFilter"),

      image = standards.def_fields("isCompressed","newCompressedData","newImageData","newCubeFaces"),

      joystick = standards.def_fields("getJoystickCount","getJoysticks","loadGamepadMappings",
         "saveGamepadMappings","setGamepadMapping"),

      keyboard = standards.def_fields("getKeyFromScancode","getScancodeFromKey","hasKeyRepeat","hasTextInput",
         "isDown","isScancodeDown","setKeyRepeat","setTextInput","hasScreenKeyboard"),

      math = standards.def_fields("compress","decompress","gammaToLinear","getRandomSeed","getRandomState",
         "isConvex","linearToGamma","newBezierCurve","newRandomGenerator","noise","random",
         "randomNormal","setRandomSeed","setRandomState","triangulate","newTransform"),

      mouse = standards.def_fields("getCursor","getPosition","getRelativeMode","getSystemCursor","getX",
         "getY","hasCursor","isDown","isGrabbed","isVisible","newCursor","setCursor","setGrabbed",
         "setPosition","setRelativeMode","setVisible","setX","setY","isCursorSupported"),

      physics = standards.def_fields("getDistance","getMeter","newBody","newChainShape","newCircleShape",
         "newDistanceJoint","newEdgeShape","newFixture","newFrictionJoint","newGearJoint",
         "newMotorJoint","newMouseJoint","newPolygonShape","newPrismaticJoint","newPulleyJoint",
         "newRectangleShape","newRevoluteJoint","newRopeJoint","newWeldJoint","newWheelJoint",
         "newWorld","setMeter"),

      sound = standards.def_fields("newDecoder","newSoundData"),

      system = standards.def_fields("getClipboardText","getOS","getPowerInfo","getProcessorCount","openURL",
         "setClipboardText","vibrate","hasBackgroundMusic"),

      thread = standards.def_fields("getChannel","newChannel","newThread"),

      timer = standards.def_fields("getAverageDelta","getDelta","getFPS","getTime","sleep","step"),

      touch = standards.def_fields("getPosition","getPressure","getTouches"),

      video = standards.def_fields("newVideoStream"),

      window = standards.def_fields("close","fromPixels","getDisplayName","getFullscreen",
         "getFullscreenModes","getIcon","getMode","getPixelScale","getPosition","getTitle",
         "hasFocus","hasMouseFocus","isDisplaySleepEnabled","isMaximized","isOpen","isVisible",
         "maximize","minimize","requestAttention","setDisplaySleepEnabled","setFullscreen",
         "setIcon","setMode","setPosition","setTitle","showMessageBox","toPixels",
         "updateMode","isMinimized","restore","getDPIScale")
   }
}

-- \`love\` standard contains only \`love\` global, so return it here directly using normal std format.
return {
   read_globals = {love = love}
}

end)
__bundle_register("luacheck.stages.linearize", function(require, _LOADED, __bundle_register, __bundle_modules)
local parser = require("luacheck.parser")
local utils = require("luacheck.utils")

local stage = {}

local function redefined_warning(message_format)
   return {
      message_format = message_format,
      fields = {"name", "prev_line", "prev_column", "prev_end_column", "self"}
   }
end

stage.warnings = {
   ["411"] = redefined_warning("variable {name!} was previously defined on line {prev_line}"),
   ["412"] = redefined_warning("variable {name!} was previously defined as an argument on line {prev_line}"),
   ["413"] = redefined_warning("variable {name!} was previously defined as a loop variable on line {prev_line}"),
   ["421"] = redefined_warning("shadowing definition of variable {name!} on line {prev_line}"),
   ["422"] = redefined_warning("shadowing definition of argument {name!} on line {prev_line}"),
   ["423"] = redefined_warning("shadowing definition of loop variable {name!} on line {prev_line}"),
   ["431"] = redefined_warning("shadowing upvalue {name!} on line {prev_line}"),
   ["432"] = redefined_warning("shadowing upvalue argument {name!} on line {prev_line}"),
   ["433"] = redefined_warning("shadowing upvalue loop variable {name!} on line {prev_line}"),
   ["521"] = {message_format = "unused label {label!}", fields = {"label"}}
}

local type_codes = {
   var = "1",
   func = "1",
   arg = "2",
   loop = "3",
   loopi = "3"
}

local function warn_redefined(chstate, var, prev_var, is_same_scope)
   local code = "4" .. (is_same_scope and "1" or var.line == prev_var.line and "2" or "3") .. type_codes[prev_var.type]

   chstate:warn_var(code, var, {
      self = var.self and prev_var.self,
      prev_line = prev_var.node.line,
      prev_column = chstate:offset_to_column(prev_var.node.line, prev_var.node.offset),
      prev_end_column = chstate:offset_to_column(prev_var.node.line, prev_var.node.end_offset)
   })
end

local function warn_unused_label(chstate, label)
   chstate:warn_range("521", label.range, {
      label = label.name
   })
end

local pseudo_labels = utils.array_to_set({"do", "else", "break", "end", "return"})

local Line = utils.class()

function Line:__init(node, parent, value)
   -- Maps variables to arrays of accessing items.
   self.accessed_upvalues = {}
   -- Maps variables to arrays of mutating items.
   self.mutated_upvalues = {}
   -- Maps variables to arays of setting items.
   self.set_upvalues = {}
   self.lines = {}
   self.node = node
   self.parent = parent
   self.value = value
   self.items = utils.Stack()
end

-- Calls callback with line, index, item, ... for each item reachable from starting item.
-- \`visited\` is a set of already visited indexes.
-- Callback can return true to stop walking from current item.
function Line:walk(visited, index, callback, ...)
   if visited[index] then
      return
   end

   visited[index] = true

   local item = self.items[index]

   if callback(self, index, item, ...) then
      return
   end

   if not item then
      return
   elseif item.tag == "Jump" then
      return self:walk(visited, item.to, callback, ...)
   elseif item.tag == "Cjump" then
      self:walk(visited, item.to, callback, ...)
   end

   return self:walk(visited, index + 1, callback, ...)
end

local function new_scope(line)
   return {
      vars = {},
      labels = {},
      gotos = {},
      line = line
   }
end

local function new_var(line, node, type_)
   return {
      name = node[1],
      node = node,
      type = type_,
      self = node.implicit,
      line = line,
      scope_start = line.items.size + 1,
      values = {}
   }
end

local function new_value(var_node, value_node, item, is_init)
   local value = {
      var = var_node.var,
      var_node = var_node,
      type = is_init and var_node.var.type or "var",
      node = value_node,
      using_lines = {},
      empty = is_init and not value_node and (var_node.var.type == "var"),
      item = item
   }

   if value_node and value_node.tag == "Function" then
      value.type = "func"
      value_node.value = value
   end

   return value
end

local function new_label(line, name, range)
   return {
      name = name,
      range = range,
      index = line.items.size + 1
   }
end

local function new_goto(name, jump, range)
   return {
      name = name,
      jump = jump,
      range = range
   }
end

local function new_jump_item(is_conditional)
   return {
      tag = is_conditional and "Cjump" or "Jump"
   }
end

local function new_eval_item(node)
   return {
      tag = "Eval",
      node = node,
      accesses = {},
      used_values = {},
      lines = {}
   }
end

local function new_noop_item(node, loop_end)
   return {
      tag = "Noop",
      node = node,
      loop_end = loop_end
   }
end

local function new_local_item(node)
   return {
      tag = "Local",
      node = node,
      lhs = node[1],
      rhs = node[2],
      accesses = node[2] and {},
      used_values = node[2] and {},
      lines = node[2] and {}
   }
end

local function new_set_item(node)
   return {
      tag = "Set",
      node = node,
      lhs = node[1],
      rhs = node[2],
      accesses = {},
      mutations = {},
      used_values = {},
      lines = {}
   }
end

local function is_unpacking(node)
   return node.tag == "Dots" or node.tag == "Call" or node.tag == "Invoke"
end

local LinState = utils.class()

function LinState:__init(chstate)
   self.chstate = chstate
   self.lines = utils.Stack()
   self.scopes = utils.Stack()
end

function LinState:enter_scope()
   self.scopes:push(new_scope(self.lines.top))
end

function LinState:leave_scope()
   local left_scope = self.scopes:pop()
   local prev_scope = self.scopes.top

   for _, goto_ in ipairs(left_scope.gotos) do
      local label = left_scope.labels[goto_.name]

      if label then
         goto_.jump.to = label.index
         label.used = true
      else
         if not prev_scope or prev_scope.line ~= self.lines.top then
            if goto_.name == "break" then
               parser.syntax_error("'break' is not inside a loop", goto_.range)
            else
               parser.syntax_error(("no visible label '%s'"):format(goto_.name), goto_.range)
            end
         end

         table.insert(prev_scope.gotos, goto_)
      end
   end

   for name, label in pairs(left_scope.labels) do
      if not label.used and not pseudo_labels[name] then
         warn_unused_label(self.chstate, label)
      end
   end

   for _, var in pairs(left_scope.vars) do
      var.scope_end = self.lines.top.items.size
   end
end

function LinState:register_var(node, type_)
   local var = new_var(self.lines.top, node, type_)
   local prev_var = self:resolve_var(var.name)

   if prev_var then
      local is_same_scope = self.scopes.top.vars[var.name]

      if var.name ~= "..." then
         warn_redefined(self.chstate, var, prev_var, is_same_scope)
      end

      if is_same_scope then
         prev_var.scope_end = self.lines.top.items.size
      end
   end

   self.scopes.top.vars[var.name] = var
   node.var = var
   return var
end

function LinState:register_vars(nodes, type_)
   for _, node in ipairs(nodes) do
      self:register_var(node, type_)
   end
end

function LinState:resolve_var(name)
   for _, scope in utils.ripairs(self.scopes) do
      local var = scope.vars[name]

      if var then
         return var
      end
   end
end

function LinState:check_var(node)
   if not node.var then
      node.var = self:resolve_var(node[1])
   end

   return node.var
end

function LinState:register_label(name, range)
   local prev_label = self.scopes.top.labels[name]

   if prev_label then
      assert(not pseudo_labels[name])
      parser.syntax_error(("label '%s' already defined on line %d"):format(
         name, prev_label.range.line), range, prev_label.range)
   end

   self.scopes.top.labels[name] = new_label(self.lines.top, name, range)
end

function LinState:emit(item)
   self.lines.top.items:push(item)
end

function LinState:emit_goto(name, is_conditional, range)
   local jump = new_jump_item(is_conditional)
   self:emit(jump)
   table.insert(self.scopes.top.gotos, new_goto(name, jump, range))
end

local tag_to_boolean = {
   Nil = false, False = false,
   True = true, Number = true, String = true, Table = true, Function = true
}

-- Emits goto that jumps to ::name:: if bool(cond_node) == false.
function LinState:emit_cond_goto(name, cond_node)
   local cond_bool = tag_to_boolean[cond_node.tag]

   if cond_bool ~= true then
      self:emit_goto(name, cond_bool ~= false)
   end
end

function LinState:emit_noop(node, loop_end)
   self:emit(new_noop_item(node, loop_end))
end

function LinState:emit_stmt(stmt)
   self["emit_stmt_" .. stmt.tag](self, stmt)
end

function LinState:emit_stmts(stmts)
   for _, stmt in ipairs(stmts) do
      self:emit_stmt(stmt)
   end
end

function LinState:emit_block(block)
   self:enter_scope()
   self:emit_stmts(block)
   self:leave_scope()
end

function LinState:emit_stmt_Do(node)
   self:emit_noop(node)
   self:emit_block(node)
end

function LinState:emit_stmt_While(node)
   self:emit_noop(node)
   self:enter_scope()
   self:register_label("do")
   self:emit_expr(node[1])
   self:emit_cond_goto("break", node[1])
   self:emit_block(node[2])
   self:emit_noop(node, true)
   self:emit_goto("do")
   self:register_label("break")
   self:leave_scope()
end

function LinState:emit_stmt_Repeat(node)
   self:emit_noop(node)
   self:enter_scope()
   self:register_label("do")
   self:enter_scope()
   self:emit_stmts(node[1])
   self:emit_expr(node[2])
   self:leave_scope()
   self:emit_cond_goto("do", node[2])
   self:register_label("break")
   self:leave_scope()
end

function LinState:emit_stmt_Fornum(node)
   self:emit_noop(node)
   self:emit_expr(node[2])
   self:emit_expr(node[3])

   if node[5] then
      self:emit_expr(node[4])
   end

   self:enter_scope()
   self:register_label("do")
   self:emit_goto("break", true)
   self:enter_scope()
   self:emit(new_local_item({{node[1]}}))
   self:register_var(node[1], "loopi")
   self:emit_stmts(node[5] or node[4])
   self:leave_scope()
   self:emit_noop(node, true)
   self:emit_goto("do")
   self:register_label("break")
   self:leave_scope()
end

function LinState:emit_stmt_Forin(node)
   self:emit_noop(node)
   self:emit_exprs(node[2])
   self:enter_scope()
   self:register_label("do")
   self:emit_goto("break", true)
   self:enter_scope()
   self:emit(new_local_item({node[1]}))
   self:register_vars(node[1], "loop")
   self:emit_stmts(node[3])
   self:leave_scope()
   self:emit_noop(node, true)
   self:emit_goto("do")
   self:register_label("break")
   self:leave_scope()
end

function LinState:emit_stmt_If(node)
   self:emit_noop(node)
   self:enter_scope()

   for i = 1, #node - 1, 2 do
      self:enter_scope()
      self:emit_expr(node[i])
      self:emit_cond_goto("else", node[i])
      self:emit_block(node[i + 1])
      self:emit_goto("end")
      self:register_label("else")
      self:leave_scope()
   end

   if #node % 2 == 1 then
      self:emit_block(node[#node])
   end

   self:register_label("end")
   self:leave_scope()
end

function LinState:emit_stmt_Label(node)
   self:register_label(node[1], node)
end

function LinState:emit_stmt_Goto(node)
   self:emit_noop(node)
   self:emit_goto(node[1], false, node)
end

function LinState:emit_stmt_Break(node)
   self:emit_goto("break", false, node)
end

function LinState:emit_stmt_Return(node)
   self:emit_noop(node)
   self:emit_exprs(node)
   self:emit_goto("return")
end

function LinState:emit_expr(node)
   local item = new_eval_item(node)
   self:scan_expr(item, node)
   self:emit(item)
end

function LinState:emit_exprs(exprs)
   for _, expr in ipairs(exprs) do
      self:emit_expr(expr)
   end
end

LinState.emit_stmt_Call = LinState.emit_expr
LinState.emit_stmt_Invoke = LinState.emit_expr

function LinState:emit_stmt_Local(node)
   local item = new_local_item(node)
   self:emit(item)

   if node[2] then
      self:scan_exprs(item, node[2])
   end

   self:register_vars(node[1], "var")
end

function LinState:emit_stmt_Localrec(node)
   local item = new_local_item(node)
   self:register_var(node[1][1], "var")
   self:emit(item)
   self:scan_expr(item, node[2][1])
end

function LinState:emit_stmt_Set(node)
   local item = new_set_item(node)
   self:scan_exprs(item, node[2])

   for _, expr in ipairs(node[1]) do
      if expr.tag == "Id" then
         local var = self:check_var(expr)

         if var then
            self:register_upvalue_action(item, var, "set_upvalues")
         end
      else
         assert(expr.tag == "Index")
         self:scan_lhs_index(item, expr)
      end
   end

   self:emit(item)
end


function LinState:scan_expr(item, node)
   local scanner = self["scan_expr_" .. node.tag]

   if scanner then
      scanner(self, item, node)
   end
end

function LinState:scan_exprs(item, nodes)
   for _, node in ipairs(nodes) do
      self:scan_expr(item, node)
   end
end

function LinState:register_upvalue_action(item, var, key)
   for _, line in utils.ripairs(self.lines) do
      if line == var.line then
         break
      end

      if not line[key][var] then
         line[key][var] = {}
      end

      table.insert(line[key][var], item)
   end
end

function LinState:mark_access(item, node)
   node.var.accessed = true

   if not item.accesses[node.var] then
      item.accesses[node.var] = {}
   end

   table.insert(item.accesses[node.var], node)
   self:register_upvalue_action(item, node.var, "accessed_upvalues")
end

function LinState:mark_mutation(item, node)
   node.var.mutated = true

   if not item.mutations[node.var] then
      item.mutations[node.var] = {}
   end

   table.insert(item.mutations[node.var], node)
   self:register_upvalue_action(item, node.var, "mutated_upvalues")
end

function LinState:scan_expr_Id(item, node)
   if self:check_var(node) then
      self:mark_access(item, node)
   end
end

function LinState:scan_expr_Dots(item, node)
   local dots = self:check_var(node)

   if not dots or dots.line ~= self.lines.top then
      parser.syntax_error("cannot use '...' outside a vararg function", node)
   end

   self:mark_access(item, node)
end

function LinState:scan_lhs_index(item, node)
   if node[1].tag == "Id" then
      if self:check_var(node[1]) then
         self:mark_mutation(item, node[1])
      end
   elseif node[1].tag == "Index" then
      self:scan_lhs_index(item, node[1])
   else
      self:scan_expr(item, node[1])
   end

   self:scan_expr(item, node[2])
end

LinState.scan_expr_Index = LinState.scan_exprs
LinState.scan_expr_Call = LinState.scan_exprs
LinState.scan_expr_Invoke = LinState.scan_exprs
LinState.scan_expr_Paren = LinState.scan_exprs
LinState.scan_expr_Table = LinState.scan_exprs
LinState.scan_expr_Pair = LinState.scan_exprs

function LinState:scan_expr_Op(item, node)
   self:scan_expr(item, node[2])

   if node[3] then
      self:scan_expr(item, node[3])
   end
end

-- Puts tables {var = value{} into field \`set_variables\` of items in line which set values.
-- Registers set values in field \`values\` of variables.
function LinState:register_set_variables()
   local line = self.lines.top

   for _, item in ipairs(line.items) do
      if item.tag == "Local" or item.tag == "Set" then
         item.set_variables = {}

         local is_init = item.tag == "Local"
         local unpacking_item -- Rightmost item of rhs which may unpack into several lhs items.

         if item.rhs then
            local last_rhs_item = item.rhs[#item.rhs]

            if is_unpacking(last_rhs_item) then
               unpacking_item = last_rhs_item
            end
         end

         local secondaries -- Array of values unpacked from rightmost rhs item.

         if unpacking_item and (#item.lhs > #item.rhs) then
            secondaries = {}
         end

         for i, node in ipairs(item.lhs) do
            local value

            if node.var then
               value = new_value(node, item.rhs and item.rhs[i] or unpacking_item, item, is_init)
               item.set_variables[node.var] = value
               table.insert(node.var.values, value)
            end

            if secondaries and (i >= #item.rhs) then
               if value then
                  value.secondaries = secondaries
                  table.insert(secondaries, value)
               else
                  -- If one of secondary values is assigned to a global or index,
                  -- it is considered used.
                  secondaries.used = true
               end
            end
         end
      end
   end
end

function LinState:build_line(node)
   self.lines:push(Line(node, self.lines.top))
   self:enter_scope()
   self:emit(new_local_item({node[1]}))
   self:enter_scope()
   self:register_vars(node[1], "arg")
   self:emit_stmts(node[2])
   self:leave_scope()
   self:register_label("return")
   self:leave_scope()
   self:register_set_variables()
   local line = self.lines:pop()

   for _, prev_line in ipairs(self.lines) do
      table.insert(prev_line.lines, line)
   end

   return line
end

function LinState:scan_expr_Function(item, node)
   local line = self:build_line(node)
   table.insert(item.lines, line)

   for _, nested_line in ipairs(line.lines) do
      table.insert(item.lines, nested_line)
   end
end

-- Builds linear representation (line) of AST and assigns it as \`chstate.top_line\`.
-- Assings an array of all lines as \`chstate.lines\`.
-- Adds warnings for redefined/shadowed locals and unused labels.
function stage.run(chstate)
   local linstate = LinState(chstate)
   chstate.top_line = linstate:build_line({{{tag = "Dots", "..."}}, chstate.ast})
   assert(linstate.lines.size == 0)
   assert(linstate.scopes.size == 0)

   chstate.lines = {chstate.top_line}

   for _, nested_line in ipairs(chstate.top_line.lines) do
      table.insert(chstate.lines, nested_line)
   end
end

return stage

end)
__bundle_register("luacheck.parser", function(require, _LOADED, __bundle_register, __bundle_modules)
local lexer = require("luacheck.lexer")
local utils = require("luacheck.utils")

local parser = {}

-- A table with range info, or simply range, has \`line\`, \`offset\`, and \`end_offset\` fields.
-- \`line\` is the line of the first character.
-- Parser state table has range info for the current token, and all AST
-- node tables have range info for themself, including parens around expressions
-- that are otherwise not reflected in the AST structure.

parser.SyntaxError = utils.class()

function parser.SyntaxError:__init(msg, range, prev_range)
   self.msg = msg
   self.line = range.line
   self.offset = range.offset
   self.end_offset = range.end_offset

   if prev_range then
      self.prev_line = prev_range.line
      self.prev_offset = prev_range.offset
      self.prev_end_offset = prev_range.end_offset
   end
end

function parser.syntax_error(msg, range, prev_range)
   error(parser.SyntaxError(msg, range, prev_range), 0)
end

local function mark_line_endings(state, token_type)
   for line = state.line, state.lexer.line - 1 do
      state.line_endings[line] = token_type
   end
end

local function skip_token(state)
   while true do
      local token, token_value, line, offset, error_end_offset = lexer.next_token(state.lexer)
      state.token = token
      state.token_value = token_value
      state.line = line
      state.offset = offset
      state.end_offset = error_end_offset or (state.lexer.offset - 1)

      if not token then
         parser.syntax_error(token_value, state)
      end

      if token == "short_comment" then
         state.comments[#state.comments + 1] = {
            contents = token_value,
            line = line,
            offset = offset,
            end_offset = state.end_offset
         }

         state.line_endings[line] = "comment"
      elseif token == "long_comment" then
         mark_line_endings(state, "comment")
      else
         if token ~= "eof" then
            mark_line_endings(state, "string")
            state.code_lines[line] = true
            state.code_lines[state.lexer.line] = true
         end

         return
      end
   end
end

local function token_name(token)
   return token == "name" and "identifier" or (token == "eof" and "<eof>" or ("'" .. token .. "'"))
end

local function parse_error(state, msg, prev_range, token_prefix, message_suffix)
   local token_repr

   if state.token == "eof" then
      token_repr = "<eof>"
   else
      token_repr = lexer.get_quoted_substring_or_line(state.lexer, state.line, state.offset, state.end_offset)
   end

   if token_prefix then
      token_repr = token_prefix .. " " .. token_repr
   end

   msg = msg .. " near " .. token_repr

   if message_suffix then
      msg = msg .. " " .. message_suffix
   end

   parser.syntax_error(msg, state, prev_range)
end

local function check_token(state, token)
   if state.token ~= token then
      parse_error(state, "expected " .. token_name(token))
   end
end

local function check_and_skip_token(state, token)
   check_token(state, token)
   skip_token(state)
end

local function test_and_skip_token(state, token)
   if state.token == token then
      skip_token(state)
      return true
   end
end

local function copy_range(range)
   return {
      line = range.line,
      offset = range.offset,
      end_offset = range.end_offset
   }
end

local new_state
local parse_block
local missing_closing_token_error

-- Attempt to guess a better location for missing \`end\` and \`until\` errors (usually they uselessly point to eof).
-- Guessed error token should be selected in such a way that inserting previously missing closing token
-- in front of it should fix the error or at least move its opening token forward.
-- The idea is to track the stack of opening tokens and their indentations.
-- For the first statement or closing token with the same or smaller indentation than the opening token
-- on the top of the stack:
-- * If it has the same indentation but is not the appropriate closing token for the opening one, pick it
--   as the guessed error location.
-- * If it has a lower indentation level, pick it as the guessed error location even it closes the opening token.
-- Example:
-- local function f()
--    <code>
--
--    if cond then                   <- \`if\` is the guessed opening token
--       <code>
--
--    <code not starting with \`end\`> <- first token on this line is the guessed error location
-- end
-- Another one:
-- local function g()
--    <code>
--
--    if cond then  <- \`if\` is the guessed opening token
--       <code>
--
-- end              <- \`end\` is the guessed error location

local opening_token_to_closing = {
   ["("] = ")",
   ["["] = "]",
   ["{"] = "}",
   ["do"] = "end",
   ["if"] = "end",
   ["else"] = "end",
   ["elseif"] = "end",
   ["while"] = "end",
   ["repeat"] = "until",
   ["for"] = "end",
   ["function"] = "end"
}

local function get_indentation(state, line)
   local ws_start, ws_end = state.lexer.src:find("^[ \\t\\v\\f]*", state.lexer.line_offsets[line])
   return ws_end - ws_start
end

local UnpairedTokenGuesser = utils.class()

function UnpairedTokenGuesser:__init(state, error_opening_range, error_closing_token)
   self.old_state = state
   self.error_offset = state.offset
   self.error_opening_range = error_opening_range
   self.error_closing_token = error_closing_token
   self.opening_tokens_stack = utils.Stack()
end

function UnpairedTokenGuesser:guess()
   -- Need to reinitialize lexer (e.g. to skip shebang again).
   self.state = new_state(self.old_state.lexer.src)
   self.state.unpaired_token_guesser = self
   skip_token(self.state)
   parse_block(self.state)
   error("No syntax error in second parse", 0)
end

function UnpairedTokenGuesser:on_block_start(opening_token_range, opening_token)
   local token_wrapper = copy_range(opening_token_range)
   token_wrapper.token = opening_token
   token_wrapper.closing_token = opening_token_to_closing[opening_token]
   token_wrapper.eligible = token_wrapper.closing_token == self.error_closing_token
   token_wrapper.indentation = get_indentation(self.state, opening_token_range.line)
   self.opening_tokens_stack:push(token_wrapper)
end

function UnpairedTokenGuesser:set_guessed()
   -- Keep the first detected location.
   if self.guessed then
      return
   end

   self.guessed = self.opening_tokens_stack.top
   self.guessed.error_token = self.state.token
   self.guessed.error_range = copy_range(self.state)
end

function UnpairedTokenGuesser:check_token()
   local top = self.opening_tokens_stack.top

   if top and top.eligible and self.state.line > top.line then
      local token_indentation = get_indentation(self.state, self.state.line)

      if token_indentation < top.indentation then
         self:set_guessed()
      elseif token_indentation == top.indentation then
         local token = self.state.token

         if token ~= top.closing_token and
               ((top.token ~= "if" and top.token ~= "elseif") or (token ~= "elseif" and token ~= "else")) then
            self:set_guessed()
         end
      end
   end

   if self.state.offset == self.error_offset then
      if self.guessed and self.guessed.error_range.offset ~= self.state.offset then
         self.state.line = self.guessed.error_range.line
         self.state.offset = self.guessed.error_range.offset
         self.state.end_offset = self.guessed.error_range.end_offset
         self.state.token = self.guessed.error_token
         missing_closing_token_error(self.state, self.guessed, self.guessed.token, self.guessed.closing_token, true)
      end
   end
end

function UnpairedTokenGuesser:on_block_end()
   self:check_token()
   self.opening_tokens_stack:pop()

   if not self.opening_tokens_stack.top then
      -- Inserting an end token into a balanced sequence of tokens adds an error earlier than original one.
      self.guessed = nil
   end
end

function UnpairedTokenGuesser:on_statement()
   self:check_token()
end

function missing_closing_token_error(state, opening_range, opening_token, closing_token, is_guess)
   local msg = "expected " .. token_name(closing_token)

   if opening_range and opening_range.line ~= state.line then
      msg = msg .. " (to close " .. token_name(opening_token) .. " on line " .. tostring(opening_range.line) .. ")"
   end

   local token_prefix
   local message_suffix

   if is_guess then
      if state.token == closing_token then
         -- "expected 'end' near 'end'" seems confusing.
         token_prefix = "less indented"
      end

      message_suffix = "(indentation-based guess)"
   end

   parse_error(state, msg, opening_range, token_prefix, message_suffix)
end

local function check_closing_token(state, opening_range, opening_token)
   local closing_token = opening_token_to_closing[opening_token] or "eof"

   if state.token == closing_token then
      return
   end

   if (opening_token == "if" or opening_token == "elseif") and (state.token == "else" or state.token == "elseif") then
      return
   end

   if closing_token == "end" or closing_token == "until" then
      if not state.unpaired_token_guesser then
         UnpairedTokenGuesser(state, opening_range, closing_token):guess()
      end
   end

   missing_closing_token_error(state, opening_range, opening_token, closing_token)
end

local function check_and_skip_closing_token(state, opening_range, opening_token)
   check_closing_token(state, opening_range, opening_token)
   skip_token(state)
end

local function check_name(state)
   check_token(state, "name")
   return state.token_value
end

local function new_outer_node(range, tag, node)
   node = node or {}
   node.line = range.line
   node.offset = range.offset
   node.end_offset = range.end_offset
   node.tag = tag
   return node
end

local function new_inner_node(start_range, end_range, tag, node)
   node = node or {}
   node.line = start_range.line
   node.offset = start_range.offset
   node.end_offset = end_range.end_offset
   node.tag = tag
   return node
end

local parse_expression

local function parse_expression_list(state, list)
   list = list or {}

   repeat
      list[#list + 1] = parse_expression(state)
   until not test_and_skip_token(state, ",")

   return list
end

local function parse_id(state, tag)
   local ast_node = new_outer_node(state, tag or "Id")
   ast_node[1] = check_name(state)
   -- Skip name.
   skip_token(state)
   return ast_node
end

local function atom(tag)
   return function(state)
      local ast_node = new_outer_node(state, tag)
      ast_node[1] = state.token_value
      skip_token(state)
      return ast_node
   end
end

local simple_expressions = {}

simple_expressions.number = atom("Number")
simple_expressions.string = atom("String")
simple_expressions["nil"] = atom("Nil")
simple_expressions["true"] = atom("True")
simple_expressions["false"] = atom("False")
simple_expressions["..."] = atom("Dots")

simple_expressions["{"] = function(state)
   local start_range = copy_range(state)
   local ast_node = {}
   skip_token(state)

   repeat
      if state.token == "}" then
         break
      end

      local key_node, value_node
      local first_token_range = copy_range(state)

      if state.token == "name" then
         local name = state.token_value
         skip_token(state)  -- Skip name.

         if test_and_skip_token(state, "=") then
            -- \`name\` = \`expr\`.
            key_node = new_outer_node(first_token_range, "String", {name})
            value_node = parse_expression(state)
         else
            -- \`name\` is beginning of an expression in array part.
            -- Backtrack lexer to before name.
            state.lexer.line = first_token_range.line
            state.lexer.offset = first_token_range.offset
            skip_token(state)  -- Load name again.
            value_node = parse_expression(state)
         end
      elseif state.token == "[" then
         -- [ \`expr\` ] = \`expr\`.
         skip_token(state)
         key_node = parse_expression(state)
         check_and_skip_closing_token(state, first_token_range, "[")
         check_and_skip_token(state, "=")
         value_node = parse_expression(state)
      else
         -- Expression in array part.
         value_node = parse_expression(state)
      end

      if key_node then
         -- Pair.
         ast_node[#ast_node + 1] = new_inner_node(first_token_range, value_node, "Pair", {key_node, value_node})
      else
         -- Array part item.
         ast_node[#ast_node + 1] = value_node
      end
   until not (test_and_skip_token(state, ",") or test_and_skip_token(state, ";"))

   new_inner_node(start_range, state, "Table", ast_node)
   check_and_skip_closing_token(state, start_range, "{")
   return ast_node
end

-- Parses argument list and the statements.
local function parse_function(state, function_range)
   local paren_range = copy_range(state)
   check_and_skip_token(state, "(")
   local args = {}

   -- Are there arguments?
   if state.token ~= ")" then
      repeat
         if state.token == "name" then
            args[#args + 1] = parse_id(state)
         elseif state.token == "..." then
            args[#args + 1] = simple_expressions["..."](state)
            break
         else
            parse_error(state, "expected argument")
         end
      until not test_and_skip_token(state, ",")
   end

   check_and_skip_closing_token(state, paren_range, "(")
   local body = parse_block(state, function_range, "function")
   local end_range = copy_range(state)
   -- Skip "function".
   skip_token(state)
   return new_inner_node(function_range, end_range, "Function", {args, body, end_range = end_range})
end

simple_expressions["function"] = function(state)
   local function_range = copy_range(state)
   -- Skip "function".
   skip_token(state)
   return parse_function(state, function_range)
end

-- A call handler parses arguments of a call with given base node that determines resulting node start location,
-- given tag, and array to which the arguments should be appended.
local call_handlers = {}

call_handlers["("] = function(state, base_node, tag, node)
   local paren_range = copy_range(state)
   -- Skip "(".
   skip_token(state)

   if state.token ~= ")" then
      parse_expression_list(state, node)
   end

   new_inner_node(base_node, state, tag, node)
   check_and_skip_closing_token(state, paren_range, "(")
   return node
end

call_handlers["{"] = function(state, base_node, tag, node)
   local arg_node = simple_expressions[state.token](state)
   node[#node + 1] = arg_node
   return new_inner_node(base_node, arg_node, tag, node)
end

call_handlers.string = call_handlers["{"]

local suffix_handlers = {}

suffix_handlers["."] = function(state, base_node)
   -- Skip ".".
   skip_token(state)
   local index_node = parse_id(state, "String")
   return new_inner_node(base_node, index_node, "Index", {base_node, index_node})
end

suffix_handlers["["] = function(state, base_node)
   local bracket_range = copy_range(state)
   -- Skip "[".
   skip_token(state)
   local index_node = parse_expression(state)
   local ast_node = new_inner_node(base_node, state, "Index", {base_node, index_node})
   check_and_skip_closing_token(state, bracket_range, "[")
   return ast_node
end

suffix_handlers[":"] = function(state, base_node)
   -- Skip ":".
   skip_token(state)
   local method_name = parse_id(state, "String")
   local call_handler = call_handlers[state.token]

   if not call_handler then
      parse_error(state, "expected method arguments")
   end

   return call_handler(state, base_node, "Invoke", {base_node, method_name})
end

suffix_handlers["("] = function(state, base_node)
   return call_handlers[state.token](state, base_node, "Call", {base_node})
end

suffix_handlers["{"] = suffix_handlers["("]
suffix_handlers.string = suffix_handlers["("]

local function parse_simple_expression(state, kind, no_literals)
   local expression

   if state.token == "(" then
      local paren_range = copy_range(state)
      skip_token(state)
      local inner_expression = parse_expression(state)
      expression = new_inner_node(paren_range, state, "Paren", {inner_expression})
      check_and_skip_closing_token(state, paren_range, "(")
   elseif state.token == "name" then
      expression = parse_id(state)
   else
      local literal_handler = simple_expressions[state.token]

      if not literal_handler or no_literals then
         parse_error(state, "expected " .. (kind or "expression"))
      end

      return literal_handler(state)
   end

   while true do
      local suffix_handler = suffix_handlers[state.token]

      if suffix_handler then
         expression = suffix_handler(state, expression)
      else
         return expression
      end
   end
end

local unary_operators = {
   ["not"] = "not",
   ["-"] = "unm",
   ["~"] = "bnot",
   ["#"] = "len"
}

local unary_priority = 12

local binary_operators = {
   ["+"] = "add", ["-"] = "sub",
   ["*"] = "mul", ["%"] = "mod",
   ["^"] = "pow",
   ["/"] = "div", ["//"] = "idiv",
   ["&"] = "band", ["|"] = "bor", ["~"] = "bxor",
   ["<<"] = "shl", [">>"] = "shr",
   [".."] = "concat",
   ["~="] = "ne", ["=="] = "eq",
   ["<"] = "lt", ["<="] = "le",
   [">"] = "gt", [">="] = "ge",
   ["and"] = "and", ["or"] = "or"
}

local left_priorities = {
   add = 10, sub = 10,
   mul = 11, mod = 11,
   pow = 14,
   div = 11, idiv = 11,
   band = 6, bor = 4, bxor = 5,
   shl = 7, shr = 7,
   concat = 9,
   ne = 3, eq = 3,
   lt = 3, le = 3,
   gt = 3, ge = 3,
   ["and"] = 2, ["or"] = 1
}

local right_priorities = {
   add = 10, sub = 10,
   mul = 11, mod = 11,
   pow = 13,
   div = 11, idiv = 11,
   band = 6, bor = 4, bxor = 5,
   shl = 7, shr = 7,
   concat = 8,
   ne = 3, eq = 3,
   lt = 3, le = 3,
   gt = 3, ge = 3,
   ["and"] = 2, ["or"] = 1
}

local function parse_subexpression(state, limit, kind)
   local expression
   local unary_operator = unary_operators[state.token]

   if unary_operator then
      local operator_range = copy_range(state)
      -- Skip operator.
      skip_token(state)
      local operand = parse_subexpression(state, unary_priority)
      expression = new_inner_node(operator_range, operand, "Op", {unary_operator, operand})
   else
      expression = parse_simple_expression(state, kind)
   end

   -- Expand while operators have priorities higher than \`limit\`.
   while true do
      local binary_operator = binary_operators[state.token]

      if not binary_operator or left_priorities[binary_operator] <= limit then
         break
      end

       -- Skip operator.
      skip_token(state)
      -- Read subexpression with higher priority.
      local subexpression = parse_subexpression(state, right_priorities[binary_operator])
      expression = new_inner_node(expression, subexpression, "Op", {binary_operator, expression, subexpression})
   end

   return expression
end

function parse_expression(state, kind)
   return parse_subexpression(state, 0, kind)
end

local statements = {}

statements["if"] = function(state)
   local start_range = copy_range(state)
   -- Skip "if".
   skip_token(state)
   local ast_node = {}

   -- The loop is entered after skipping "if" or "elseif".
   -- Block start token info is set to the last skipped "if", "elseif", or "else" token.
   local block_start_token = "if"
   local block_start_range = start_range

   while true do
      ast_node[#ast_node + 1] = parse_expression(state, "condition")
      -- Add range of the "then" token to the block statement array.
      local branch_range = copy_range(state)
      check_and_skip_token(state, "then")
      ast_node[#ast_node + 1] = parse_block(state, block_start_range, block_start_token, branch_range)

      if state.token == "else" then
         branch_range = copy_range(state)
         block_start_token = "else"
         block_start_range = branch_range
         skip_token(state)
         ast_node[#ast_node + 1] = parse_block(state, block_start_range, block_start_token, branch_range)
         break
      elseif state.token == "elseif" then
         block_start_token = "elseif"
         block_start_range = copy_range(state)
         skip_token(state)
      else
         break
      end
   end

   new_inner_node(start_range, state, "If", ast_node)
   -- Skip "end".
   skip_token(state)
   return ast_node
end

statements["while"] = function(state)
   local start_range = copy_range(state)
   -- Skip "while".
   skip_token(state)
   local condition = parse_expression(state, "condition")
   check_and_skip_token(state, "do")
   local block = parse_block(state, start_range, "while")
   local ast_node = new_inner_node(start_range, state, "While", {condition, block})
   -- Skip "end".
   skip_token(state)
   return ast_node
end

statements["do"] = function(state)
   local start_range = copy_range(state)
   -- Skip "do".
   skip_token(state)
   local block = parse_block(state, start_range, "do")
   local ast_node = new_inner_node(start_range, state, "Do", block)
   -- Skip "end".
   skip_token(state)
   return ast_node
end

statements["for"] = function(state)
   local start_range = copy_range(state)
   -- Skip "for".
   skip_token(state)

   local ast_node = {}
   local tag
   local first_var = parse_id(state)

   if state.token == "=" then
      -- Numeric "for" loop.
      tag = "Fornum"
      -- Skip "=".
      skip_token(state)
      ast_node[1] = first_var
      ast_node[2] = parse_expression(state)
      check_and_skip_token(state, ",")
      ast_node[3] = parse_expression(state)

      if test_and_skip_token(state, ",") then
         ast_node[4] = parse_expression(state)
      end

      check_and_skip_token(state, "do")
      ast_node[#ast_node + 1] = parse_block(state, start_range, "for")
   elseif state.token == "," or state.token == "in" then
      -- Generic "for" loop.
      tag = "Forin"

      local iter_vars = {first_var}
      while test_and_skip_token(state, ",") do
         iter_vars[#iter_vars + 1] = parse_id(state)
      end

      ast_node[1] = iter_vars
      check_and_skip_token(state, "in")
      ast_node[2] = parse_expression_list(state)
      check_and_skip_token(state, "do")
      ast_node[3] = parse_block(state, start_range, "for")
   else
      parse_error(state, "expected '=', ',' or 'in'")
   end

   new_inner_node(start_range, state, tag, ast_node)
   -- Skip "end".
   skip_token(state)
   return ast_node
end

statements["repeat"] = function(state)
   local start_range = copy_range(state)
   -- Skip "repeat".
   skip_token(state)
   local block = parse_block(state, start_range, "repeat")
   -- Skip "until".
   skip_token(state)
   local condition = parse_expression(state, "condition")
   return new_inner_node(start_range, condition, "Repeat", {block, condition})
end

statements["function"] = function(state)
   local start_range = copy_range(state)
   -- Skip "function".
   skip_token(state)
   local lhs = parse_id(state)
   local implicit_self_range

   while (not implicit_self_range) and (state.token == "." or state.token == ":") do
      implicit_self_range = (state.token == ":") and copy_range(state)
      -- Skip "." or ":".
      skip_token(state)
      local index_node = parse_id(state, "String")
      lhs = new_inner_node(lhs, index_node, "Index", {lhs, index_node})
   end

   local function_node = parse_function(state, start_range)

   if implicit_self_range then
      -- Insert implicit "self" argument.
      local self_arg = new_outer_node(implicit_self_range, "Id", {"self", implicit = true})
      table.insert(function_node[1], 1, self_arg)
   end

   return new_inner_node(start_range, function_node, "Set", {{lhs}, {function_node}})
end

statements["local"] = function(state)
   local start_range = copy_range(state)
   -- Skip "local".
   skip_token(state)

   if state.token == "function" then
      -- Local function.
      local function_range = copy_range(state)
      -- Skip "function".
      skip_token(state)
      local var = parse_id(state)
      local function_node = parse_function(state, function_range)
      return new_inner_node(start_range, function_node, "Localrec", {{var}, {function_node}})
   end

   -- Local definition, potentially with assignment.
   local lhs = {}
   local rhs

   repeat
      lhs[#lhs + 1] = parse_id(state)
   until not test_and_skip_token(state, ",")

   if test_and_skip_token(state, "=") then
      rhs = parse_expression_list(state)
   end

   return new_inner_node(start_range, rhs and rhs[#rhs] or lhs[#lhs], "Local", {lhs, rhs})
end

statements["::"] = function(state)
   local start_range = copy_range(state)
   -- Skip "::".
   skip_token(state)
   local name = check_name(state)
   -- Skip label name.
   skip_token(state)
   local ast_node = new_inner_node(start_range, state, "Label", {name})
   check_and_skip_token(state, "::")
   return ast_node
end

local closing_tokens = utils.array_to_set({"end", "eof", "else", "elseif", "until"})

statements["return"] = function(state)
   local start_range = copy_range(state)
   -- Skip "return".
   skip_token(state)

   if closing_tokens[state.token] or state.token == ";" then
      -- No return values.
      return new_outer_node(start_range, "Return")
   else
      local returns = parse_expression_list(state)
      return new_inner_node(start_range, returns[#returns], "Return", returns)
   end
end

statements["break"] = function(state)
   local ast_node = new_outer_node(state, "Break")
   -- Skip "break".
   skip_token(state)
   return ast_node
end

statements["goto"] = function(state)
   local start_range = copy_range(state)
   -- Skip "goto".
   skip_token(state)
   local name = check_name(state)
   local ast_node = new_outer_node(start_range, "Goto", {name})
   -- Skip label name.
   skip_token(state)
   return ast_node
end

local function parse_expression_statement(state)
   local lhs
   local start_range = copy_range(state)

   -- Handle lhs of an assignment or a single expression.
   repeat
      local item_start_range = lhs and copy_range(state) or start_range
      local expected = lhs and "identifier or field" or "statement"
      local primary_expression = parse_simple_expression(state, expected, true)

      if primary_expression.tag == "Paren" then
         -- (expr) in lhs is invalid.
         parser.syntax_error("expected " .. expected .. " near '('", item_start_range)
      end

      if primary_expression.tag == "Call" or primary_expression.tag == "Invoke" then
         if lhs then
            -- The is an assingment, and a call is not valid in lhs.
            parse_error(state, "expected call or indexing")
         else
            -- This is a call.
            return primary_expression
         end
      end

      -- This is an assignment.
      lhs = lhs or {}
      lhs[#lhs + 1] = primary_expression
   until not test_and_skip_token(state, ",")

   check_and_skip_token(state, "=")
   local rhs = parse_expression_list(state)
   return new_inner_node(start_range, rhs[#rhs], "Set", {lhs, rhs})
end

local function parse_statement(state)
   return (statements[state.token] or parse_expression_statement)(state)
end

function parse_block(state, opening_token_range, opening_token, block)
   local unpaired_token_guesser = state.unpaired_token_guesser

   if unpaired_token_guesser and opening_token then
      unpaired_token_guesser:on_block_start(opening_token_range, opening_token)
   end

   block = block or {}
   local after_statement = false

   while not closing_tokens[state.token] do
      local first_token = state.token

      if first_token == ";" then
         if not after_statement then
            table.insert(state.hanging_semicolons, copy_range(state))
         end

         -- Skip ";".
         skip_token(state)
         -- Further semicolons are considered hanging.
         after_statement = false
      else
         if unpaired_token_guesser then
            unpaired_token_guesser:on_statement()
         end

         local statement = parse_statement(state)
         after_statement = true
         block[#block + 1] = statement

         if statement.tag == "Return" then
            -- "return" must be the last statement.
            -- However, one ";" after it is allowed.
            test_and_skip_token(state, ";")
            break
         end
      end
   end

   if unpaired_token_guesser and opening_token then
      unpaired_token_guesser:on_block_end()
   end

   check_closing_token(state, opening_token_range, opening_token)

   return block
end

function new_state(src, line_offsets, line_lengths)
   return {
      lexer = lexer.new_state(src, line_offsets, line_lengths),
      -- Set of line numbers containing code.
      code_lines = {},
      -- Maps line numbers to "comment", "string", or nil based on whether the line ending is within a token
      line_endings = {},
      -- Array of {contents = string} with range info.
      comments = {},
       -- Array of ranges of semicolons not following a statement.
      hanging_semicolons = {}
   }
end

-- Parses source characters.
-- Returns AST (in almost MetaLua format), array of comments - tables {contents = string} with range info,
-- set of line numbers containing code, map of types of tokens wrapping line endings (nil, "string", or "comment"),
-- array of ranges of hanging semicolons (not after statements), array of line start offsets, array of line lengths.
-- The last two tables can be passed as arguments to be filled.
-- On error throws an instance of parser.SyntaxError: table {msg = msg, prev_range = prev_range?} with range info,
-- prev_range may refer to some extra relevant location.
function parser.parse(src, line_offsets, line_lengths)
   local state = new_state(src, line_offsets, line_lengths)
   skip_token(state)
   local ast = parse_block(state)
   return ast, state.comments, state.code_lines, state.line_endings, state.hanging_semicolons,
      state.lexer.line_offsets, state.lexer.line_lengths
end

return parser

end)
__bundle_register("luacheck.lexer", function(require, _LOADED, __bundle_register, __bundle_modules)
local utils = require("luacheck.utils")

-- Lexer should support syntax of Lua 5.1, Lua 5.2, Lua 5.3 and LuaJIT(64bit and complex cdata literals).
local lexer = {}

local sbyte = string.byte
local schar = string.char
local sreverse = string.reverse
local tconcat = table.concat
local mfloor = math.floor

-- No point in inlining these, fetching a constant ~= fetching a local.
local BYTE_0, BYTE_9, BYTE_f, BYTE_F = sbyte("0"), sbyte("9"), sbyte("f"), sbyte("F")
local BYTE_x, BYTE_X, BYTE_i, BYTE_I = sbyte("x"), sbyte("X"), sbyte("i"), sbyte("I")
local BYTE_l, BYTE_L, BYTE_u, BYTE_U = sbyte("l"), sbyte("L"), sbyte("u"), sbyte("U")
local BYTE_e, BYTE_E, BYTE_p, BYTE_P = sbyte("e"), sbyte("E"), sbyte("p"), sbyte("P")
local BYTE_a, BYTE_z, BYTE_A, BYTE_Z = sbyte("a"), sbyte("z"), sbyte("A"), sbyte("Z")
local BYTE_DOT, BYTE_COLON = sbyte("."), sbyte(":")
local BYTE_OBRACK, BYTE_CBRACK = sbyte("["), sbyte("]")
local BYTE_OBRACE, BYTE_CBRACE = sbyte("{"), sbyte("}")
local BYTE_QUOTE, BYTE_DQUOTE = sbyte("'"), sbyte('"')
local BYTE_PLUS, BYTE_DASH, BYTE_LDASH = sbyte("+"), sbyte("-"), sbyte("_")
local BYTE_SLASH, BYTE_BSLASH = sbyte("/"), sbyte("\\\\")
local BYTE_EQ, BYTE_NE = sbyte("="), sbyte("~")
local BYTE_LT, BYTE_GT = sbyte("<"), sbyte(">")
local BYTE_LF, BYTE_CR = sbyte("\\n"), sbyte("\\r")
local BYTE_SPACE, BYTE_FF, BYTE_TAB, BYTE_VTAB = sbyte(" "), sbyte("\\f"), sbyte("\\t"), sbyte("\\v")

local function to_hex(b)
   if BYTE_0 <= b and b <= BYTE_9 then
      return b-BYTE_0
   elseif BYTE_a <= b and b <= BYTE_f then
      return 10+b-BYTE_a
   elseif BYTE_A <= b and b <= BYTE_F then
      return 10+b-BYTE_A
   else
      return nil
   end
end

local function to_dec(b)
   if BYTE_0 <= b and b <= BYTE_9 then
      return b-BYTE_0
   else
      return nil
   end
end

local function to_utf(codepoint)
   if codepoint < 0x80 then  -- ASCII?
      return schar(codepoint)
   end

   local buf = {}
   local mfb = 0x3F

   repeat
      buf[#buf+1] = schar(codepoint % 0x40 + 0x80)
      codepoint = mfloor(codepoint / 0x40)
      mfb = mfloor(mfb / 2)
   until codepoint <= mfb

   buf[#buf+1] = schar(0xFE - mfb*2 + codepoint)
   return sreverse(tconcat(buf))
end

local function is_alpha(b)
   return (BYTE_a <= b and b <= BYTE_z) or
      (BYTE_A <= b and b <= BYTE_Z) or b == BYTE_LDASH
end

local function is_newline(b)
   return (b == BYTE_LF) or (b == BYTE_CR)
end

local function is_space(b)
   return (b == BYTE_SPACE) or (b == BYTE_FF) or
      (b == BYTE_TAB) or (b == BYTE_VTAB)
end

local keywords = utils.array_to_set({
   "and", "break", "do", "else", "elseif", "end", "false", "for", "function", "goto", "if", "in",
   "local", "nil", "not", "or", "repeat", "return", "then", "true", "until", "while"})

local simple_escapes = {
   [sbyte("a")] = sbyte("\\a"),
   [sbyte("b")] = sbyte("\\b"),
   [sbyte("f")] = sbyte("\\f"),
   [sbyte("n")] = sbyte("\\n"),
   [sbyte("r")] = sbyte("\\r"),
   [sbyte("t")] = sbyte("\\t"),
   [sbyte("v")] = sbyte("\\v"),
   [BYTE_BSLASH] = BYTE_BSLASH,
   [BYTE_QUOTE] = BYTE_QUOTE,
   [BYTE_DQUOTE] = BYTE_DQUOTE
}

local function next_byte(state)
   local offset = state.offset + 1
   state.offset = offset
   return state.src:get_codepoint(offset)
end

-- Skipping helpers.
-- Take the current character, skip something, return next character.

local function skip_newline(state, newline)
   local first_newline_offset = state.offset
   local b = next_byte(state)

   if b ~= newline and is_newline(b) then
      b = next_byte(state)
   end

   local line = state.line
   local line_offsets = state.line_offsets
   state.line_lengths[line] = first_newline_offset - line_offsets[line]
   line = line + 1
   state.line = line
   line_offsets[line] = state.offset
   return b
end

local function skip_to_newline(state, b)
   while not is_newline(b) and b do
      b = next_byte(state)
   end

   return b
end

local function skip_space(state, b)
   while is_space(b) or is_newline(b) do
      if is_newline(b) then
         b = skip_newline(state, b)
      else
         b = next_byte(state)
      end
   end

   return b
end

-- Skips "[=*" or "]=*". Returns next character and number of "="s.
local function skip_long_bracket(state)
   local start = state.offset
   local b = next_byte(state)

   while b == BYTE_EQ do
      b = next_byte(state)
   end

   return b, state.offset-start-1
end

-- Token handlers.

-- Called after the opening "[=*" has been skipped.
-- Takes number of "=" in the opening bracket and token type(comment or string).
local function lex_long_string(state, opening_long_bracket, token)
   local b = next_byte(state)

   if is_newline(b) then
      b = skip_newline(state, b)
   end

   local lines = {}
   local line_start = state.offset

   while true do
      if is_newline(b) then
         -- Add the finished line.
         lines[#lines+1] = state.src:get_substring(line_start, state.offset-1)

         b = skip_newline(state, b)
         line_start = state.offset
      elseif b == BYTE_CBRACK then
         local long_bracket
         b, long_bracket = skip_long_bracket(state)

         if b == BYTE_CBRACK and long_bracket == opening_long_bracket then
            break
         end
      elseif b == nil then
         return nil, token == "string" and "unfinished long string" or "unfinished long comment"
      else
         b = next_byte(state)
      end
   end

   -- Add last line.
   lines[#lines+1] = state.src:get_substring(line_start, state.offset-opening_long_bracket-2)
   state.offset = state.offset + 1
   return token, tconcat(lines, "\\n")
end

local function lex_short_string(state, quote)
   local b = next_byte(state)
   local chunks  -- Buffer is only required when there are escape sequences.
   local chunk_start = state.offset

   while b ~= quote do
      if b == BYTE_BSLASH then
         -- Escape sequence.

         if not chunks then
            -- This is the first escape sequence, init buffer.
            chunks = {}
         end

         -- Put previous chunk into buffer.
         if chunk_start ~= state.offset then
            chunks[#chunks+1] = state.src:get_substring(chunk_start, state.offset-1)
         end

         b = next_byte(state)

         -- The final string escape sequence evaluates to.
         local s

         local escape_byte = simple_escapes[b]

         if escape_byte then  -- Is it a simple escape sequence?
            b = next_byte(state)
            s = schar(escape_byte)
         elseif is_newline(b) then
            b = skip_newline(state, b)
            s = "\\n"
         elseif b == BYTE_x then
            -- Hexadecimal escape.
            b = next_byte(state)  -- Skip "x".
            -- Exactly two hexadecimal digits.
            local c1, c2

            if b then
               c1 = to_hex(b)
            end

            if not c1 then
               return nil, "invalid hexadecimal escape sequence", -2
            end

            b = next_byte(state)

            if b then
               c2 = to_hex(b)
            end

            if not c2 then
               return nil, "invalid hexadecimal escape sequence", -3
            end

            b = next_byte(state)
            s = schar(c1*16 + c2)
         elseif b == BYTE_u then
            b = next_byte(state)  -- Skip "u".

            if b ~= BYTE_OBRACE then
               return nil, "invalid UTF-8 escape sequence", -2
            end

            b = next_byte(state)  -- Skip "{".

            local codepoint  -- There should be at least one digit.

            if b then
               codepoint = to_hex(b)
            end

            if not codepoint then
               return nil, "invalid UTF-8 escape sequence", -3
            end

            local hexdigits = 0

            while true do
               b = next_byte(state)
               local hex

               if b then
                  hex = to_hex(b)
               end

               if hex then
                  hexdigits = hexdigits + 1
                  codepoint = codepoint*16 + hex

                  if codepoint > 0x10FFFF then
                     -- UTF-8 value too large.
                     return nil, "invalid UTF-8 escape sequence", -hexdigits-3
                  end
               else
                  break
               end
            end

            if b ~= BYTE_CBRACE then
               return nil, "invalid UTF-8 escape sequence", -hexdigits-4
            end

            b = next_byte(state)  -- Skip "}".
            s = to_utf(codepoint)
         elseif b == BYTE_z then
            -- Zap following span of spaces.
            b = skip_space(state, next_byte(state))
         else
            -- Must be a decimal escape.
            local cb

            if b then
               cb = to_dec(b)
            end

            if not cb then
               return nil, "invalid escape sequence", -1
            end

            -- Up to three decimal digits.
            b = next_byte(state)

            if b then
               local c2 = to_dec(b)

               if c2 then
                  cb = 10*cb + c2
                  b = next_byte(state)

                  if b then
                     local c3 = to_dec(b)

                     if c3 then
                        cb = 10*cb + c3

                        if cb > 255 then
                           return nil, "invalid decimal escape sequence", -3
                        end

                        b = next_byte(state)
                     end
                  end
               end
            end

            s = schar(cb)
         end

         if s then
            chunks[#chunks+1] = s
         end

         -- Next chunk starts after escape sequence.
         chunk_start = state.offset
      elseif b == nil or is_newline(b) then
         return nil, "unfinished string"
      else
         b = next_byte(state)
      end
   end

   -- Offset now points at the closing quote.
   local string_value

   if chunks then
      -- Put last chunk into buffer.
      if chunk_start ~= state.offset then
         chunks[#chunks+1] = state.src:get_substring(chunk_start, state.offset-1)
      end

      string_value = tconcat(chunks)
   else
      -- There were no escape sequences.
      string_value = state.src:get_substring(chunk_start, state.offset-1)
   end

   -- Skip the closing quote.
   state.offset = state.offset + 1
   return "string", string_value
end

-- Payload for a number is simply a substring.
-- Luacheck is supposed to be forward-compatible with Lua 5.3 and LuaJIT syntax, so
--    parsing it into actual number may be problematic.
-- It is not needed currently anyway as Luacheck does not do static evaluation yet.
local function lex_number(state, b)
   local start = state.offset

   local exp_lower, exp_upper = BYTE_e, BYTE_E
   local is_digit = to_dec
   local has_digits = false
   local is_float = false

   if b == BYTE_0 then
      b = next_byte(state)

      if b == BYTE_x or b == BYTE_X then
         exp_lower, exp_upper = BYTE_p, BYTE_P
         is_digit = to_hex
         b = next_byte(state)
      else
         has_digits = true
      end
   end

   while b ~= nil and is_digit(b) do
      b = next_byte(state)
      has_digits = true
   end

   if b == BYTE_DOT then
      -- Fractional part.
      is_float = true
      b = next_byte(state)  -- Skip dot.

      while b ~= nil and is_digit(b) do
         b = next_byte(state)
         has_digits = true
      end
   end

   if b == exp_lower or b == exp_upper then
      -- Exponent part.
      is_float = true
      b = next_byte(state)

      -- Skip optional sign.
      if b == BYTE_PLUS or b == BYTE_DASH then
         b = next_byte(state)
      end

      -- Exponent consists of one or more decimal digits.
      if b == nil or not to_dec(b) then
         return nil, "malformed number"
      end

      repeat
         b = next_byte(state)
      until b == nil or not to_dec(b)
   end

   if not has_digits then
      return nil, "malformed number"
   end

   -- Is it cdata literal?
   if b == BYTE_i or b == BYTE_I then
      -- It is complex literal. Skip "i" or "I".
      state.offset = state.offset + 1
   else
      -- uint64_t and int64_t literals can not be fractional.
      if not is_float then
         if b == BYTE_u or b == BYTE_U then
            -- It may be uint64_t literal.
            local b1 = state.src:get_codepoint(state.offset+1)

            if b1 == BYTE_l or b1 == BYTE_L then
               local b2 = state.src:get_codepoint(state.offset+2)

               if b2 == BYTE_l or b2 == BYTE_L then
                  -- It is uint64_t literal.
                  state.offset = state.offset + 3
               end
            end
         elseif b == BYTE_l or b == BYTE_L then
            -- It may be uint64_t or int64_t literal.
            local b1 = state.src:get_codepoint(state.offset+1)

            if b1 == BYTE_l or b1 == BYTE_L then
               local b2 = state.src:get_codepoint(state.offset+2)

               if b2 == BYTE_u or b2 == BYTE_U then
                  -- It is uint64_t literal.
                  state.offset = state.offset + 3
               else
                  -- It is int64_t literal.
                  state.offset = state.offset + 2
               end
            end
         end
      end
   end

   return "number", state.src:get_substring(start, state.offset-1)
end

local function lex_ident(state)
   local start = state.offset
   local b = next_byte(state)

   while (b ~= nil) and (is_alpha(b) or to_dec(b)) do
      b = next_byte(state)
   end

   local ident = state.src:get_substring(start, state.offset-1)

   if keywords[ident] then
      return ident
   else
      return "name", ident
   end
end

local function lex_dash(state)
   local b = next_byte(state)

   -- Is it "-" or comment?
   if b ~= BYTE_DASH then
      return "-"
   end

   -- It is a comment.
   b = next_byte(state)
   local start = state.offset

   -- Is it a long comment?
   if b == BYTE_OBRACK then
      local long_bracket
      b, long_bracket = skip_long_bracket(state)

      if b == BYTE_OBRACK then
         return lex_long_string(state, long_bracket, "long_comment")
      end
   end

   -- Short comment.
   skip_to_newline(state, b)
   local comment_value = state.src:get_substring(start, state.offset - 1)
   return "short_comment", comment_value
end

local function lex_bracket(state)
   -- Is it "[" or long string?
   local b, long_bracket = skip_long_bracket(state)

   if b == BYTE_OBRACK then
      return lex_long_string(state, long_bracket, "string")
   elseif long_bracket == 0 then
      return "["
   else
      return nil, "invalid long string delimiter"
   end
end

local function lex_eq(state)
   local b = next_byte(state)

   if b == BYTE_EQ then
      state.offset = state.offset + 1
      return "=="
   else
      return "="
   end
end

local function lex_lt(state)
   local b = next_byte(state)

   if b == BYTE_EQ then
      state.offset = state.offset + 1
      return "<="
   elseif b == BYTE_LT then
      state.offset = state.offset + 1
      return "<<"
   else
      return "<"
   end
end

local function lex_gt(state)
   local b = next_byte(state)

   if b == BYTE_EQ then
      state.offset = state.offset + 1
      return ">="
   elseif b == BYTE_GT then
      state.offset = state.offset + 1
      return ">>"
   else
      return ">"
   end
end

local function lex_div(state)
   local b = next_byte(state)

   if b == BYTE_SLASH then
      state.offset = state.offset + 1
      return "//"
   else
      return "/"
   end
end

local function lex_ne(state)
   local b = next_byte(state)

   if b == BYTE_EQ then
      state.offset = state.offset + 1
      return "~="
   else
      return "~"
   end
end

local function lex_colon(state)
   local b = next_byte(state)

   if b == BYTE_COLON then
      state.offset = state.offset + 1
      return "::"
   else
      return ":"
   end
end

local function lex_dot(state)
   local b = next_byte(state)

   if b == BYTE_DOT then
      b = next_byte(state)

      if b == BYTE_DOT then
         state.offset = state.offset + 1
         return "...", "..."
      else
         return ".."
      end
   elseif b and to_dec(b) then
      -- Backtrack to dot.
      state.offset = state.offset - 2
      return lex_number(state, next_byte(state))
   else
      return "."
   end
end

local function lex_any(state, b)
   state.offset = state.offset + 1

   if b > 255 then
      b = 255
   end

   return schar(b)
end

-- Maps first bytes of tokens to functions that handle them.
-- Each handler takes the first byte as an argument.
-- Each handler stops at the character after the token and returns the token and,
--    optionally, a value associated with the token.
-- On error handler returns nil, error message and, optionally, start of reported location as negative offset.
local byte_handlers = {
   [BYTE_DOT] = lex_dot,
   [BYTE_COLON] = lex_colon,
   [BYTE_OBRACK] = lex_bracket,
   [BYTE_QUOTE] = lex_short_string,
   [BYTE_DQUOTE] = lex_short_string,
   [BYTE_DASH] = lex_dash,
   [BYTE_SLASH] = lex_div,
   [BYTE_EQ] = lex_eq,
   [BYTE_NE] = lex_ne,
   [BYTE_LT] = lex_lt,
   [BYTE_GT] = lex_gt,
   [BYTE_LDASH] = lex_ident
}

for b=BYTE_0, BYTE_9 do
   byte_handlers[b] = lex_number
end

for b=BYTE_a, BYTE_z do
   byte_handlers[b] = lex_ident
end

for b=BYTE_A, BYTE_Z do
   byte_handlers[b] = lex_ident
end

-- Creates and returns lexer state for source.
function lexer.new_state(src, line_offsets, line_lengths)
   local state = {
      src = src,
      line = 1,
      line_offsets = line_offsets or {},
      line_lengths = line_lengths or {},
      offset = 1
   }

   state.line_offsets[1] = 1

   if src:get_length() >= 2 and src:get_substring(1, 2) == "#!" then
      -- Skip shebang line.
      state.offset = 2
      skip_to_newline(state, next_byte(state))
   end

   return state
end

function lexer.get_quoted_substring_or_line(state, line, offset, end_offset)
   local line_length = state.line_lengths[line]

   if line_length then
      local line_end_offset = state.line_offsets[line] + line_length - 1

      if line_end_offset < end_offset then
         end_offset = line_end_offset
      end
   end

   return "'" .. state.src:get_printable_substring(offset, end_offset) .. "'"
end

-- Looks for next token starting from state.line, state.offset.
-- Returns next token, its value and its location (line, offset).
-- Sets state.line, state.offset to token end location + 1.
-- Fills state.line_offsets and state.line_lengths.
-- On error returns nil, error message, error location (line, offset), error end offset.
function lexer.next_token(state)
   local line_offsets = state.line_offsets
   local b = skip_space(state, state.src:get_codepoint(state.offset))

   -- Save location of token start.
   local token_line = state.line
   local line_offset = line_offsets[token_line]
   local token_offset = state.offset

   if not b then
      -- EOF token has length 1.
      state.offset = state.offset + 1
      state.line_lengths[token_line] = token_offset - line_offset
      return "eof", nil, token_line, token_offset
   end

   local token, token_value, relative_error_offset = (byte_handlers[b] or lex_any)(state, b)

   if relative_error_offset then
      -- Error relative to current offset.
      local error_offset = state.offset + relative_error_offset
      local error_end_offset = math.min(state.offset, state.src:get_length())
      local error_message = token_value .. " " .. lexer.get_quoted_substring_or_line(state,
         state.line, error_offset, error_end_offset)
      return nil, error_message, state.line, error_offset, error_end_offset
   end

   -- Single character errors fall through here.
   return token, token_value, token_line, token_offset, not token and token_offset
end

return lexer

end)
__bundle_register("luacheck.stages.unwrap_parens", function(require, _LOADED, __bundle_register, __bundle_modules)
local stage = {}

-- Mutates an array of nodes and non-tables, unwrapping Paren nodes.
-- If list_start is given, tail Paren is not unwrapped if it's unpacking and past list_start index.
local function handle_nodes(nodes, list_start)
   local num_nodes = #nodes

   for index = 1, num_nodes do
      local node = nodes[index]

      if type(node) == "table" then
         local tag = node.tag

         if tag == "Table" or tag == "Return" then
            handle_nodes(node, 1)
         elseif tag == "Call" then
            handle_nodes(node, 2)
         elseif tag == "Invoke" then
            handle_nodes(node, 3)
         elseif tag == "Forin" then
            handle_nodes(node[2], 1)
            handle_nodes(node[3])
         elseif tag == "Local" then
            if node[2] then
               handle_nodes(node[2])
            end
         elseif tag == "Set" then
            handle_nodes(node[1])
            handle_nodes(node[2], 1)
         else
            handle_nodes(node)

            if tag == "Paren" and (not list_start or index < list_start or index ~= num_nodes) then
               local inner_node = node[1]

               if inner_node.tag ~= "Call" and inner_node.tag ~= "Invoke" and inner_node.tag ~= "Dots" then
                  nodes[index] = inner_node
               end
            end
         end
      end
   end
end

-- Mutates AST, unwrapping Paren nodes.
-- Paren nodes are preserved only when they matter:
-- at the ends of expression lists with potentially multi-value inner expressions.
function stage.run(chstate)
   handle_nodes(chstate.ast)
end

return stage

end)
__bundle_register("luacheck.stages.parse", function(require, _LOADED, __bundle_register, __bundle_modules)
local decoder = require("luacheck.decoder")
local parser = require("luacheck.parser")

local stage = {}

function stage.run(chstate)
   chstate.source = decoder.decode(chstate.source_bytes)
   chstate.line_offsets = {}
   chstate.line_lengths = {}
   local ast, comments, code_lines, line_endings, useless_semicolons = parser.parse(
      chstate.source, chstate.line_offsets, chstate.line_lengths)
   chstate.ast = ast
   chstate.comments = comments
   chstate.code_lines = code_lines
   chstate.line_endings = line_endings
   chstate.useless_semicolons = useless_semicolons
end

return stage

end)
__bundle_register("luacheck.filter", function(require, _LOADED, __bundle_register, __bundle_modules)
local core_utils = require("luacheck.core_utils")
local decoder = require("luacheck.decoder")
local options = require("luacheck.options")
local utils = require("luacheck.utils")

local filter = {}

-- Returns two optional booleans indicating if warning matches pattern by code and name.
local function match(pattern, code, name)
   local matches_code, matches_name
   local code_pattern, name_pattern = pattern[1], pattern[2]

   if code_pattern then
      matches_code = utils.pmatch(code, code_pattern)
   end

   if name_pattern then
      if not name then
         -- Warnings without name field can't match by name.
         matches_name = false
      else
         matches_name = utils.pmatch(name, name_pattern)
      end
   end

   return matches_code, matches_name
end

local function passes_rules_filter(rules, code, name)
   -- A warning is enabled when its code and name are enabled.
   local enabled_code, enabled_name = false, false

   for _, rule in ipairs(rules) do
      local matches_one = false

      for _, pattern in ipairs(rule[1]) do
         local matches_code, matches_name = match(pattern, code, name)

         -- If a factor is enabled, warning can't be disabled by it.
         if enabled_code then
            matches_code = rule[2] ~= "disable"
         end

         if enabled_name then
            matches_code = rule[2] ~= "disable"
         end

         if (matches_code and matches_name ~= false) or
               (matches_name and matches_code ~= false) then
            matches_one = true
         end

         if rule[2] == "enable" then
            if matches_code then
               enabled_code = true
            end

            if matches_name then
               enabled_name = true
            end

            if enabled_code and enabled_name then
               -- Enable as matching to some \`enable\` pattern by code and to another by name.
               return true
            end
         elseif rule[2] == "disable" then
            if matches_one then
               -- Disable as matching to \`disable\` pattern.
               return false
            end
         end
      end

      if rule[2] == "only" and not matches_one then
         -- Disable as not matching to any of \`only\` patterns.
         return false
      end
   end

   -- Enable by default.
   return true
end

local function get_field_string(warning)
   local parts = {}

   if warning.indexing then
      for _, index in ipairs(warning.indexing) do
         local part

         if type(index) == "string" then
            local chars = decoder.decode(index)
            part = chars:get_printable_substring(1, chars:get_length())
         else
            part = "?"
         end

         table.insert(parts, part)
      end
   end

   return table.concat(parts, ".")
end

local function get_field_status(opts, warning, depth)
   local def = opts.std
   local defined = true
   local read_only = true

   for i = 1, depth or (warning.indexing and #warning.indexing or 0) + 1 do
      local index_string = i == 1 and warning.name or warning.indexing[i - 1]

      if index_string == true then
         -- Indexing with something that may or may not be a string.
         if (def.fields and next(def.fields)) or def.other_fields then
            if def.deep_read_only then
               read_only = true
            else
               read_only = false
            end
         else
            defined = false
         end

         break
      elseif index_string == false then
         -- Indexing with not a string.
         if not def.other_fields then
            defined = false
         end

         break
      else
         -- Indexing with a constant string.
         if def.fields and def.fields[index_string] then
            -- The field is defined, recurse into it.
            def = def.fields[index_string]

            if def.read_only ~= nil then
               read_only = def.read_only
            end
         else
            -- The field is not defined, but it may be okay to index if \`other_fields\` is true.
            if not def.other_fields then
               defined = false
            end

            break
         end
      end
   end

   return defined and (read_only and "read_only" or "global") or "undefined"
end

-- Checks if a warning passes options filter. May add some fields required for formatting.
local function passes_filter(normalized_options, warning)
   if warning.code == "561" then
      local max_complexity = normalized_options.max_cyclomatic_complexity

      if not max_complexity or warning.complexity <= max_complexity then
         return false
      end

      warning.max_complexity = max_complexity
   elseif warning.code:find("^[234]") and warning.name == "_" and not warning.useless then
      return false
   elseif warning.code:find("^1[14]") then
      if warning.indirect and
            get_field_status(normalized_options, warning, warning.previous_indexing_len) == "undefined" then
         return false
      end

      if not warning.module and get_field_status(normalized_options, warning) ~= "undefined" then
         return false
      end
   end

   if warning.code:find("^1[24][23]") then
      warning.field = get_field_string(warning)
   end

   if warning.secondary and not normalized_options.unused_secondaries then
      return false
   end

   if warning.self and not normalized_options.self then
      return false
   end

   return passes_rules_filter(normalized_options.rules, warning.code, warning.name)
end

local empty_options = {}

-- Updates option_stack for given line with next_index pointing to the inline option past the previous line.
-- Adds warnings for invalid inline options to check_result, filtered_warnings.
-- Returns updated next_index.
local function update_option_stack_for_new_line(check_result, stds, option_stack, line, next_index)
   local inline_option = check_result.inline_options[next_index]

   if not inline_option or inline_option.line > line then
      -- No inline options on this line, option stack for the line is ready.
      return next_index
   end

   next_index = next_index + 1

   if inline_option.pop_count then
      for _ = 1, inline_option.pop_count do
         table.remove(option_stack)
      end
   end

   if not inline_option.options then
      -- No inline option push on this line, option stack for the line is ready.
      return next_index
   end

   local options_ok, err_msg = options.validate(options.all_options, inline_option.options, stds)

   if not options_ok then
      -- Warn about invalid inline option, push a dummy empty table instead to keep pop counts correct.
      inline_option.options = nil
      inline_option.code = "021"
      inline_option.msg = err_msg
      table.insert(check_result.filtered_warnings, inline_option)

      -- Reuse empty table identity so that normalized option caching works better.
      table.insert(option_stack, empty_options)
   else
      table.insert(option_stack, inline_option.options)
   end

   return next_index
end

-- Warns (adds to check_result.filtered_warnings) about a line if it's too long
-- and the warning is not filtered out by options.
local function check_line_length(check_result, normalized_options, line)
   local line_length = check_result.line_lengths[line]
   local line_type = check_result.line_endings[line]
   local max_length = normalized_options["max_" .. (line_type or "code") .. "_line_length"]

   if max_length and line_length > max_length then
      if passes_rules_filter(normalized_options.rules, "631") then
         table.insert(check_result.filtered_warnings, {
            code = "631",
            line = line,
            column = max_length + 1,
            end_column = line_length,
            max_length = max_length,
            line_ending = line_type
         })
      end
   end
end

-- Adds warnings passing filtering and not related to globals to check_result.filtered_warnings.
-- If there is a global related warning on this line, sets check_results[line] to normalized_optuons.
local function filter_warnings_on_new_line(check_result, normalized_options, line, next_index)
   while true do
      local warning = check_result.warnings[next_index]

      if not warning or warning.line > line then
         -- No more warnings on this line.
         break
      end

      if warning.code:find("^1") then
         check_result.normalized_options[line] = normalized_options
      elseif passes_filter(normalized_options, warning) then
         table.insert(check_result.filtered_warnings, warning)
      end

      next_index = next_index + 1
   end

   return next_index
end

-- Normalizing options is relatively expensive because full std definitions are quite large.
-- \`CachingOptionsNormalizer\` implements a caching layer that reduces number of \`options.normalize\` calls.
-- Caching is done based on identities of option tables.

local CachingOptionsNormalizer = utils.class()

function CachingOptionsNormalizer:__init()
   self.result_trie = {}
end

function CachingOptionsNormalizer:normalize_options(stds, option_stack)
   local result_node = self.result_trie

   for _, option_table in ipairs(option_stack) do
      if not result_node[option_table] then
         result_node[option_table] = {}
      end

      result_node = result_node[option_table]
   end

   if result_node.result then
      return result_node.result
   end

   local result = options.normalize(option_stack, stds)
   result_node.result = result
   return result
end

-- May mutate base_opts_stack.
local function filter_not_global_related_in_file(check_result, options_normalizer, stds, option_stack)
   check_result.filtered_warnings = {}
   check_result.normalized_options = {}

   -- Iterate over lines, warnings, and inline options at the same time, keeping opts_stack up to date.
   local next_warning_index = 1
   local next_inline_option_index = 1

   for line in ipairs(check_result.line_lengths) do
      next_inline_option_index = update_option_stack_for_new_line(
         check_result, stds, option_stack, line, next_inline_option_index)
      local normalized_options = options_normalizer:normalize_options(stds, option_stack)
      check_line_length(check_result, normalized_options, line)
      next_warning_index = filter_warnings_on_new_line(check_result, normalized_options, line, next_warning_index)
   end
end

local function may_have_options(opts_table)
   for key in pairs(opts_table) do
      if type(key) == "string" then
         return true
      end
   end

   return false
end

local function get_option_stack(opts, file_index)
   local res = {opts}

   if opts and opts[file_index] then
      -- Don't add useless per-file option tables, that messes up normalized option caching
      -- since it memorizes based on option table identities.
      if may_have_options(opts[file_index]) then
         table.insert(res, opts[file_index])
      end

      for _, nested_opts in ipairs(opts[file_index]) do
         table.insert(res, nested_opts)
      end
   end

   return res
end

-- For each file check result:
-- * Stores invalid inline options, not filtered out not global-related warnings, and newly created line length warnings
--   in .filtered_warnings.
-- * Stores a map from line numbers to normalized options for lines of global-related warnings in .normalized_options.
local function filter_not_global_related(check_results, opts, stds)
   local caching_options_normalizer = CachingOptionsNormalizer()

   for file_index, check_result in ipairs(check_results) do
      if not check_result.fatal then
         if check_result.warnings[1] and check_result.warnings[1].code == "011" then
            -- Special case syntax errors, they don't have line numbers so normal filtering does not work.
            check_result.filtered_warnings = check_result.warnings
            check_result.normalized_options = {}
         else
            local base_file_option_stack = get_option_stack(opts, file_index)
            filter_not_global_related_in_file(check_result, caching_options_normalizer, stds, base_file_option_stack)
         end
      end
   end
end

-- A global is implicitly defined in a file if opts.allow_defined == true and it is set anywhere in the file,
--    or opts.allow_defined_top == true and it is set in the top level function scope.
-- By default, accessing and setting globals in a file is allowed for explicitly defined globals (standard and custom)
--    for that file and implicitly defined globals from that file and
--    all other files except modules (files with opts.module == true).
-- Accessing other globals results in "accessing undefined variable" warning.
-- Setting other globals results in "setting non-standard global variable" warning.
-- Unused implicitly defined global results in "unused global variable" warning.
-- For modules, accessing globals uses same rules as normal files, however,
--    setting globals is only allowed for implicitly defined globals from the module.
-- Setting a global not defined in the module results in "setting non-module global variable" warning.

local function is_definition(normalized_options, warning)
   return normalized_options.allow_defined or (normalized_options.allow_defined_top and warning.top)
end

-- Extracts sets of defined, exported and used globals from a file check result.
local function get_implicit_globals_in_file(check_result)
   local defined = {}
   local exported = {}
   local used = {}

   for _, warning in ipairs(check_result.warnings) do
      if warning.code:find("^11") then
         if warning.code == "111" then
            local normalized_options = check_result.normalized_options[warning.line]

            if is_definition(normalized_options, warning) then
               if normalized_options.module then
                  defined[warning.name] = true
               else
                  exported[warning.name] = true
               end
            end
         else
            used[warning.name] = true
         end
      end
   end

   return defined, exported, used
end

-- Returns set of globals defines across all files except modules, a set of globals used across all files,
-- and an array of sets of globals defined per file, parallel to the check results array.
local function get_implicit_globals(check_results)
   local globally_defined = {}
   local globally_used = {}
   local locally_defined = {}

   for file_index, check_result in ipairs(check_results) do
      if not check_result.fatal then
         local defined, exported, used = get_implicit_globals_in_file(check_result)
         utils.update(globally_defined, exported)
         utils.update(globally_used, used)
         locally_defined[file_index] = defined
      end
   end

   return globally_defined, globally_used, locally_defined
end

-- Mutates the warning and returns it or discards it by returning nothing if it's filtered out.
local function apply_implicit_definitions(globally_defined, globally_used, locally_defined, normalized_options, warning)
   if not warning.code:find("^11") then
      return warning
   end

   if warning.code == "111" then
      if normalized_options.module then
         if locally_defined[warning.name] then
            return
         end

         warning.module = true
      else
         if is_definition(normalized_options, warning) then
            if globally_used[warning.name] then
               return
            end

            warning.code = "131"
            warning.top = nil
         else
            if globally_defined[warning.name] then
               return
            end
         end
      end
   else
      if globally_defined[warning.name] or locally_defined[warning.name] then
         return
      end
   end

   return warning
end

local function filter_global_related_in_file(check_result, globally_defined, globally_used, locally_defined)
   for _, warning in ipairs(check_result.warnings) do
      if warning.code:find("^1") then
         local normalized_options = check_result.normalized_options[warning.line]
         warning = apply_implicit_definitions(
            globally_defined, globally_used, locally_defined, normalized_options, warning)

         if warning then
            if warning.code:find("^11[12]") and not warning.module and
                  get_field_status(normalized_options, warning) == "read_only" then
               warning.code = "12" .. warning.code:sub(3, 3)
            elseif warning.code:find("^11[23]") and get_field_status(normalized_options, warning, 1) ~= "undefined" then
               warning.code = "14" .. warning.code:sub(3, 3)
            end

            if warning.code:match("11[23]") and get_field_status(normalized_options, warning, 1) ~= "undefined" then
               warning.code = "14" .. warning.code:sub(3, 3)
            end

            if passes_filter(normalized_options, warning) then
               table.insert(check_result.filtered_warnings, warning)
            end
         end
      end
   end
end

local function filter_global_related(check_results)
   local globally_defined, globally_used, locally_defined = get_implicit_globals(check_results)

   for file_index, check_result in ipairs(check_results) do
      if not check_result.fatal then
         filter_global_related_in_file(check_result, globally_defined, globally_used, locally_defined[file_index])
      end
   end
end

-- Processes an array of results of the check stage (or tables with .fatal field) into the final report.
-- \`opts[i]\`, if present, is used as options when processing \`report[i]\` together with options in its array part.
-- This function may mutate check results or reuse its parts in the return value.
function filter.filter(check_results, opts, stds)
   filter_not_global_related(check_results, opts, stds)
   filter_global_related(check_results)

   local report = {}

   for file_index, check_result in ipairs(check_results) do
      if check_result.fatal then
         report[file_index] = check_result
      else
         core_utils.sort_by_location(check_result.filtered_warnings)
         report[file_index] = check_result.filtered_warnings
      end
   end

   return report
end

return filter

end)
__bundle_register("luacheck.check", function(require, _LOADED, __bundle_register, __bundle_modules)
local check_state = require("luacheck.check_state")
local core_utils = require("luacheck.core_utils")
local parse_inline_options = require("luacheck.stages.parse_inline_options")
local parser = require("luacheck.parser")
local stages = require("luacheck.stages.init")
local utils = require("luacheck.utils")

local inline_option_fields = utils.array_to_set(parse_inline_options.inline_option_fields)

local function validate_fields(tables, per_code_fields)
   for _, t in ipairs(tables) do
      local fields_set

      if per_code_fields then
         if not t.code then
            error("Warning has no code", 0)
         end

         local warning_info = stages.warnings[t.code]

         if not warning_info then
            error("Unknown issue code " .. t.code, 0)
         end

         fields_set = warning_info.fields_set
      else
         fields_set = inline_option_fields
      end

      for field in pairs(t) do
         if not fields_set[field] then
            error("Unknown field " .. field .. " in " ..
               (per_code_fields and "issue with code " .. t.code or "inline option table"), 0)
         end
      end
   end
end

--- Checks source.
-- Returns a table with results, with the following fields:
--    \`events\`: array of issues and inline option events (options, push, or pop).
--    \`per_line_options\`: map from line numbers to arrays of inline option events.
--    \`line_lengths\`: map from line numbers to line lengths.
--    \`line_endings\`: map from line numbers to "comment", "string", or \`nil\` base on
--                    whether the line ending is within a token.
-- If \`events\` array contains a syntax error, the other fields are empty tables.
local function check(source)
   local chstate = check_state.new(source)
   local ok, error_wrapper = utils.try(stages.run, chstate)
   local warnings, inline_options, line_lengths, line_endings

   if ok then
      warnings = chstate.warnings
      core_utils.sort_by_location(warnings)
      inline_options = chstate.inline_options
      line_lengths = chstate.line_lengths
      line_endings = chstate.line_endings
   else
      local err = error_wrapper.err

      if not utils.is_instance(err, parser.SyntaxError) then
         error(error_wrapper, 0)
      end

      local syntax_error = {
         code = "011",
         line = err.line,
         column = chstate:offset_to_column(err.line, err.offset),
         end_column = chstate:offset_to_column(err.line, err.end_offset),
         msg = err.msg
      }

      if err.prev_line then
         syntax_error.prev_line = err.prev_line
         syntax_error.prev_column = chstate:offset_to_column(err.prev_line, err.prev_offset)
         syntax_error.prev_end_column = chstate:offset_to_column(err.prev_line, err.prev_end_offset)
      end

      warnings = {syntax_error}
      inline_options = {}
      line_lengths = {}
      line_endings = {}
   end

   validate_fields(warnings, true)
   validate_fields(inline_options)

   return {
      warnings = warnings,
      inline_options = inline_options,
      line_lengths = line_lengths,
      line_endings = line_endings
   }
end

return check

end)
__bundle_register("luacheck.check_state", function(require, _LOADED, __bundle_register, __bundle_modules)
local utils = require("luacheck.utils")

local check_state = {}

local CheckState = utils.class()

function CheckState:__init(source_bytes)
   self.source_bytes = source_bytes
   self.warnings = {}
end

-- Returns column of a character in a line given its offset.
-- The column is never larger than the line length.
-- This can be called if line length is not yet known.
function CheckState:offset_to_column(line, offset)
   local line_length = self.line_lengths[line]
   local column = offset - self.line_offsets[line] + 1

   if not line_length then
      return column
   end

   return math.max(1, math.min(line_length, column))
end

function CheckState:warn_column_range(code, range, warning)
   warning = warning or {}
   warning.code = code
   warning.line = range.line
   warning.column = range.column
   warning.end_column = range.end_column
   table.insert(self.warnings, warning)
   return warning
end

function CheckState:warn(code, line, offset, end_offset, warning)
   warning = warning or {}
   warning.code = code
   warning.line = line
   warning.column = self:offset_to_column(line, offset)
   warning.end_column = self:offset_to_column(line, end_offset)
   table.insert(self.warnings, warning)
   return warning
end

function CheckState:warn_range(code, range, warning)
   return self:warn(code, range.line, range.offset, range.end_offset, warning)
end

function CheckState:warn_var(code, var, warning)
   warning = self:warn_range(code, var.node, warning)
   warning.name = var.name
   return warning
end

function CheckState:warn_value(code, value, warning)
   warning = self:warn_range(code, value.var_node, warning)
   warning.name = value.var.name
   return warning
end

function check_state.new(source_bytes)
   return CheckState(source_bytes)
end

return check_state

end)
luacheck = __bundle_require("__root")`});var{LuaFactory:ga}=kt(),ba=xt();(async()=>{let h=new ga,P=await h.createEngine();await P.doString(ba),Object.assign(globalThis,{luacheck:P.global.get("luacheck")})})();})();
//# sourceMappingURL=index.min.js.map
